<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="icon" type="image/png" href="logo.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docs</title>
    <link href="https://fonts.googleapis.com/css?family=Poppins:100,200,300,400,500,600,700,800,900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <!-- Intro screen -->
    <div id="intro-screen">
        <div id="intro-text-wrapper">
            <span class="intro-letter">D</span>
            <span class="intro-letter">o</span>
            <span class="intro-letter">c</span>
            <span class="intro-letter">s</span>
        </div>
        <div class="intro-logo">Arub Â© 2024 - 2025</div>
    </div>

    <div id="main-content-wrapper" class="hidden">
    <canvas id="particleCanvas"></canvas>
    <nav class="navbar">
        <div class="hamburger-menu">
            <div class="hamburger-lines">
                <span class="line line1"></span>
                <span class="line line2"></span>
                <span class="line line3"></span>
            </div>
            <div class="side-menu">
                <a href="index.html" class="menu-item">
                    <h5 class="left-navbar-text">
                        <div class="code-language">
                            <i class="language-icon home"></i>
                        </div>
                        Home
                    </h5>
                </a>
                <a href="Projects.html" class="menu-item">
                    <h5 class="left-navbar-text">
                        <div class="code-language">
                            <i class="language-icon project"></i>
                        </div>
                        Projects
                    </h5>
                </a>
                <a href="Certifications.html" class="menu-item">
                    <h5 class="left-navbar-text">
                        <div class="code-language">
                            <i class="language-icon certification"></i>
                        </div>
                        Certifications
                    </h5>
                </a>
                <a href="About.html" class="menu-item">
                    <h5 class="left-navbar-text">
                        <div class="code-language">
                            <i class="language-icon about"></i>
                        </div>
                        About
                    </h5>
                </a>
            </div>
        </div>
        <div class="nav-container">
            <div class="nav-items">

                <div class="nav-item">
                    <span style="position: relative; left: -39px;">Profiles</span>
                    <div class="nav-content">
                        <a href="https://github.com/arubbinali/" data-hover="arubbinali" target="_blank">GitHub</a>
                        <a href="https://www.linkedin.com/in/arubbinali/" data-hover="arubbinali" target="_blank">LinkedIn</a>
                        <a href="https://leetcode.com/u/arubbinali/" data-hover="arubbinali" target="_blank">Leetcode</a>
                        <a href="https://www.khanacademy.org/profile/mbinali06" data-hover="mbinali06" target="_blank">Khan Academy</a>
                    </div>
                </div>
                <div class="nav-item">
                    <span style="position: relative; left: -17px;">Contact</span>
                    <div class="nav-content">
                        <a href="#" data-hover="arubbinali@outlook.com" onclick="noScroll(event);">Mail</a>
                        <a href="#" data-hover="arub" onclick="noScroll(event);">Discord</a>
                    </div>
                </div>

            </div>
            <div class="hover-text"></div>
        </div>
    </nav>

    <main>
        <div class="center-text">
            <div class="aura-text">Docs</div>
            <div class="code-text">Licensed Code and Notes for My Projects & Certifications</div>
        </div>

        <div class="scroll-spacer" style="height: 0vh;"></div>

        <div class="content-sections">
            <h2 class="project-heading">Projects</h2>
            <div class="glow-line"></div>
            <div class="code-snippets-container">


                <!-- School Site -->
                <div id="school-docs">
                <section class="info-section">
                <h2 class="project-heading">My School's Revamped Website (Main Page)</h2>

                <!-- School HTML -->
                <div class="code-snippet">
                    <div class="code-snippet-header">
                        <h5 class="code-snippet-title">
                            <div class="code-language">
                                <i class="language-icon html"></i>
                            </div>
                            main.html
                        </h5>
                        <button class="code-snippet-toggle">+</button>
                    </div>
                    
                    <div class="code-snippet-content">
                        <pre class="code-snippet-code"><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Revamped Elite School Website&lt;/title&gt;
    &lt;link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet"&gt;
    &lt;link rel="icon" href="favicon.png" type="image/png"&gt;
    &lt;link rel="stylesheet" href="styles.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="screen-overlay"&gt;&lt;/div&gt;</code></pre>
                        <div class="scrolling-text">No Access</div>
                        <h5 class="code-snippet-title">&nbsp;</h5>
                        <h5 class="code-snippet-title">Code length:&nbsp;&nbsp;&nbsp;724 lines</h5>
                        <h5 class="code-snippet-title">&nbsp;</h5>
                    </div>
                </div>

                

                <!-- School CSS -->
                <div class="code-snippet">

                    <div class="code-snippet-header">
                        <h5 class="code-snippet-title">
                            <div class="code-language">
                                <i class="language-icon css"></i>
                            </div>
                            syles.css
                        </h5>
                        <button class="code-snippet-toggle">+</button>
                    </div>

                    <div class="code-snippet-content">
                        <pre class="code-snippet-code"><code class="language-css">/* General */
body {
    font-family: 'Poppins', sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f0f0f0;
    color: #333;
    transition: background-color 1.5s, color 0.3s;
}
/* Dark Mode */
body.dark-mode {
    background-color: #1a1a1a;
    color: #f0f0f0;
}</code></pre>
                        <div class="scrolling-text">No Access</div>
                        <h5 class="code-snippet-title">&nbsp;</h5>
                        <h5 class="code-snippet-title">Code length:&nbsp;&nbsp;&nbsp;2,092 lines</h5>
                        <h5 class="code-snippet-title">&nbsp;</h5>
                    </div>
                </div>

                <!-- JavaScript Code Snippet -->
                <div class="code-snippet">

                    <div class="code-snippet-header">
                        <h5 class="code-snippet-title">
                            <div class="code-language">
                                <i class="language-icon javascript"></i>
                            </div>
                            script.js
                        </h5>
                        <button class="code-snippet-toggle">+</button>
                    </div>

                    <div class="code-snippet-content">
                        
                        <pre class="code-snippet-code"><code class="language-javascript">window.onload = function () {
    showPopup();
};
function showPopup() {
    const popup = document.getElementById("popup");
    popup.style.display = "flex";
    setTimeout(() => {
        popup.style.opacity = "1";
    }, 100);
}
function closePopup() {
    const popup = document.getElementById('popup');
    popup.style.opacity = "0";
    popup.addEventListener('transitionend', function (e) {
        if (popup.style.opacity === "0") {
            popup.style.display = 'none';
        }
    }, { once: true });
}
//Yeah buddy good try tryna sneak in but u rlly aint getting to see nun lol</code></pre>
                        <div class="scrolling-text">No Access</div>
                        <h5 class="code-snippet-title">&nbsp;</h5>
                        <h5 class="code-snippet-title">Code length:&nbsp;&nbsp;&nbsp;454 lines</h5>
                        <h5 class="code-snippet-title">&nbsp;</h5>
                    </div>
                </div>


                <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;3,270 lines</h5>
                <button class="see-more-btn" onclick="window.open('https://arubbinali.github.io/Projects.html#school-projects', '_blank')">
                    <i class="language-icon project"></i>
                    View Project
                </button>
                
            </section>
            </div>



                <!-- Islamic Inheritance Calculator -->
                <div id="inheritance-docs">
                <section class="info-section">
                <h2 class="project-heading">Islamic Inheritance Calculator</h2>
                <div class="code-snippet">
                    <div class="code-snippet-header">
                        <h5 class="code-snippet-title">
                            <div class="code-language">
                                <i class="language-icon python"></i>
                            </div>
                            Inheritance.py
                        </h5>
                        <button class="code-snippet-toggle">+</button>
                    </div>

                    <div class="code-snippet-content">
                        
                        <pre class="code-snippet-code"><code class="language-python">#Heirs' input

#-------------------------------------Validation using Flag for Input Variables-------------------------------------

from time import sleep                      #For Delay 
from art import tprint                      #For Starting font
import matplotlib.pyplot as plt             #For Pie Chart
from rich.tree import Tree                  #For Tree Structure
from rich import print                      #console.print > for Table 
from rich.console  import Console           #Needed this library for Table
from rich.table import Table                #For Table Structure
from rich.progress import track             #For Scrapping Data Representation
from fractions import Fraction              #For Fractions in case of Non-reccuring

console = Console()

tree = Tree("Tree view")

table = Table(show_header=True, header_style="bold magenta")
table.add_column("Relation", style="dim", width=23)
table.add_column("Prescribed share")
table.add_column("Percentage", justify="right")
table.add_column("Inherited amount", justify="right")

tprint("     Welcome   ",font="tarty1")
sleep(1)
tprint("\n      To",font="tarty1")
sleep(1)
tprint("\n      Inheritance",font="tarty1")
sleep(1)
tprint("\n      Calculator",font="tarty1")
sleep(1)
tprint("\n      by           Arub!",font="tarty1")
sleep(1)

    #Husband + Wife
inp=False
while not inp:
    try:        
            
            #Husband
            print("\n       Enter surviving [green]Husband[/green] (0 or 1) ?        ")
            h=int(input("                                            "))
        
            if h<0 or h>1:
                print("       [red]Husband can only be 1 or 0[/red]")
            else:
                while not inp:

                    #Wife
                    print("\n       Enter surviving [green]Wives[/green] (0 to 4) ?        ")
                    w=int(input("                                            "))
                    if w<0 or w>4:
                            print("       [red]Wives can only be from 0 to 4[red]")
                    else:

                        #Husband + Wife
                        if h>0 and w>0:
                            inp = False
                            print("\n       [red]Husband & Wife both cannot be alive[/red]")
                        else:
                            inp = True
    
    except ValueError:
        print("\n       [red]Please give valid input[/red]")
        
#Father
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Father[/green] (0 or 1) ?        ")
        f = int(input("                                            "))
        if f == 0 or f == 1 :
            inp=True   
        else :
            print("\n       [red]Father can not be more than 1 or less than 0")
            #print("\n       Kindly Re-enter")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")

#Mother
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Mother[/green] (0 or 1) ?        ")
        m = int(input("                                            "))
        if m == 0 or m == 1 :
            inp=True   
        else :
            print("\n       [red]Mother can not be more than 1 or less than 0")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")
        
#Daughter
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Daughter(s)[/green] ?        ")
        d = int(input("                                            "))
        if d >= 0 :
            inp=True   
        else :
            print("\n       [red]Daughter can not be less than 0")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")

#Son
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Son(s)[/green] ?        ")
        s = int(input("                                            "))
        if s >= 0 :
            inp=True   
        else :
            print("\n       [red]Son can not be less than 0")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")


#Brother
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Brother(s)[/green] ?        ")
        b = int(input("                                            "))
        if b >= 0 :
            inp=True   
        else :
            print("\n       [red]Brother can not be less than 0")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")


#Sister
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Sister(s)[/green] ?        ")
        si = int(input("                                            "))
        if si >= 0 :
            inp=True   
        else :
            print("\n       [red]Mother can not be more than 1 or less than 0")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")


#Paternal Grand Father
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Paternal Grand Father[/green] (0 or 1) ?        ")
        pgf = int(input("                                            "))

        if pgf == 0 or pgf == 1 :
            inp=True   
        else :
            print("\n       [red]Paternal Grand Father can not be more than 1 or less than 0")
            #print("\n       Re-enter")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")


#Paternal Grand Mother
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Paternal Grand Mother[/green] (0 or 1) ?        ")
        pgm = int(input("                                            "))
        if pgm == 0 or pgm == 1 :
            inp=True   
        else :
            print("\n       [red]Paternal Grand Mother can not be more than 1 or less than 0")
            #print("\n       Re-enter")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")


#Maternal Grand Mother
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Maternal Grand Mother[/green] (0 or 1) ?        ")
        mgm = int(input("                                            "))
        if mgm == 0 or mgm == 1 :
            inp=True   
        else :
            print("\n      [red]Maternal Grand Mother can not be more than 1 or less than 0")
            #print("\n       Re-enter")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")

#Grand Son
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Grand Son(s)[/green] ?        ")
        gs = int(input("                                            "))
        if gs >= 0 :
            inp=True   
        else :
            print("\n       [red]Grand Son can not be less than 0")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")


#Grand Daughter
inp=False
while not inp :
    try:
        print("\n       Enter surviving [green]Grand Daughter(s)[/green] ?        ")
        gd = int(input("                                            "))
        if gd >= 0 :
            inp=True   
        else :
            print("\n       [red]Grand Daughter can not be less than 0")
            inp=False
    except ValueError :
        print("\n       [red]Please give valid input")        



#Inheritance applicable amount calculation
first_amount = -1
while first_amount <= 0 :

    print("\n       (i) [bold][red]Zakat[/red][/bold], (ii) [bold][red]Wife's Mehr[/red][/bold] and (iii) [bold][red]Loan[/red][/bold] have to be paid first from the leftover Wealth. \n       So kindly enter respective amounts : ")
            
    inp=False
    while not inp : #Wealth
        try:
            print("\n       Enter [green]wealth of deceased[/green] :   ")
            wealth = int(input("                                            "))
            if wealth <0:
                print("       [red]Give [bold]positive[/bold] number")
                inp=False
            else :
                inp=True
        except ValueError :
            print("\n     [red]  Please give valid input")


    inp=False
    while not inp : #Zakat
        try:
            print("\n       Enter any [green]outstanding zakat :   ")
            zakat = int(input("                                           "))
            if zakat <0:
                print("       [red]Give [bold]positive[/bold] amount")
                #print("\n       Re-enter")
                inp=False
            else :
                inp=True
        except ValueError :
            print("\n       [red]Please give valid input")
                

    inp=False
    while not inp : #Mehr
        try:
            print("\n       Enter [green]Mehr[/green] (if not paid yet to wife) :   ")      
            mehr = int(input("                                           "))
            if mehr <0:
                print("       [red]Give [bold]positive[/bold] amount")
                #print("\n       Re-enter")
                inp=False
            else :
                inp=True
        except ValueError :
            print("\n       [red]Please give valid input")


    inp=False
    while not inp : #Loan
        try:
            print("\n       Enter any [green]outstanding loan :   ")
            loan = int(input("                                           "))
            if loan <0:
                print("       [red]Give [bold]positive[/bold] amount")
                #print("\n       Re-enter")
                inp=False
            else :
                inp=True
        except ValueError :
            print("\n       [red]Please give valid input")

    print("\n      :point_right: [bold][u][yellow]Maximum 1/3rd of WILL (wasiyat) by deceased, can be executed in favor of Non-Heirs [red]only.")

    inp=False
    while not inp : #Will
        try:
            print("\n       Enter amount of [green]WILL[/green] if any : ")
            will = int(input("                                           "))
            if will <0:
                print("\n       [red]Give [bold]positive[/bold] amount")
                #print("\n       Re-enter")
                inp=False
            else :
                inp=True
        except ValueError :
            print("\n       [red]Please give valid input")


    first_amount = wealth - zakat - mehr - loan
    if first_amount <=0:
        print("       :red_circle:   ",first_amount," [red]is not applicable for Inheritance distribution[/red]. Kindly re-enter the amounts.")
        sleep(2)


#Adjusting the WILL to 1/3rd at most
if will<= first_amount/3:
    amount = first_amount - will
    print("\n      [blue][bold] :large_blue_circle: Applicable amount for inheritance is : :point_right: ", amount,"\n\n")

else :
    will= first_amount/3
    amount = first_amount - will
    print("\n       [blue][bold]:large_blue_circle: Applicable amount for inheritance is : :point_right: ", amount,"\n\n")

#-----------------------------------------Validation completed-----------------------------------------
        
#initial heirs' shares
hs = 0
ws = 0
fs = 0
ms = 0
ds = 0  
ss = 0
pgfs = 0 
pgms = 0
mgms = 0
bs = 0
sis = 0
gss = 0
gds = 0

#-----------------------------------------Scenario 1: Son alive---------------------------------------------------------
if s >= 1 :

    #Husband
    if h == 1 :        
        hs = (1/4)*amount
        sleep(1)
        hsp=hs/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Husband'):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Husband gets 1/4th prescribed share: " , round(hs,3),"\n\n")
        tree.add("Husband 1/4 " + str(round(hs,3))).add("[green] 1/4").add("[blue] "+str(round(hs,3)))
        table.add_row("Husband", "1/4", str(round(hsp,3)) + '%', str(round(hs,3)))
        sleep(1)

    #wife
    elif h == 0 and w == 1:        
        ws = (1/8)*amount
        sleep(1)
        wsp=ws/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance for Wife            '):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Wife gets 1/8th prescribed share: " , round(ws,3),"\n\n")
        tree.add("Wife 1/8 " + str(round(ws,3))).add("[green] 1/8").add("[blue] "+str(round(ws,3)))
        table.add_row("Wife", "1/8", str(round(wsp,3)) + '%', str(round(ws,3)))
        sleep(1)

    #Multiple Wives
    elif h == 0 and w > 1 :
        ws = (1/8)*amount
        wsp=ws/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance for Wives           '):
            sleep(.1)
            step
        print("\n       :small_red_triangle: All wives combined get 1/8th prescribed share:" , round(ws,3))
        tree.add("Wives 1/8 " + str(round(ws,3))).add("[green] 1/8").add("[blue] "+str(round(ws,3)))
        table.add_row("Wives", "1/8", str(round(wsp,3)) + '%', str(round(ws,3)))
        ews=ws/w
        ewsp=ews/amount*100

        if w==3 :
            table.add_row("  Each wife", "1/24", str(round(ewsp,3)) + '%', str(round(ews,3)))
        else :
            ewsf=1/8/w
            table.add_row("  Each wife", str(Fraction(ewsf)), str(round(ewsp,3)) + '%', str(round(ews,3)))

        sleep(1)
        print("\n       Each wife gets: ", ews,"\n\n")
        sleep(1)

    #Father
    if f == 1 :        
        fs = (1/6)*amount
        sleep(1)
        fsp=fs/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Father    '):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Father gets 1/6th prescribed share: " , round(fs,3),"\n\n")
        tree.add("Father 1/6 " + str(round(fs,3))).add("[green] 1/6").add("[blue] "+str(round(fs,3)))
        table.add_row("Father", "1/6", str(round(fsp,3)) + '%', str(round(fs,3)))
        sleep(1)

    #Paternal Grand Father
    elif pgf == 1 and f == 0:     
        pgfs = (1/6)*amount
        sleep(1)
        pgfsp=pgfs/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Father'):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Paternal Grand Father gets 1/6th prescribed share: " , round(pgfs,3),"\n\n")
        tree.add("Paternal Grand Father 1/6 " + str(round(pgfs,3))).add("[green] 1/6").add("[blue] "+str(round(pgfs,3)))
        table.add_row("Paternal Grand Father", "1/6", str(round(pgfsp,3)) + '%', str(round(pgfs,3)))
        sleep(1)


    #Mother
    if m == 1 :        
        ms = (1/6)*amount
        sleep(1)
        msp=ms/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Mother    '):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Mother gets 1/6th prescribed share: " , round(ms,3),"\n\n")
        tree.add("Mother 1/6 " + str(round(ms,3))).add("[green] 1/6").add("[blue] "+str(round(ms,3)))
        table.add_row("Mother", "1/6", str(round(msp,3)) + '%', str(round(ms,3)))
        sleep(1)


    #Paternal Grand Mother
    elif pgm == 1 and f == 0 and m == 0 and mgm == 0 :
        pgms=(1/6)*amount
        sleep(1)
        pgmsp=pgms/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Mother'):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Paternal Grand Mother gets 1/6th prescribed share: " , round(pgms,3),"\n\n")
        tree.add("Paternal Grand Mother 1/6 " + str(round(pgms,3))).add("[green] 1/6").add("[blue] "+str(round(pgms,3)))
        table.add_row("Paternal Grand Mother", "1/6", str(round(pgmsp,3)) + '%', str(round(pgms,3)))
        sleep(1)



    #Paternal + Maternal Grandmother
    elif pgm == 1 and f == 0 and m == 0 and mgm == 1 :
        pgms=(1/12)*amount
        pgmsp=pgms/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for both Paternal & Maternal Grand Mothers'):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Paternal Grand Mother gets 1/12th prescribed share: " , round(pgms,3),"\n")
        tree.add("Paternal Grand Mother 1/12 " + str(round(pgms,3))).add("[green] 1/12").add("[blue] "+str(round(pgms,3)))
        table.add_row("Paternal Grand Mother", "1/12", str(round(pgmsp,3)) + '%', str(round(pgms,3)))
        sleep(1)
        
        mgms=(1/12)*amount
        mgmsp=mgms/amount*100
        
        print("\n       :small_red_triangle: Maternal Grand Mother gets 1/12th prescribed share: " , round(mgms,3),"\n\n")
        tree.add("Maternal Grand Mother 1/12 " + str(round(mgms,3))).add("[green] 1/12").add("[blue] "+str(round(mgms,3)))
        table.add_row("Maternal Grand Mother", "1/12", str(round(mgmsp,3)) + '%', str(round(mgms,3)))
        sleep(1)


    #Maternal Grand Mother
    elif mgm == 1 and m == 0 :
        mgms=(1/6)*amount
        sleep(1)
        mgmsp=mgms/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Maternal Grand Mother'):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Maternal Grand Mother gets 1/6th prescribed share: " , round(mgms,3),"\n\n")
        tree.add("Maternal Grand Mother 1/6 " + str(round(mgms,3))).add("[green] 1/6").add("[blue] "+str(round(mgms,3)))
        table.add_row("Maternal Grand Mother", "1/6", str(round(mgmsp,3)) + '%', str(round(mgms,3)))
        sleep(1)
    

    #Sum Of Prescribed Shares + Remainder
    sops = ( hs + ws + fs + ms + ds + ss + pgfs + pgms + mgms )
    remainder = amount - sops
    

    #Daughter 
    if d == 1 :
        ds=d/((s*2)+d)*(remainder)
        dsp=ds/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Daughter  '):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Daughter gets half ratio to son from remaining: " , round(ds,3),"\n\n")
        tree.add("Daughter 1:2 Ratio to Son(s) " + str(round(ds,3))).add("[green] Ratio").add("[blue] "+str(round(ds,2)))
        table.add_row("Daughter", "1:2 Ratio with Son(s)", str(round(dsp,3)) + '%', str(round(ds,3)))
        sleep(1)


    #Multiple Daughters
    elif d > 1 :
        ds=d/((s*2)+d)*(remainder)
        dsp=ds/amount*100
        edsp=ds/d/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Daughters '):
            sleep(.1)
            step
        print("\n       :small_red_triangle: All Daughters combined, get half ratio to sons from remaining: " , round(ds,3))
        tree.add("Daughters 1:2 Ratio to Son " + str(round(ds,3))).add("[green] Ratio").add("[blue] "+str(round(ds,2)))
        table.add_row("Daughter(s)", "1:2 Ratio to Son", str(round(dsp,3)) + '%', str(round(ds,3)))
        table.add_row("  Each Daughter", "1:2 Ratio to Son", str(round(edsp,3)) + '%', str(round(ds/d,3)))
        
        
        sleep(1)
        
        print("\n       Each daughter gets : " , round(ds/d,3),"\n\n")

        sleep(1)


    #Sons
    if s == 1:    
        ss=s*2/((s*2)+d)*(remainder)
        ssp=ss/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Son       '):
            sleep(.1)
            step
        print("\n       :small_red_triangle: Son gets remaining OR twice to daughter: " , round(ss,3),"\n\n")
        tree.add("Son Remaining OR 2:1 to Daughter(s) " + str(round(ss,3))).add("[green] Remaining OR Ratio").add("[blue] "+str(round(ss,2)))
        table.add_row("Son", "Remaining OR 2:1 to Daughter", str(round(ssp,3)) + '%', str(round(ss,3)))

        sleep(1)
    #Multiple Sons
    elif s > 1:
        ss=s*2/((s*2)+d)*(remainder)
        ssp=ss/amount*100
        essp=ss/s/amount*100
        for step in track(range(15), description='[green]    Calculating Inheritance share for Sons      '):
            sleep(.1)
            step
        print("\n       :small_red_triangle: All Sons combined, get remaining OR twice to daughter: " , round(ss,3))
        tree.add("Son Remaining OR 2:1 to Daughter(s) " + str(round(ss,3))).add("[green] Remaining OR Ratio").add("[blue] "+str(round(ss,2)))
        table.add_row("Sons", "Remaining OR 2:1 to Daughter", str(round(ssp,3)) + '%', str(round(ss,3)))
        table.add_row("  Each Son", "2:1 to Daughter", str(round(essp,3)) + '%', str(round(ss/s,3)))
        sleep(1)
        print("\n       Each son gets: " , round(ss/s,3),"\n\n")
        sleep(1)

    #Inheritance distributed
    #print(remainder)
    print("\n        [green]*** All inheritance distributed ***\n\n")

#-----------------------------------------Scenario 2: No Son but Daughter alive-----------------------------------------
if s==0 and d >= 1 : 
                
        #Husband 
        if h == 1 :        
            hs = (1/4)*amount
            sleep(1)
            hsp=hs/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Husband'):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Husband gets 1/4th prescribed share: " , round(hs,3),"\n\n")
            tree.add("Husband 1/4 " + str(round(hs,3))).add("[green] 1/4").add("[blue] "+str(round(hs,3)))
            table.add_row("Husband", "1/4", str(round(hsp,3)) + '%', str(round(hs,3)))
            sleep(1)
                

        #Wife
        elif h == 0 and w == 1:        
            ws = (1/8)*amount
            sleep(1)
            wsp=ws/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance for Wife            '):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Wife gets 1/8th prescribed share: " , round(ws,3),"\n\n")
            tree.add("Wife 1/8 " + str(round(ws,3))).add("[green] 1/8").add("[blue] "+str(round(ws,3)))
            table.add_row("Wife", "1/8", str(round(wsp,3)) + '%', str(round(ws,3)))
            sleep(1)


        #Multiple Wives
        elif h == 0 and w > 1 :
            ws = (1/8)*amount
            wsp=ws/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance for Wives           '):
                sleep(.1)
                step
            print("\n       :small_red_triangle: All wives combined get 1/8th prescribed share:" , round(ws,3))
            tree.add("Wives 1/8 " + str(round(ws,3))).add("[green] 1/8").add("[blue] "+str(round(ws,3)))
            table.add_row("Wives", "1/8", str(round(wsp,3)) + '%', str(round(ws,3)))
            ews=ws/w
            ewsp=ews/amount*100

            if w==3 :
                table.add_row("  Each wife", "1/24", str(round(ewsp,3)) + '%', str(round(ews,3)))
            else :
                ewsf=1/8/w
                table.add_row("  Each wife", str(Fraction(ewsf)), str(round(ewsp,3)) + '%', str(round(ews,3)))

            sleep(1)
            print("\n       Each wife gets: ", ews,"\n\n")
            sleep(1)

        #Daughter
        if d == 1 :
            ds=(1/2)*amount
            dsp=ds/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Daughter  '):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Daughter gets 1/2 prescribed share: " , round(ds,3),"\n\n")
            tree.add("Daughter 1/2 " + str(round(ds,3))).add("[green] 1/2").add("[blue] "+str(round(ds,2)))
            table.add_row("Daughter", "1/2", str(round(dsp,3)) + '%', str(round(ds,3)))
            sleep(1)
            

        #Multiple Daughters
        elif d > 1 :
                ds=(2/3)*amount
                dsp=ds/amount*100
                edsp=ds/d/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Daughters '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: All Daughters combined, get 2/3: " , round(ds,3))
                tree.add("Daughters 2/3 " + str(round(ds,3))).add("[green] 2/3").add("[blue] "+str(round(ds,2)))
                table.add_row("Daughter(s)", "2/3", str(round(dsp,3)) + '%', str(round(ds,3)))
                edsf=2/3/d
                table.add_row("  Each Daughter", str(Fraction(edsf)) , str(round(edsp,3)) + '%', str(round(ds/d,3)))
                sleep(1)
                print("\n       Each daughter gets : " , round(ds/d,3),"\n\n")
                sleep(1)


        #Father
        if f == 1 :        
            fs = (1/6)*amount
            sleep(1)
            fsp=fs/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Father    '):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Father gets 1/6th prescribed share: " , round(fs,3),"\n\n")
            tree.add("Father 1/6 " + str(round(fs,3))).add("[green] 1/6").add("[blue] "+str(round(fs,3)))
            table.add_row("Father", "1/6", str(round(fsp,3)) + '%', str(round(fs,3)))
            sleep(1)


        #Paternal Grand Father
        elif pgf == 1 and f == 0:     
            pgfs = (1/6)*amount
            sleep(1)
            pgfsp=pgfs/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Father'):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Paternal Grand Father gets 1/6th prescribed share: " , round(pgfs,3),"\n\n")
            tree.add("Paternal Grand Father 1/6 " + str(round(pgfs,3))).add("[green] 1/6").add("[blue] "+str(round(pgfs,3)))
            table.add_row("Paternal Grand Father", "1/6", str(round(pgfsp,3)) + '%', str(round(pgfs,3)))
            sleep(1)


        #Mother
        if m == 1 :        
            ms = (1/6)*amount
            sleep(1)
            msp=ms/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Mother    '):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Mother gets 1/6th prescribed share: " , round(ms,3),"\n\n")
            tree.add("Mother 1/6 " + str(round(ms,3))).add("[green] 1/6").add("[blue] "+str(round(ms,3)))
            table.add_row("Mother", "1/6", str(round(msp,3)) + '%', str(round(ms,3)))
            sleep(1)


        #Paternal Grand Mother
        elif pgm == 1 and f == 0 and m == 0 and mgm == 0 :
            pgms=(1/6)*amount
            sleep(1)
            pgmsp=pgms/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Mother'):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Paternal Grand Mother gets 1/6th prescribed share: " , round(pgms,3),"\n\n")
            tree.add("Paternal Grand Mother 1/6 " + str(round(pgms,3))).add("[green] 1/6").add("[blue] "+str(round(pgms,3)))
            table.add_row("Paternal Grand Mother", "1/6", str(round(pgmsp,3)) + '%', str(round(pgms,3)))
            sleep(1)


        #Paternal Grand Mother + Maternal Grand Mother                
        elif pgm == 1 and f == 0 and m == 0 and mgm == 1 :
            pgms=(1/12)*amount
            pgmsp=pgms/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for both Paternal & Maternal Grand Mothers'):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Paternal Grand Mother gets 1/12th prescribed share: " , round(pgms,3),"\n")
            tree.add("Paternal Grand Mother 1/12 " + str(round(pgms,3))).add("[green] 1/12").add("[blue] "+str(round(pgms,3)))
            table.add_row("Paternal Grand Mother", "1/12", str(round(pgmsp,3)) + '%', str(round(pgms,3)))
            sleep(1)
            
            mgms=(1/12)*amount
            mgmsp=mgms/amount*100
            
            print("\n       :small_red_triangle: Maternal Grand Mother gets 1/12th prescribed share: " , round(mgms,3),"\n\n")
            tree.add("Maternal Grand Mother 1/12 " + str(round(mgms,3))).add("[green] 1/12").add("[blue] "+str(round(mgms,3)))
            table.add_row("Maternal Grand Mother", "1/12", str(round(mgmsp,3)) + '%', str(round(mgms,3)))
            sleep(1)



        #Maternal Grand Mother
        elif mgm == 1 and m == 0 :
            mgms=(1/6)*amount
            sleep(1)
            mgmsp=mgms/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Maternal Grand Mother'):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Maternal Grand Mother gets 1/6th prescribed share: " , round(mgms,3),"\n\n")
            tree.add("Maternal Grand Mother 1/6 " + str(round(mgms,3))).add("[green] 1/6").add("[blue] "+str(round(mgms,3)))
            table.add_row("Maternal Grand Mother", "1/6", str(round(mgmsp,3)) + '%', str(round(mgms,3)))
            sleep(1)


        # Grand Daughter 1/6th Share
        if gd == 1 and gs == 0 and d == 1 :
            gds=(1/6)*amount
            sleep(1)
            gdsp=gds/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughter       '):
                sleep(.1)
                step
            print("\n       :small_red_triangle: Grand Daughter gets 1/6th prescribed share: " , round(gds,3),"\n\n")
            tree.add("Grand Daughter 1/6 " + str(round(gds,3))).add("[green] 1/6").add("[blue] "+str(round(gds,3)))
            table.add_row("Grand Daughter", "1/6", str(round(gdsp,3)) + '%', str(round(gds,3)))
            sleep(1)

        if gd > 1 and gs == 0 and d == 1 :
            gds=(1/6)*amount
            sleep(1)
            gdsp=gds/amount*100
            egds=gds/gd
            egdsp=egds/amount*100
            for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughters       '):
                sleep(.1)
                step
            print("\n       :small_red_triangle: All Grand Daughters combined, get 1/6th prescribed share: " , round(gds,3))
            tree.add("Grand Daughters 1/6 " + str(round(gds,3))).add("[green] 1/6").add("[blue] "+str(round(gds,3)))
            table.add_row("Grand Daughter(s)", "1/6", str(round(gdsp,3)) + '%', str(round(gds,3)))
            egdsf=1/6/gd
            table.add_row("  Each Grand Daughter", egdsf , str(round(egdsp,3)) + '%', str(round(egds,3)))
            sleep(1)

            print("\n       Each Grand daughter gets : " , round(egds,3),"\n\n")
        

        #Sum Of Prescribed Shares + Remainder
        sops = ( hs + ws + fs + ms + ds + ss + pgfs + pgms + mgms + gds )
        remainder = amount - sops


        #Inheritance distributed
        if remainder == 0 :
                print("\n        [green]*** All inheritance distributed ***")


#-------------------------Scenario 2---A: No Son but Daughter alive --- Amount Leftover----------------------------
        remainder=round(remainder,0)
        if remainder > 0 :
                print("\n       Prescribed shares distribution has leftover amount : ", remainder,"\n\n       [bold][blue]Tasib will be checked\n\n")
                

                #Grand Son
                if gs >= 1 and gd == 0:
                    
                    
                    gss=remainder
                    if gs == 1:
                        sleep(1)
                        gssp=gss/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Son'):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Grand Son gets all remaining: " , round(gss,3),"\n\n")
                        tree.add("Grand Son : Tasib" + str(round(gss,3))).add("[green] All remaining").add("[blue] "+str(round(gss,3)))
                        table.add_row("Grand Son", "Tasib", str(round(gssp,3)) + '%', str(round(gss,3)))
                        sleep(1)
                        
                    
                    elif gs > 1:
                        gss=remainder
                        gssp=gss/amount*100
                        egssp=gss/gs/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Sons      '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: All Grand Sons combined, get remaining: " , round(gss,3))
                        tree.add("Grand Sons : Tasib " + str(round(gss,3))).add("[green] Remaining").add("[blue] "+str(round(gss,2)))
                        table.add_row("Grand Sons", "Tasib", str(round(gssp,3)) + '%', str(round(gss,3)))
                        table.add_row("  Each Grand Son", "Tasib", str(round(egssp,3)) + '%', str(round(gss/gs,3)))
                        sleep(1)
                        print("\n       Each Grand Son gets: " , round(gss/gs,3),"\n\n")
                        sleep(1)

                    

                elif gs >= 1 and gd >=1:
                        
                        #Grand Son + Grand Daughter Shares
                        gss=gs*2/(gs*2+gd)*remainder
                        gds=gd/(gs*2+gd)*remainder
                        
                        #Grand Son + Grand Daughter Percentages
                        gssp=gss/amount*100
                        egssp=gss/gs/amount*100
                        gdsp=gds/amount*100
                        egdsp=gds/gd/amount*100


                        for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Sons      '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: All Grand Sons to Grand Daughter 2:1 Tasib: " , round(gss,3))
                        tree.add("Grand Son(s) 2:1 to Grand Daughter(s) " + str(round(gss,3))).add("[green] Ratio").add("[blue] "+str(round(gss,2)))
                        table.add_row("Grand Sons", "2:1 to Grand Daughter", str(round(gssp,3)) + '%', str(round(gss,3)))
                        table.add_row("  Each Grand Son", "2:1 to Grand Daughter", str(round(egssp,3)) + '%', str(round(gss/gs,3)))
                        sleep(1)
                        print("\n       Each Grand Son gets: " , round(gss/gs,3),"\n\n")
                        sleep(1)

                        
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughters '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: All Grand Daughters to Grand Sons 1:2 Tasib: " , round(gds,3))
                        tree.add("Grand Daughter(s) 1:2 Ratio to Grand Son(s) " + str(round(gds,3))).add("[green] Ratio").add("[blue] "+str(round(gds,2)))
                        table.add_row("Grand Daughter(s)", "1:2 Ratio to Son", str(round(gdsp,3)) + '%', str(round(gds,3)))
                        table.add_row("  Each Grand Daughter", "1:2 Ratio to Grand Son", str(round(egdsp,3)) + '%', str(round(gds/gd,3)))
                        sleep(1)
                        print("\n       Each Grand Daughter gets : " , round(gds/gd,3),"\n\n")
                        sleep(1)


                #Father
                elif gs == 0:
                    if f == 1 :        
                        fs = fs + remainder
                        sleep(1)
                        fsp=fs/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Father    '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Father gets gets all remaining: " , round(fs,3),"\n\n")
                        tree.add("Father : Tasib " + str(round(fs,3))).add("[green] All Remaining").add("[blue] "+str(round(fs,3)))
                        table.add_row("Father", "Tasib", str(round(fsp,3)) + '%', str(round(fs,3)))
                        sleep(1)

                    #No Father
                    elif f == 0 :


                            #Only Brother
                            if b > 0 and si == 0 :
                                    

                                    #Brother = 1
                                    if b == 1:
                                        
                                        bs=remainder
                                        sleep(1)
                                        bsp=bs/amount*100

                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Brother'):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: Brother gets all remaining: " , round(bs,3),"\n\n")
                                        tree.add("Brother : Tasib" + str(round(bs,3))).add("[green] All remaining").add("[blue] "+str(round(bs,3)))
                                        table.add_row("Brother", "Tasib", str(round(bsp,3)) + '%', str(round(bs,3)))
                                        sleep(1)


                                    #Brother > 1
                                    elif b > 1 :

                                        bs=remainder
                                        bsp=bs/amount*100
                                        ebsp=bs/b/amount*100

                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Brothers      '):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: All Brothers combined, get remaining: " , round(bs,3))
                                        tree.add("Brother(s) : Tasib " + str(round(bs,3))).add("[green] Remaining").add("[blue] "+str(round(bs,2)))
                                        table.add_row("Brother", "Tasib", str(round(bsp,3)) + '%', str(round(bs,3)))
                                        table.add_row("  Each Brother", "Tasib", str(round(ebsp,3)) + '%', str(round(bs/b,3)))
                                        sleep(1)
                                        print("\n       Each Brother gets: " , round(bs/b,3),"\n\n")
                                        sleep(1)
                                        

                            #Only Sister
                            elif b == 0 and si > 0 :
                                    #Sister = 1
                                    if si == 1:
                                        
                                        sis=remainder
                                        sleep(1)
                                        sisp=sis/amount*100

                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Sister'):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: Sister gets all remaining: " , round(sis,3),"\n\n")
                                        tree.add("Sister : Tasib" + str(round(sis,3))).add("[green] All remaining").add("[blue] "+str(round(sis,3)))
                                        table.add_row("Sister", "Tasib", str(round(sisp,3)) + '%', str(round(sis,3)))
                                        sleep(1)


                                    #Sister > 1
                                    elif si > 1 :

                                        sis=remainder
                                        sisp=sis/amount*100
                                        esisp=sis/si/amount*100

                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Sisters      '):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: All Sisters combined, get remaining: " , round(sis,3))
                                        tree.add("Sisters : Tasib " + str(round(sis,3))).add("[green] Remaining").add("[blue] "+str(round(sis,2)))
                                        table.add_row("Sisters ", "Tasib", str(round(sisp,3)) + '%', str(round(sis,3)))
                                        table.add_row("  Each Sister", "Tasib", str(round(esisp,3)) + '%', str(round(sis/si,3)))
                                        sleep(1)
                                        print("\n       Each Sister gets: " , round(sis/si,3),"\n\n")
                                        sleep(1)
                                        
                            
                            #Brother + Sister
                            elif b >= 1 and si >=1:
                        
                                #Grand Son + Grand Daughter Shares
                                bs=b*2/(b*2+si)*remainder
                                sis=si/(b*2+si)*remainder
                                
                                #Grand Son + Grand Daughter Percentages
                                bsp=bs/amount*100
                                ebsp=bs/b/amount*100
                                sisp=sis/amount*100
                                esisp=sis/si/amount*100


                                for step in track(range(15), description='[green]    Calculating Inheritance share for Brothers      '):
                                    sleep(.1)
                                    step
                                print("\n       :small_red_triangle: All Brothers to Sisters 2:1 Tasib : " , round(bs,3))
                                tree.add("Brother(s) 2:1 to Sister(s) " + str(round(bs,3))).add("[green] Ratio").add("[blue] "+str(round(bs,2)))
                                table.add_row("Brothers", "2:1 to Sister", str(round(bsp,3)) + '%', str(round(bs,3)))
                                table.add_row("  Each Brother", "2:1 to Sister", str(round(ebsp,3)) + '%', str(round(bs/b,3)))
                                sleep(1)
                                print("\n       Each Brother gets: " , round(bs/b,3),"\n\n")
                                sleep(1)

                                
                                for step in track(range(15), description='[green]    Calculating Inheritance share for Sisters '):
                                    sleep(.1)
                                    step
                                print("\n       :small_red_triangle: All Sisters to Brothers 1:2 Tasib: " , round(sis,3))
                                tree.add("Sisters 1:2 Ratio to Brother " + str(round(sis,3))).add("[green] Ratio").add("[blue] "+str(round(sis,2)))
                                table.add_row("Sister(s)", "1:2 Ratio to Brother", str(round(sisp,3)) + '%', str(round(sis,3)))
                                table.add_row("  Each Sister", "1:2 Ratio to Brother", str(round(esisp,3)) + '%', str(round(sis/si,3)))
                                sleep(1)
                                print("\n       Each Sister gets : " , round(sis/si,3),"\n\n")
                                sleep(1)

                            #No Brother + Sister Shares increase proportionally
                            elif b + si == 0 :
                                    print("\n\n       :arrow_up: [green]RADD Case :arrow_up: : Therefore, Shares will now be increased proportionally except the spouse\n")
                                    

                                    #Daughter & GrandDaughter
                                    if  d == 1 :
                                        ds=ds+(ds/(sops-hs-ws)*remainder)
                                        dsp=ds/amount*100
                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Daughter  '):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: Daughter now gets 1/2 + Increment : " , round(ds,3),"\n\n")
                                        tree.add("Daughter [REVISED] 1/2 + Increment " + str(round(ds,3))).add("[green] 1/2").add("[blue] "+str(round(ds,2)))
                                        table.add_row("Daughter [REVISED]", "1/2 + Increment", str(round(dsp,3)) + '%', str(round(ds,3)))
                                        sleep(1)

                                        if gd >= 1 and gs == 0 : #gs condition is extra
                                            gds=gds+(gds/(sops-hs-ws)*remainder)
                                            gdsp=gds/amount*100
                                            egds=gds/gd
                                            egdsp=egds/amount*100
                                            if gd > 1 :
                                                for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughters  '):
                                                    sleep(.1)
                                                    step
                                                print("\n       :small_red_triangle: Grand Daughters now get 1/6 + Increment : " , round(gds,3),"\n\n")
                                                tree.add("Grand Daughters [REVISED] 1/6 + Increment" + str(round(gds,3))).add("[green] 1/6").add("[blue] "+str(round(gds,3)))
                                                table.add_row("Grand Daughters [REVISED]", "1/6 + Increment", str(round(gdsp,3)) + '%', str(round(gds,3)))
                                                table.add_row("  Each Grand Daughter [REVISED]", "1/6 + Increment", str(round(egdsp,3)) + '%', str(round(egds,3)))
                                                sleep(1)
                                                print("\n       Each Grand Daughters now gets:" , gds/gd)
                                            elif gd==1 :
                                                for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughter  '):
                                                    sleep(.1)
                                                    step
                                                print("\n       :small_red_triangle: Grand Daughters now get 1/6 + Increment : " , round(gds,3),"\n\n")
                                                tree.add("Grand Daughter [REVISED] 1/6 + Increment" + str(round(gds,3))).add("[green] 1/6").add("[blue] "+str(round(gds,3)))
                                                table.add_row("Grand Daughter [REVISED]", "1/6 + Increment", str(round(gdsp,3)) + '%', str(round(gds,3)))
                                                sleep(1)
                                                print("\n       Each Grand Daughters now gets:" , gds/gd)
                                                
                                                print("Grand Daughter now gets:" , gds)

                                    elif d > 1 :
                                        ds=ds+(ds/(sops-hs-ws)*remainder)
                                        dsp=ds/amount*100
                                        edsp=ds/d/amount*100
                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Daughters  '):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: Daughters get 2/3 prescribed share + Increment: " , round(ds,3),"\n\n")
                                        tree.add("Daughters [REVISED] 2/3 + Increment" + str(round(ds,3))).add("[green] 2/3 + Increment").add("[blue] "+str(round(ds,2)))
                                        table.add_row("Daughter(s) [REVISED]", "2/3 + Increment", str(round(dsp,3)) + '%', str(round(ds,3)))
                                        table.add_row("  Each Daughter [REVISED]", "2/3 + Increment", str(round(edsp,3)) + '%', str(round(ds/d,3)))
                                        sleep(1)
                                        print("\n       All Daughters combined now get:" , ds)
                                        
                                        print("\n       Each Daughter now gets:" , ds/d)
                                    
                            
                                    #Paternal Grand Father
                                    if pgf == 1 :
                                            pgfs=pgfs+(pgfs/(sops-hs-ws)*remainder)
                                            sleep(1)
                                            pgfsp=pgfs/amount*100
                                            for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Father'):
                                                sleep(.1)
                                                step
                                            print("\n       :small_red_triangle: Paternal Grand Father now gets 1/6th prescribed share + Increment: " , round(pgfs,3),"\n\n")
                                            tree.add("Paternal Grand Father [REVISED] 1/6 + Increment " + str(round(pgfs,3))).add("[green] 1/6 + Increment").add("[blue] "+str(round(pgfs,3)))
                                            table.add_row("Paternal Grand Father [REVISED]", "1/6 + Increment", str(round(pgfsp,3)) + '%', str(round(pgfs,3)))
                                            sleep(1)



                                    #Paternal Grand Mother
                                    if pgm == 1 :
                                            pgms=pgms+(pgms/(sops-hs-ws)*remainder)
                                            sleep(1)
                                            pgmsp=pgms/amount*100
                                            for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Mother'):
                                                sleep(.1)
                                                step
                                            print("\n       :small_red_triangle: Paternal Grand Mother gets 1/6th prescribed share + Increment: " , round(pgms,3),"\n\n")
                                            tree.add("Paternal Grand Mother [REVISED] 1/6 + Increment " + str(round(pgms,3))).add("[green] 1/6 + Increment").add("[blue] "+str(round(pgms,3)))
                                            table.add_row("Paternal Grand Mother [REVISED]", "1/6 + Increment", str(round(pgmsp,3)) + '%', str(round(pgms,3)))
                                            sleep(1)


                                    #Maternal Grand Mother
                                    if mgm == 1 :
                                            mgms=mgms+(mgms/(sops-hs-ws)*remainder)
                                            sleep(1)
                                            mgmsp=mgms/amount*100
                                            for step in track(range(15), description='[green]    Calculating Inheritance share for Maternal Grand Mother'):
                                                sleep(.1)
                                                step
                                            print("\n       :small_red_triangle: Maternal Grand Mother gets 1/6th prescribed share + Increment: " , round(mgms,3),"\n\n")
                                            tree.add("Maternal Grand Mother [REVISED] 1/6 + Increment " + str(round(mgms,3))).add("[green] 1/6 + Increment").add("[blue] "+str(round(mgms,3)))
                                            table.add_row("Maternal Grand Mother [REVISED]", "1/6 + Increment", str(round(mgmsp,3)) + '%', str(round(mgms,3)))
                                            sleep(1)
                                    
                                    
                                    #Mother
                                    if m == 1 :
                                            ms=ms+((ms/(sops-hs-ws))*remainder)
                                            sleep(1)
                                            msp=ms/amount*100
                                            for step in track(range(15), description='[green]    Calculating Inheritance share for Mother    '):
                                                sleep(.1)
                                                step
                                            print("\n       :small_red_triangle: Mother gets 1/6th prescribed share + Increment: " , round(ms,3),"\n\n")
                                            tree.add("Mother 1/6 + Increment " + str(round(ms,3))).add("[green] 1/6 + Increment").add("[blue] "+str(round(ms,3)))
                                            table.add_row("Mother", "1/6 + Increment", str(round(msp,3)) + '%', str(round(ms,3)))
                                            sleep(1)

                                
                print("\n       [green]***All inheritance distributed***\n")
                        
#-------------------------Scenario 2---B: No Son but Daughter alive---Amount Exceeded----------------------------
        
        if remainder < 0 :

                #Absolute remainder as [remainer < 0]
                remainder=abs(remainder)
                
                print("\n       [red]Prescribed shares distribution has exceeded the amount by ",remainder,".")
                print("\n\n       :arrow_down: [red]AWL Case :arrow_down: : Therefore, Shares will now be reduced proportionally\n\n")

                #Decreased share of Husband
                if h == 1 :
                        hs=(hs-((hs/sops))*remainder)
                        sleep(1)
                        hsp=hs/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Husband'):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Husband gets 1/4th prescribed share - Decrement: " , round(hs,3),"\n\n")
                        tree.add("Husband [REVISED] 1/4 - Decrement " + str(round(hs,3))).add("[green] 1/4 - Decrement").add("[blue] "+str(round(hs,3)))
                        table.add_row("Husband [REVISED]", "1/4 - Decrement", str(round(hsp,3)) + '%', str(round(hs,3)))
                        sleep(1)


                #Decreased share of Wife
                if w == 1 :
                    ws=(ws-((ws/sops))*remainder)
                    sleep(1)
                    wsp=ws/amount*100
                    for step in track(range(15), description='[green]    Calculating Inheritance for Wife            '):
                        sleep(.1)
                        step
                    print("\n       :small_red_triangle: Wife gets 1/8th prescribed share - Decrement: " , round(ws,3),"\n\n")
                    tree.add("Wife [REVISED] 1/8 - Decrement " + str(round(ws,3))).add("[green] 1/8 - Decrement").add("[blue] "+str(round(ws,3)))
                    table.add_row("Wife [REVISED]", "1/8 - Decrement", str(round(wsp,3)) + '%', str(round(ws,3)))
                    sleep(1)

                if w > 1 :
                        ws=(ws-((ws/sops))*remainder)
                        print("All Wives combined get:" , ws)
                        print("Each Wife now gets:" , ws/w)
                        wsp=ws/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance for Wives           '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: All wives combined get 1/8th prescribed share - Decrement:" , round(ws,3))
                        tree.add("Wives [REVISED] 1/8 - Decrement " + str(round(ws,3))).add("[green] 1/8 - Decrement").add("[blue] "+str(round(ws,3)))
                        table.add_row("Wives [REVISED]", "1/8 - Decrement", str(round(wsp,3)) + '%', str(round(ws,3)))
                        
                        ews=ws/w
                        ewsp=ews/amount*100

                        if w==3 :
                            table.add_row("  Each wife [REVISED]", "1/24 - Decrement", str(round(ewsp,3)) + '%', str(round(ews,3)))
                        else :
                            ewsf=1/8/w
                            table.add_row("  Each wife [REVISED]", str(Fraction(ewsf)), str(round(ewsp,3)) + '%', str(round(ews,3)))

                        sleep(1)
                        print("\n       Each wife gets: ", ews,"\n\n")
                        sleep(1)


                #Decreased share of Father
                if f == 1 :
                        fs=(fs-((fs/sops))*remainder)
                        sleep(1)
                        fsp=fs/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Father    '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Father gets 1/6th prescribed share - Decrement: " , round(fs,3),"\n\n")
                        tree.add("Father [REVISED] 1/6 - Decrement " + str(round(fs,3))).add("[green] 1/6 - Decrement").add("[blue] "+str(round(fs,3)))
                        table.add_row("Father [REVISED]", "1/6 - Decrement", str(round(fsp,3)) + '%', str(round(fs,3)))
                        sleep(1)


                #Decreased share of Mother
                if m == 1 :
                        ms=(ms-((ms/sops))*remainder)
                        sleep(1)
                        msp=ms/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Mother    '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Mother gets 1/6th prescribed share - Decrement: " , round(ms,3),"\n\n")
                        tree.add("Mother [REVISED] 1/6 - Decrement " + str(round(ms,3))).add("[green] 1/6 - Decrement").add("[blue] "+str(round(ms,3)))
                        table.add_row("Mother [REVISED]", "1/6 - Decrement", str(round(msp,3)) + '%', str(round(ms,3)))
                        sleep(1)


                #Decreased share of Daughter & Grand Daughter
                if d == 1 :
                    ds=ds-(ds/sops*remainder)
                    dsp=ds/amount*100
                    for step in track(range(15), description='[green]    Calculating Inheritance share for Daughter  '):
                        sleep(.1)
                        step
                    print("\n       :small_red_triangle: Daughter gets 1/2 prescribed share - Decrement: " , round(ds,3),"\n\n")
                    tree.add("Daughter [REVISED] 1/2 - Decrement" + str(round(ds,3))).add("[green] 1/2 - Decrement").add("[blue] "+str(round(ds,2)))
                    table.add_row("Daughter [REVISED]", "1/2 - Decrement", str(round(dsp,3)) + '%', str(round(ds,3)))
                    sleep(1)

                    if gd >= 1 and gs == 0 : #gs condition is extra
                        gds=gds-(gds/(sops)*remainder)
                        sleep(1)
                        gdsp=gds/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughter       '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Grand Daughter gets 1/6th prescribed share - Decrement: " , round(gds,3),"\n\n")
                        tree.add("Grand Daughter [REVISED] 1/6 - Decrement " + str(round(gds,3))).add("[green] 1/6 - Decrement").add("[blue] "+str(round(gds,3)))
                        table.add_row("Grand Daughter [REVISED]", "1/6 - Decrement", str(round(gdsp,3)) + '%', str(round(gds,3)))
                        sleep(1)

                if d > 1 :
                    ds=ds-(ds/sops*remainder)
                    dsp=ds/amount*100
                    edsp=ds/d/amount*100
                    for step in track(range(15), description='[green]    Calculating Inheritance share for Daughters '):
                        sleep(.1)
                        step
                    print("\n       :small_red_triangle: All Daughters combined, get 2/3 - Decrement: " , round(ds,3))
                    tree.add("Daughters [REVISED] 2/3 - Decrement " + str(round(ds,3))).add("[green] 2/3 - Decrement").add("[blue] "+str(round(ds,2)))
                    table.add_row("Daughter(s) [REVISED]", "2/3 + Decrement", str(round(dsp,3)) + '%', str(round(ds,3)))
                    edsf=2/3/d
                    table.add_row("  Each Daughter [REVISED]", str(Fraction(edsf)) , str(round(edsp,3)) + '%', str(round(ds/d,3)))
                    sleep(1)
                    print("\n       Each daughter gets : " , round(ds/d,3),"\n\n")
                    sleep(1)

                
                #Decreased share of Paternal Grand Father        
                if pgf == 1 and f == 0: 
                        pgfs=(pgfs-(pgfs/sops)*remainder)
                        sleep(1)
                        pgfsp=pgfs/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Father'):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Paternal Grand Father gets 1/6th prescribed share - Decrement: " , round(pgfs,3),"\n\n")
                        tree.add("Paternal Grand Father [REVISED] 1/6 - Decrement " + str(round(pgfs,3))).add("[green] 1/6 - Decrement").add("[blue] "+str(round(pgfs,3)))
                        table.add_row("Paternal Grand Father [REVISED]", "1/6 - Decrement", str(round(pgfsp,3)) + '%', str(round(pgfs,3)))
                        sleep(1)


                #Decreased share of Paternal Grand Mother
                if pgm == 1 and m == 0:
                        pgms=(pgms-(pgms/sops)*remainder)
                        sleep(1)
                        pgmsp=pgms/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Mother'):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Paternal Grand Mother gets 1/6th prescribed share - Decrement: " , round(pgms,3),"\n\n")
                        tree.add("Paternal Grand Mother [REVISED] 1/6 - Decrement " + str(round(pgms,3))).add("[green] 1/6 - Decrement").add("[blue] "+str(round(pgms,3)))
                        table.add_row("Paternal Grand Mother [REVISED]", "1/6 - Decrement", str(round(pgmsp,3)) + '%', str(round(pgms,3)))
                        sleep(1)
                

                #Decreased share of Maternal Grand Mother
                if mgm == 1 and m == 0:
                        mgms=(mgms-(mgms/sops)*remainder)
                        sleep(1)
                        mgmsp=mgms/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Maternal Grand Mother'):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Maternal Grand Mother gets 1/6th prescribed share - Decrement: " , round(mgms,3),"\n\n")
                        tree.add("Maternal Grand Mother [REVISED] 1/6 - Decrement " + str(round(mgms,3))).add("[green] 1/6 - Decrement").add("[blue] "+str(round(mgms,3)))
                        table.add_row("Maternal Grand Mother [REVISED]", "1/6 - Decrement", str(round(mgmsp,3)) + '%', str(round(mgms,3)))
                        sleep(1)
                

                print()
                print("\n       [green]***All inheritance distributed.***")
                print()


#-----------------------------------------Scenario 3: No Son + No Daughter----------------------------------------------

'''old
if s + d == 0 :


    #Brother + Sister is less than 2 i.e. No multiple siblings.
    if b + si <= 1: #Brother + Sister is less than 2 i.e. No multiple siblings.
        

        #Father + Mother both alive, while one of Husband or Wife is alive
        if f + m == 2 and h + w == 1 : #Umar (RA)'s Fatwa
    

            #Wife
            if w == 1 :
                ws = (1/4) * amount
                print("Wife gets:" , ws)


            #Multiple Wives
            elif w >= 1 and w <= 4 : 
                ws = (1/4) * amount
                print("Wives get:" , ws)
                print("Each Wife gets:" , ws/w)
            

            #Husband
            elif h == 1 :
                hs = (1/2) * amount
                print("Husband gets:" , hs)
            

            #Sum Of Prescribed Shares + Remainder
            sops = ( hs + ws + fs + ms + ds + ss + pgfs + pgms + mgms )
            remainder = amount - sops
            
            
            #Father
            if f == 1 :
                fs = f*2/((f*2)+m)*(remainder)
                print("Father gets:" , fs)
            
            
            #Mother
            if m == 1 :
                ms = m/((f*2)+m)*(remainder)
                print("Mother gets:" , ms)
    

        else :
            
            
            #Husband
            if h == 1 :        
                hs = (1/2)*amount
                print("Husband gets:" , hs)


            #wife
            elif h == 0 and w == 1:
                ws = (1/4)*amount
                print("Wife gets:" , ws)


            #Multiple Wives
            elif h == 0 and w > 1 :
                ws = (1/4)*amount
                print("Wives get:" , ws)
                print("Each wife gets:" , ws/w)


            #Father
            if f == 1 :
                fs = (1/3)*amount
                print("Father prescribed share :" , fs)


            #Paternal Grand Father
            elif pgf == 1 and f == 0:
                pgfs = (1/6)*amount
                print("Paternal Grand Father gets:" , pgfs)


            #Mother
            if m == 1 :
                    ms=(1/3)*amount
                    print("Mother gets:" , ms)


            #Paternal Grand Mother
            elif pgm == 1 and f == 0 and m == 0 and mgm == 0 :
                    pgms=(1/6)*amount
                    print("Paternal Grand Mother gets" , pgms)


            #Paternal Grand Mother + Maternal Grand Mother
            elif pgm == 1 and f == 0 and m == 0 and mgm == 1 :
                    pgms=(1/12)*amount
                    print("Paternal Grand Mother gets" , pgms)
                    mgms=(1/12)*amount
                    print("Paternal Grand Mother gets" , mgms)


            #Maternal Grand Mother
            elif mgm == 1 and m == 0 :
                    mgms=(1/6)*amount
                    print("Maternal Grand Mother gets" , mgms)


            #Sum Of Prescribed Shares + Remainder
            sops = ( hs + ws + fs + ms + ds + ss + pgfs + pgms + mgms )
            remainder = amount - sops
            #print("REMAINDER",remainder)


            #No remainder
            if remainder == 0 :
                    print("       [green]***All inheritance distributed, No remainder:",remainder)

#-------------------------Scenario 3---A: No Son + No Daughter---Amount Leftover----------------------------
            #Remainder left to distribute    
            if remainder > 0 :
                print("Prescribed shares distribution has leftover amount : ", remainder,"\n\n")

                #Father
                if f == 1 :
                    fs=fs+remainder
                    print()
                    print("Father now gets all remaining,:" , remainder, "since he is the only heir left.  Thus total for father becomes",fs)
                    print()


                #Brother
                elif b > 0 and si == 0 :
                    bs=bs+remainder
                    print("Brother gets all remaining: ",remainder, "since he is the only heir left.")
                        

                #Sister
                elif b == 0 and si > 0 :
                    sis=sis+remainder
                    print("Sister gets all remaining: ",remainder, "since she is the only heir left.")


                #Paternal Grand Father
                elif pgf == 1:
                    pgfs=pgfs+remainder
                    print()
                    print("Paternal Grand Father now gets all remaining,:" , remainder, "since he is the only heir left.  Thus total for Paternal Grand Father becomes",pgfs)
                    print()
'''                    

if s + d == 0 :

    #Brother + Sister is less than 2 i.e. No multiple siblings.
    if b + si <= 1: #Brother + Sister is less than 2 i.e. No multiple siblings.

        #Father + Mother both alive, while one of Husband or Wife is alive
        if f + m == 2 and h + w == 1 : #Umar (RA)'s Fatwa
    

            #Wives              
            if w == 1:
                ws = (1/4) * amount
                sleep(1)
                wsp=ws/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance for Wife            '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Wife gets 1/4th prescribed share: " , round(ws,3),"\n\n")
                tree.add("Wife 1/4 " + str(round(ws,3))).add("[green] 1/4").add("[blue] "+str(round(ws,3)))
                table.add_row("Wife", "1/4", str(round(wsp,3)) + '%', str(round(ws,3)))
                sleep(1)
                

            #Multiple Wives
            elif w >= 2 and w <= 4 :# Wives >= 2 here unlike above code as multiple starts from 2
                ws = (1/4)*amount
                wsp=ws/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance for Wives           '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: All wives combined get 1/4th prescribed share:" , round(ws,3))
                tree.add("Wives 1/4 " + str(round(ws,3))).add("[green] 1/4").add("[blue] "+str(round(ws,3)))
                table.add_row("Wives", "1/4", str(round(wsp,3)) + '%', str(round(ws,3)))
                ews=ws/w
                ewsp=ews/amount*100

                if w == 2 :
                    table.add_row("  Each wife", "1/8", str(round(ewsp,3)) + '%', str(round(ews,3)))
                elif w == 3 :
                    table.add_row("  Each wife", "1/12", str(round(ewsp,3)) + '%', str(round(ews,3)))
                elif w == 4:
                    table.add_row("  Each wife", "1/16" , str(round(ewsp,3)) + '%', str(round(ews,3)))

                sleep(1)
                print("\n       Each wife gets: ", ews,"\n\n")
                sleep(1)

                '''#Husband
                elif h == 1 :
                    hs = (1/2) * amount
                    print("Husband gets:" , hs)'''
                

            #Husband
            elif h == 1 :
                hs = (1/2) * amount    
                sleep(1)
                hsp=hs/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Husband'):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Husband gets 1/2th prescribed share: " , round(hs,3),"\n\n")
                tree.add("Husband 1/2 " + str(round(hs,3))).add("[green] 1/4").add("[blue] "+str(round(hs,3)))
                table.add_row("Husband", "1/2", str(round(hsp,3)) + '%', str(round(hs,3)))
                sleep(1)


            #Sum Of Prescribed Shares + Remainder
            sops = ( hs + ws + fs + ms + ds + ss + pgfs + pgms + mgms )
            remainder = amount - sops
            
            
    
            #Father
            if f == 1 :
                fs = f*2/((f*2)+m)*(remainder)
                sleep(1)
                fsp=fs/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Father    '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Father gets twice of mother's share: " , round(fs,3),"\n\n")
                tree.add("Father 2:1 " + str(round(fs,3))).add("[green] 2:1").add("[blue] "+str(round(fs,3)))
                table.add_row("Father", "2:1", str(round(fsp,3)) + '%', str(round(fs,3)))
                sleep(1)
                
            

            #Mother
            if m == 1 :        
                ms = m/((f*2)+m)*(remainder)
                sleep(1)
                msp=ms/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Mother    '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Mother gets half of Father's share: " , round(ms,3),"\n\n")
                tree.add("Mother 1:2 " + str(round(ms,3))).add("[green] 1:2").add("[blue] "+str(round(ms,3)))
                table.add_row("Mother", "1:2", str(round(msp,3)) + '%', str(round(ms,3)))
                sleep(1)

        else :


            #Husband
            if h == 1 :        
                hs = (1/2)*amount
                sleep(1)
                hsp=hs/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Husband'):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Husband gets 1/2 prescribed share: " , round(hs,3),"\n\n")
                tree.add("Husband 1/2 " + str(round(hs,3))).add("[green] 1/2").add("[blue] "+str(round(hs,3)))
                table.add_row("Husband", "1/2", str(round(hsp,3)) + '%', str(round(hs,3)))
                sleep(1)


            #wife
            elif h == 0 and w == 1:
                ws = (1/4)*amount
                sleep(1)
                wsp=ws/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance for Wife            '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Wife gets 1/4th prescribed share: " , round(ws,3),"\n\n")
                tree.add("Wife 1/4 " + str(round(ws,3))).add("[green] 1/4").add("[blue] "+str(round(ws,3)))
                table.add_row("Wife", "1/4", str(round(wsp,3)) + '%', str(round(ws,3)))
                sleep(1)


            #Multiple Wives
            elif h == 0 and w > 1 :
                ws = (1/4)*amount
                wsp=ws/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance for Wives           '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: All wives combined get 1/4th prescribed share:" , round(ws,3))
                tree.add("Wives 1/4 " + str(round(ws,3))).add("[green] 1/4").add("[blue] "+str(round(ws,3)))
                table.add_row("Wives", "1/4", str(round(wsp,3)) + '%', str(round(ws,3)))
                ews=ws/w
                ewsp=ews/amount*100

                if w == 2 :
                    table.add_row("  Each wife", "1/8", str(round(ewsp,3)) + '%', str(round(ews,3)))
                elif w == 3 :
                    table.add_row("  Each wife", "1/12", str(round(ewsp,3)) + '%', str(round(ews,3)))
                elif w == 4:
                    table.add_row("  Each wife", "1/16" , str(round(ewsp,3)) + '%', str(round(ews,3)))

                sleep(1)
                print("\n       Each wife gets: ", ews,"\n\n")
                sleep(1)

            #Father
            if f == 1 :
                fs = (1/3)*amount
                sleep(1)
                fsp=fs/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Father    '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Father gets 1/3th prescribed share: " , round(fs,3),"\n\n")
                tree.add("Father 1/3 " + str(round(fs,3))).add("[green] 1/3").add("[blue] "+str(round(fs,3)))
                table.add_row("Father", "1/3", str(round(fsp,3)) + '%', str(round(fs,3)))
                sleep(1)


            #Paternal Grand Father
            elif pgf == 1 and f == 0:
                pgfs = (1/6)*amount
                sleep(1)
                pgfsp=pgfs/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Father'):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Paternal Grand Father gets 1/6th prescribed share: " , round(pgfs,3),"\n\n")
                tree.add("Paternal Grand Father 1/6 " + str(round(pgfs,3))).add("[green] 1/6").add("[blue] "+str(round(pgfs,3)))
                table.add_row("Paternal Grand Father", "1/6", str(round(pgfsp,3)) + '%', str(round(pgfs,3)))
                sleep(1)



            #Mother
            if m == 1 :
                ms=(1/3)*amount
                sleep(1)
                msp=ms/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Mother    '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Mother gets 1/3rd prescribed share: " , round(ms,3),"\n\n")
                tree.add("Mother 1/3 " + str(round(ms,3))).add("[green] 1/3").add("[blue] "+str(round(ms,3)))
                table.add_row("Mother", "1/3", str(round(msp,3)) + '%', str(round(ms,3)))
                sleep(1)


            #Paternal Grand Mother
            elif pgm == 1 and f == 0 and m == 0 and mgm == 0 :
                pgms=(1/6)*amount
                sleep(1)
                pgmsp=pgms/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Mother'):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Paternal Grand Mother gets 1/6th prescribed share: " , round(pgms,3),"\n\n")
                tree.add("Paternal Grand Mother 1/6 " + str(round(pgms,3))).add("[green] 1/6").add("[blue] "+str(round(pgms,3)))
                table.add_row("Paternal Grand Mother", "1/6", str(round(pgmsp,3)) + '%', str(round(pgms,3)))
                sleep(1)



            #Paternal + Maternal Grandmother
            elif pgm == 1 and f == 0 and m == 0 and mgm == 1 :
                pgms=(1/12)*amount
                pgmsp=pgms/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for both Paternal & Maternal Grand Mothers'):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Paternal Grand Mother gets 1/12th prescribed share: " , round(pgms,3),"\n")
                tree.add("Paternal Grand Mother 1/12 " + str(round(pgms,3))).add("[green] 1/12").add("[blue] "+str(round(pgms,3)))
                table.add_row("Paternal Grand Mother", "1/12", str(round(pgmsp,3)) + '%', str(round(pgms,3)))
                sleep(1)
                
                mgms=(1/12)*amount
                mgmsp=mgms/amount*100
                
                print("\n       :small_red_triangle: Maternal Grand Mother gets 1/12th prescribed share: " , round(mgms,3),"\n\n")
                tree.add("Maternal Grand Mother 1/12 " + str(round(mgms,3))).add("[green] 1/12").add("[blue] "+str(round(mgms,3)))
                table.add_row("Maternal Grand Mother", "1/12", str(round(mgmsp,3)) + '%', str(round(mgms,3)))
                sleep(1)

            #Maternal Grand Mother
            elif mgm == 1 and m == 0 :
                mgms=(1/6)*amount
                sleep(1)
                mgmsp=mgms/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Maternal Grand Mother'):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Maternal Grand Mother gets 1/6th prescribed share: " , round(mgms,3),"\n\n")
                tree.add("Maternal Grand Mother 1/6 " + str(round(mgms,3))).add("[green] 1/6").add("[blue] "+str(round(mgms,3)))
                table.add_row("Maternal Grand Mother", "1/6", str(round(mgmsp,3)) + '%', str(round(mgms,3)))
                sleep(1)

            if gd == 1 and gs == 0 :
                gds=(1/2) * amount
                sleep(1)
                gdsp=gds/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughter       '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: Grand Daughter gets 1/2th prescribed share: " , round(gds,3),"\n\n")
                tree.add("Grand Daughter 1/2 " + str(round(gds,3))).add("[green] 1/2").add("[blue] "+str(round(gds,3)))
                table.add_row("Grand Daughter", "1/2", str(round(gdsp,3)) + '%', str(round(gds,3)))
                sleep(1)

            elif gd > 1 and gs == 0 :
                gds=(2/3) * amount
                sleep(1)
                gdsp=gds/amount*100
                egds=gds/gd
                egdsp=egds/amount*100
                for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughters       '):
                    sleep(.1)
                    step
                print("\n       :small_red_triangle: All Grand Daughters combined, get 2/3 prescribed share: " , round(gds,3))
                tree.add("Grand Daughters 2/3 " + str(round(gds,3))).add("[green] 2/3").add("[blue] "+str(round(gds,3)))
                table.add_row("Grand Daughter(s)", "2/3", str(round(gdsp,3)) + '%', str(round(gds,3)))
                egdsf=1/6/gd
                table.add_row("  Each Grand Daughter", egdsf , str(round(egdsp,3)) + '%', str(round(egds,3)))
                sleep(1)

                print("\n       Each Grand daughter gets : " , round(egds,3),"\n\n")

            #Sum Of Prescribed Shares + Remainder
            sops = ( hs + ws + fs + ms + ds + ss + pgfs + pgms + mgms + gds)
            remainder = amount - sops


            #No remainder
            if remainder == 0 :
                print("All inheritance distributed, No remainder:",remainder)


#-------------------------Scenario 3---A: No Son + No Daughter---Amount Leftover----------------------------
            #Remainder left to distribute    
            if remainder > 0 :

                #Grand Son
                if gs >= 1 and gd == 0:
                    
                    
                    gss=remainder
                    if gs == 1:
                        sleep(1)
                        gssp=gss/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Son'):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: Grand Son gets all remaining: " , round(gss,3),"\n\n")
                        tree.add("Grand Son Taseeb" + str(round(gss,3))).add("[green] All remaining").add("[blue] "+str(round(gss,3)))
                        table.add_row("Grand Son", "Taseeb", str(round(gssp,3)) + '%', str(round(gss,3)))
                        sleep(1)
                        
                    
                    elif gs > 1:
                        gss=remainder
                        gssp=gss/amount*100
                        egssp=gss/gs/amount*100
                        for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Sons      '):
                            sleep(.1)
                            step
                        print("\n       :small_red_triangle: All Grand Sons combined, get remaining: " , round(gss,3))
                        tree.add("Grand Son Remaining " + str(round(gss,3))).add("[green] Remaining").add("[blue] "+str(round(gss,2)))
                        table.add_row("Grand Sons", "Remaining", str(round(gssp,3)) + '%', str(round(gss,3)))
                        table.add_row("  Each Grand Son", "Remaining", str(round(egssp,3)) + '%', str(round(gss/gs,3)))
                        sleep(1)
                        print("\n       Each Grand Son gets: " , round(gss/gs,3),"\n\n")
                        sleep(1)

                    

                elif gs >= 1 and gd >=1:
                    
                    #Grand Son + Grand Daughter Shares
                    gss=gs*2/(gs*2+gd)*remainder
                    gds=gd/(gs*2+gd)*remainder
                    
                    #Grand Son + Grand Daughter Percentages
                    gssp=gss/amount*100
                    egssp=gss/gs/amount*100
                    gdsp=gds/amount*100
                    egdsp=gds/gd/amount*100


                    for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Sons      '):
                        sleep(.1)
                        step
                    print("\n       :small_red_triangle: All Grand Sons combined, get twice to Grand Daughter: " , round(gss,3))
                    tree.add("Grand Son 2:1 to Grand Daughter(s) " + str(round(gss,3))).add("[green] Ratio").add("[blue] "+str(round(gss,2)))
                    table.add_row("Grand Son", "2:1 to Grand Daughter", str(round(gssp,3)) + '%', str(round(gss,3)))
                    table.add_row("  Each Grand Son", "2:1 to Grand Daughter", str(round(egssp,3)) + '%', str(round(gss/gs,3)))
                    sleep(1)
                    print("\n       Each Grand Son gets: " , round(gss/gs,3),"\n\n")
                    sleep(1)

                    
                    for step in track(range(15), description='[green]    Calculating Inheritance share for Grand Daughters '):
                        sleep(.1)
                        step
                    print("\n       :small_red_triangle: All Grand Daughters combined, get half ratio to Grand Sons from remaining: " , round(gds,3))
                    tree.add("Grand Daughters 1:2 Ratio to Grand Son " + str(round(gds,3))).add("[green] Ratio").add("[blue] "+str(round(gds,2)))
                    table.add_row("Grand Daughter(s)", "1:2 Ratio to Son", str(round(gdsp,3)) + '%', str(round(gds,3)))
                    table.add_row("  Each Grand Daughter", "1:2 Ratio to Grand Son", str(round(egdsp,3)) + '%', str(round(gds/gd,3)))
                    sleep(1)
                    print("\n       Each Grand Daughter gets : " , round(gds/gd,3),"\n\n")
                    sleep(1)

                print("Prescribed shares distribution has leftover amount : ", remainder)
                if f == 1 :        
                    fs = fs + remainder
                    sleep(1)
                    fsp=fs/amount*100
                    for step in track(range(15), description='[green]    Calculating Inheritance share for Father    '):
                        sleep(.1)
                        step
                    print("\n       :small_red_triangle: Father gets 1/6th prescribed share + Remaining: " , round(fs,3),"\n\n")
                    tree.add("Father Taseeb " + str(round(fs,3))).add("[green] All Remaining").add("[blue] "+str(round(fs,3)))
                    table.add_row("Father", "Taseeb", str(round(fsp,3)) + '%', str(round(fs,3)))
                    sleep(1)

                elif gs == 0:
                    if f == 1 :
                

                            #Only Brother
                            if b > 0 and si == 0 :
                                    

                                    #Brother = 1
                                    if b == 1:
                                        
                                        bs=remainder
                                        sleep(1)
                                        bsp=bs/amount*100

                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Brother'):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: Brother gets all remaining: " , round(bs,3),"\n\n")
                                        tree.add("Brother Taseeb" + str(round(bs,3))).add("[green] All remaining").add("[blue] "+str(round(bs,3)))
                                        table.add_row("Brother", "Taseeb", str(round(bsp,3)) + '%', str(round(bs,3)))
                                        sleep(1)


                                    #Brother > 1
                                    elif b > 1 :

                                        bs=remainder
                                        bsp=bs/amount*100
                                        ebsp=bs/b/amount*100

                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Brothers      '):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: All Brothers combined, get remaining: " , round(bs,3))
                                        tree.add("Brother Remaining " + str(round(bs,3))).add("[green] Remaining").add("[blue] "+str(round(bs,2)))
                                        table.add_row("Brother", "Remaining", str(round(bsp,3)) + '%', str(round(bs,3)))
                                        table.add_row("  Each Brother", "Remaining", str(round(ebsp,3)) + '%', str(round(bs/b,3)))
                                        sleep(1)
                                        print("\n       Each Brother gets: " , round(bs/b,3),"\n\n")
                                        sleep(1)
                                        

                            #Only Sister
                            elif b == 0 and si > 0 :
                                    #Sister = 1
                                    if si == 1:
                                        
                                        sis=remainder
                                        sleep(1)
                                        sisp=sis/amount*100

                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Sister'):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: Sister gets all remaining: " , round(sis,3),"\n\n")
                                        tree.add("Sister Remaining" + str(round(sis,3))).add("[green] All remaining").add("[blue] "+str(round(sis,3)))
                                        table.add_row("Sister", "Taseeb", str(round(sisp,3)) + '%', str(round(sis,3)))
                                        sleep(1)


                                    #Sister > 1
                                    elif si > 1 :

                                        sis=remainder
                                        sisp=sis/amount*100
                                        esisp=sis/si/amount*100

                                        for step in track(range(15), description='[green]    Calculating Inheritance share for Sisters      '):
                                            sleep(.1)
                                            step
                                        print("\n       :small_red_triangle: All Sisters combined, get remaining: " , round(sis,3))
                                        tree.add("Sister Remaining " + str(round(sis,3))).add("[green] Remaining").add("[blue] "+str(round(sis,2)))
                                        table.add_row("Sister", "Remaining", str(round(sisp,3)) + '%', str(round(sis,3)))
                                        table.add_row("  Each Sister", "Remaining", str(round(esisp,3)) + '%', str(round(sis/si,3)))
                                        sleep(1)
                                        print("\n       Each Sister gets: " , round(sis/si,3),"\n\n")
                                        sleep(1)
                                        
                            
                            #Brother + Sister
                            elif b >= 1 and si >=1:
                        
                                #Grand Son + Grand Daughter Shares
                                bs=b*2/(b*2+si)*remainder
                                sis=si/(b*2+si)*remainder
                                
                                #Grand Son + Grand Daughter Percentages
                                bsp=bs/amount*100
                                ebsp=bs/b/amount*100
                                sisp=sis/amount*100
                                esisp=sis/si/amount*100


                                for step in track(range(15), description='[green]    Calculating Inheritance share for Brothers      '):
                                    sleep(.1)
                                    step
                                print("\n       :small_red_triangle: All Brothers combined, get twice to Sisters: " , round(bs,3))
                                tree.add("Brother(s) 2:1 to Sister(s) " + str(round(bs,3))).add("[green] Ratio").add("[blue] "+str(round(bs,2)))
                                table.add_row("Brother", "2:1 to Sister", str(round(bsp,3)) + '%', str(round(bs,3)))
                                table.add_row("  Each Brother", "2:1 to Sister", str(round(ebsp,3)) + '%', str(round(bs/b,3)))
                                sleep(1)
                                print("\n       Each Brother gets: " , round(bs/b,3),"\n\n")
                                sleep(1)

                                
                                for step in track(range(15), description='[green]    Calculating Inheritance share for Sisters '):
                                    sleep(.1)
                                    step
                                print("\n       :small_red_triangle: All Sisters combined, get half ratio to Brothers from remaining: " , round(sis,3))
                                tree.add("Sisters 1:2 Ratio to Brother " + str(round(sis,3))).add("[green] Ratio").add("[blue] "+str(round(sis,2)))
                                table.add_row("Sister(s)", "1:2 Ratio to Brother", str(round(sisp,3)) + '%', str(round(sis,3)))
                                table.add_row("  Each Sister", "1:2 Ratio to Brother", str(round(esisp,3)) + '%', str(round(sis/si,3)))
                                sleep(1)
                                print("\n       Each Sister gets : " , round(sis/si,3),"\n\n")
                                sleep(1)


                #Paternal Grand Father
                elif pgf == 1:
                    pgfs=pgfs+remainder
                    sleep(1)
                    pgfsp=pgfs/amount*100
                    for step in track(range(15), description='[green]    Calculating Inheritance share for Paternal Grand Father'):
                        sleep(.1)
                        step
                    print("\n       :small_red_triangle: Paternal Grand Father now gets 1/6th prescribed share + Increment: " , round(pgfs,3),"\n\n")
                    tree.add("Paternal Grand Father 1/6 + Increment " + str(round(pgfs,3))).add("[green] 1/6 + Increment").add("[blue] "+str(round(pgfs,3)))
                    table.add_row("Paternal Grand Father", "1/6 + Increment", str(round(pgfsp,3)) + '%', str(round(pgfs,3)))
                    sleep(1)
            

#-------------------------Scenario 3---B: No Son + No Daughter---Amount Exceeded----------------------------
            #Amount exceeded
            if remainder < 0 :
                
                
                remainder=abs(remainder)
                print("Prescribed shares distribution has exceeded the amount by ",remainder,".  Therefore shares will be reduced proportionally")
                    

                #Decreased share of Husband
                if h == 1 :
                    hs=(hs-((hs/sops))*remainder)
                    print("Husband now gets:" , hs)


                #Decreased share of Wife
                if w >= 1 :
                    ws=(ws-((ws/sops))*remainder)
                    print("Wife now gets:" , ws)


                #Decreased share of Father
                if f == 1 :
                    fs=(fs-((fs/sops))*remainder)
                    print("Father now gets:" , fs)


                #Decreased share of Mother
                if m == 1 :
                    ms=(ms-((ms/sops))*remainder)
                    print("Mother now gets:" , ms)


                #Decreased share of Daughter
                if d > 0 :
                    ds=ds-(ds/sops*remainder)
                    print("Daughter(s) now get(s):" , ds)


                #Decreased share of Paternal Grand Father        
                if pgf == 1 :
                    pgfs=(pgfs-(pgfs/sops)*remainder)
                    print("Paternal Grand Father now gets:" , pgfs)


                #Decreased share of Paternal Grand Mother
                if pgm == 1 :
                    pgms=(pgms-(pgms/sops)*remainder)
                    print("Paternal Grand Mother now gets:" , pgms)


                            #Increased share of Maternal Grand Mother
                if mgm == 1 :
                    mgms=(mgms-(mgms/sops)*remainder)
                    print("Maternal Grand Mother now gets:" , mgms)


                print()
                print("All inheritance distributed, No remainder")
                print()


    #Brother + Sister are equals to or more than 2
    if b + si >= 2 :
        

        #Husband
        if h == 1 :        
            hs = (1/2)*amount
            print("Husband gets:" , hs)


        #wife
        elif h == 0 and w == 1:
            ws = (1/4)*amount
            print("Wife gets:" , ws)


        #Multiple Wives
        elif h == 0 and w > 1 :
            ws = (1/4)*amount
            print("Wives get:" , ws)
            print("Each wife gets:" , ws/w)


        #Father
        if f == 1 :
            fs = (1/3)*amount
            print("Father prescribed share :" , fs)


        #Paternal Grand Father
        elif pgf == 1 and f == 0:
            pgfs = (1/6)*amount
            print("Paternal Grand Father gets:" , pgfs)


        #Mother
        if m == 1 :
                ms=(1/6)*amount
                print("Mother gets:" , ms)


        #Paternal Grand Mother
        elif pgm == 1 and f == 0 and m == 0 and mgm == 0 :
                pgms=(1/6)*amount
                print("Paternal Grand Mother gets" , pgms)
                

        #Paternal Grand Mother + Maternal Grand Mother
        elif pgm == 1 and f == 0 and m == 0 and mgm == 1 :
                pgms=(1/12)*amount
                print("Paternal Grand Mother gets" , pgms)
                mgms=(1/12)*amount
                print("Paternal Grand Mother gets" , mgms)
        
        #Maternal Grand Mother
        elif mgm == 1 and m == 0 :
                mgms=(1/6)*amount
                print("Maternal Grand Mother gets" , mgms)


        #Sum Of Prescribed Shares + Remainder
        sops = ( hs + ws + fs + ms + ds + ss + pgfs + pgms + mgms )
        remainder = amount - sops
        print("REMAINDER",remainder)


        #No Remainder
        if remainder == 0 :
                print("All inheritance distributed, No remainder:",remainder)


        #Remainder left to be distributed
        remainder=round(remainder)
        if remainder > 0 :


            #Father
            if f == 1 :
                fs=fs+remainder
                print("Father gets:" , fs)


            #Brother    
            elif b > 0 and si == 0 :
                bs=bs+remainder
                print("Brother gets:",bs)


            #Sister    
            elif b == 0 and si > 0 :
                sis=sis+remainder
                print("Sister gets:",sis)


            #Brother + Sister    
            elif b > 0 and si > 0 :
                bs=bs+((b*2)/((b*2)+si))*remainder
                sis=sis+((si)/((b*2)+si))*remainder
                print("Brother(s) get:",bs)
                print("Sister(s) get:",sis)
            

        #Exceeded Amount
        if remainder < 0 :


            remainder=abs(remainder)
            print("Exceeded amount, Reducing",remainder)
            print("Shares decrease proportionally")
                
            #Decreased share of Husband
            if h == 1 :
                hs=(hs-((hs/sops))*remainder)
                print("Husband now gets:" , hs)


            #Decreased share of Wife
            if w >= 1 :
                ws=(ws-((ws/sops))*remainder)
                print("Wife now gets:" , ws)


            #Decreased share of Father
            if f == 1 :
                fs=(fs-((fs/sops))*remainder)
                print("Father now gets:" , fs)


            #Decreased share of Mother
            if m == 1 :
                ms=(ms-((ms/sops))*remainder)
                print("Mother now gets:" , ms)


            #Decreased share of Daughter
            if d > 0 :
                ds=ds-(ds/sops*remainder)
                print("Daughter(s) now get(s):" , ds)


            #Decreased share of Paternal Grand Father        
            if pgf == 1 :
                pgfs=(pgfs-(pgfs/sops)*remainder)
                print("Paternal Grand Father now gets:" , pgfs)


            #Decreased share of Paternal Grand Mother
            if pgm == 1 :   
                pgms=(pgms-(pgms/sops)*remainder)
                print("Paternal Grand Mother now gets:" , pgms)


            #Decreased share of Maternal Grand Mother
            if mgm == 1 :
                mgms=(mgms-(mgms/sops)*remainder)
                print("Maternal Grand Mother now gets:" , mgms)

            #End
            print()
            print("All inheritance distributed")
            print()
            print()

relations=s+d+h+w+f+m+pgf+pgm+mgm+b+si+gs+gd

if relations >0:

    #Tree Structure
    sleep(1)
    for step in track(range(40), description='[gblue]    Generating Tree structure                    '):
        sleep(.04)
        step
    sleep(1)
    print("   ",tree)
    print("\n\n")

    #Table Structurex
    for step in track(range(40), description='[blue]    Generating Table view                        '):
        sleep(.04)
        step
    sleep(3)
    print("\n")
    console.print(table)
    sh=[ss,ds,hs,ws,fs,ms,pgfs,pgms,mgms,bs,sis,gss,gds]
    names=['Sons','Daughters','Husband','Wives', 'Father', 'Mother', 'P GrandFather', 'P GrandMother','M GrandMother','Brothers','Sisters','GrandSons','GrandDaughters']
    #plt.pie(sh,labels=names,autopct='%1.1f%%')

    #Pie Chart
    for step in track(range(40), description='[red]    Generating Pie chart                        '):
        sleep(.04)
        step
    sleep(3)
    #plt.show()
    print("\n\n")
    piesh=[]
    pinames=[]
    i=0
    for x in sh:
        
        if x != 0:
            piesh.append(x)
            print(piesh)
            #name.append()
            pinames.append(names[i])
            print(pinames)
        i=i+1

    plt.pie(piesh,labels=pinames,autopct='%1.1f%%')
    #plt.pie(piesh,labels=pinames)
    plt.show()


else:
    print("       No relative was entered. Inheritance will go to Islamic government.")</code></pre>
                        <div class="button-container">
                            <button class="see-more-btn" onclick="showModal(this)">
                                <i class="language-icon more"></i>
                                See More
                            </button>
                            <button class="see-more-btn" onclick="window.open('https://github.com/arubbinali/github-projects/blob/main/Islamic%20Inheritance%20Calculator/Inheritance.py', '_blank')">
                                <i class="language-icon github"></i>
                                GitHub
                            </button>
                            <button class="see-more-btn" onclick="window.open('https://arubbinali.github.io/Projects.html#inheritance-projects', '_blank')">
                                <i class="language-icon project"></i>
                                View Project
                            </button>
                        </div>
                    </div>
                </div>

                <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;2,222 lines (1,784 loc)</h5>

            </section>
            </div>

                <!-- Mathematical & Utility GUI software -->
                <div id="gui-docs">
                <section class="info-section">
                    <h2 class="project-heading">Mathematical & Utility GUI software</h2>
                    <div class="code-snippet">
                        <div class="code-snippet-header">
                            <h5 class="code-snippet-title">
                                <div class="code-language">
                                    <i class="language-icon python"></i>
                                </div>
                                MathLab GUI.py
                            </h5>
                            <button class="code-snippet-toggle">+</button>
                        </div>
    
                        <div class="code-snippet-content">
                            <pre class="code-snippet-code"><code class="language-python">#Importing libraries
from tkinter import *
import tkinter as tk
from tkinter import ttk
from openpyxl import *
import numpy
import pygame
from time import strftime
from datetime import datetime
from time import sleep
from tkinter import Tk, Label, PhotoImage

#Initialization - (paths not updated as of July 30 2024) 
sound_path = "C:/Users/Micro/Desktop/MathLab GUI/Important/click.wav"
wallpaper_path = "C:/Users/Micro/Desktop/MathLab GUI/Important/main.png"
sheet_path = "C:/Users/Micro/Desktop/MathLab GUI/Important/sheet.xlsx"
ringtone_path = "C:/Users/Micro/Desktop/MathLab GUI/Important/ringtone.mp3"
pygame.mixer.init()
pathx, pathy, logox = 40, 30, 1160
for3x1, for3x2, for3x3, for3y =  90, 490, 890, 350
quadraticx, quadraticy = 240, 135
cubicx, cubicy = 310, 100
quarticx, quarticy = 310, 90
calculatorx, calculatory = 375, 30
converterx, convertery = 340, 145
milliseconds, running = 0, False
clockx, clocky = 270, 140
stopwatchx, stopwatchy = 500, 150
notepadx, notepady = 315, 150
formx = 400
running, times, minutes, hours, seconds, count = False, 0, 0, 0, 0, 1
i = "Number of "
    
#Main Functions
def design():
    global new_window
    new_window = tk.Toplevel(window)
    new_window.attributes('-fullscreen', True)
    new_window.configure(bg="#262626")

def logo():
    path = tk.Label(new_window, text = "MathLab GUI", bg="#7cd8e0")
    path.place(x = logox, y = pathy)

def return_button():
    #Buttons Color execution functions
    def back_enter(nul):
        back_button.config(bg="#ff8f03", width=13, height=1)

    def back_leave(nul):
        back_button.config(bg="SystemButtonFace", width=10, height=1)

    #Back button
    back_button = tk.Button(new_window, text = "Go Back â©", command=new_window.destroy, activebackground="yellow", width=10, height=1, font = ("Consolas", 10))
    back_button.place(x=1165, y=660)

    #Buttons Color execution
    back_button.bind("<Enter>", back_enter)
    back_button.bind("<Leave>", back_leave)

def sound():
    click = pygame.mixer.Sound(sound_path)
    click.play()

#Polynomials' Applications
def quadratic():
    def quadratic_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Math â Polynomials â Quadratic Equation", bg="#5be471")
        path.place(x = pathx, y = pathy)

        frame = tk.Frame(new_window, bg="#262626")
        frame.place(x = quadraticx, y = quadraticy)

        #Quadratic Equation code
        new_label = tk.Label(frame, text="Quadratic Equation Calculator", font= ("Consolas", 22), bg="#262626", fg="#ff99cc")
        new_label.grid(row=0, column=0, columnspan=4)

        equation_label = tk.Label(frame, text="axÂ² + bx + c = 0", font= ("Consolas", 22), bg="#262626", fg="#ff9999")
        equation_label.grid(row=1, column=0, columnspan=4)

        a_value = tk.Label(frame, text="Value of a: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        b_value = tk.Label(frame, text="Value of b: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        c_value = tk.Label(frame, text="Value of c: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))

        a_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font=("Consolas", 15))
        b_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font=("Consolas", 15))
        c_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font=("Consolas", 15))

        a_value.grid(row=2, column=0, padx=20, pady=20)
        b_value.grid(row=3, column=0, padx=20, pady=20)
        c_value.grid(row=4, column=0, padx=20, pady=20)

        a_input.grid(row=2, column=1, padx=100, pady=20)
        b_input.grid(row=3, column=1, padx=100, pady=20)
        c_input.grid(row=4, column=1, padx=100, pady=20)

        def quadratic_submit_button():
            global wrong_input
            global x_values
            global x
            global eq_label
            global equation
            a_num = a_input.get()
            b_num = b_input.get()
            c_num = c_input.get()
            try:
                wrong_input.destroy()
            except:
                pass
            try:
                x_values.destroy()
                x.destroy()
            except:
                pass
            try:
                eq_label.destroy()
                equation.destroy()
            except:
                pass
            try:
                a_float = float(a_num)
                b_float = float(b_num)
                c_float = float(c_num)
                ans = numpy.roots([a_float, b_float, c_float])
                ans_1 = numpy.round(ans[0], 3)
                ans_2 = numpy.round(ans[1], 3)
                x_values = tk.Label(frame, text="Roots of x: ", fg="#ff9999", bg="#262626", font=("Consolas", 15))
                x_values.grid(row=8, column=0, padx=20, pady=20)
                if ans_1 == ans_2:
                    x = tk.Label(frame, text=str(ans_1), fg="white", bg="#262626", font=("Consolas", 15))
                else:
                    x = tk.Label(frame, text=str(ans_1) + ", " + str(ans_2), fg="white", bg="#262626", font=("Consolas", 15))

                x.grid(row=8, column=1, padx=100, pady=20)
            except:
                wrong_input = tk.Label(frame, text="Error: Invalid Input", fg="#ff0000", bg="#262626", font=("Consolas", 15))
                wrong_input.grid(row=6, column=0, pady=20)

        def quadratic_clear_button():
            global wrong_input
            global x_values
            global x
            global eq_label
            global equation
            a_input.delete(0, "end")
            b_input.delete(0, "end")
            c_input.delete(0, "end")
            try:
                wrong_input.destroy()
            except:
                pass
            try:
                x_values.destroy()
                x.destroy()
            except:
                pass
            try:
                eq_label.destroy()
                equation.destroy()
            except:
                pass

        submit_button = tk.Button(frame, text="Submit", fg="#66FF99", bg="#737373", font=("Consolas", 12), command=quadratic_submit_button, width = 30)
        clear_button = tk.Button(frame, text="Clear", fg="#66FF99", bg="#737373", font=("Consolas", 12), command=quadratic_clear_button, width = 30)

        submit_button.grid(row=5, column=1, padx=100, pady=20)
        clear_button.grid(row=6, column=1, padx=100, pady=20)

        #End
        return_button()
    sound()
    quadratic_inner()

def cubic():
    def cubic_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Math â Polynomials â Cubic Equation", bg="#5be471")
        path.place(x = pathx, y = pathy)
    

        #Cubic Equation code
        frame = tk.Frame(new_window, bg="#262626")
        frame.place(x = cubicx, y = cubicy)

        new_label = tk.Label(frame, text="Cubic Equation Calculator", font= ("Consolas", 22), bg="#262626", fg="#ff99cc")
        new_label.grid(row=0, column=0, columnspan=4)

        equation_label = tk.Label(frame, text="axÂ³ + bxÂ² + cx + d = 0", font=("Consolas", 18), bg="#262626", fg="#ff9999")
        equation_label.grid(row=1, column=0, columnspan=4)

        a_value = tk.Label(frame, text="Value of a: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        b_value = tk.Label(frame, text="Value of b: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        c_value = tk.Label(frame, text="Value of c: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        d_value = tk.Label(frame, text="Value of d: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))

        a_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")
        b_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")
        c_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")
        d_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")

        a_value.grid(row=2, column=0, padx=20, pady=20)
        b_value.grid(row=3, column=0, padx=20, pady=20)
        c_value.grid(row=4, column=0, padx=20, pady=20)
        d_value.grid(row=5, column=0, padx=20, pady=20)

        a_input.grid(row=2, column=1, padx=100, pady=20)
        b_input.grid(row=3, column=1, padx=100, pady=20)
        c_input.grid(row=4, column=1, padx=100, pady=20)
        d_input.grid(row=5, column=1, padx=100, pady=20)

        def cubic_submit_button():
            global wrong_input
            global x_values
            global x
            global eq_label
            global equation
            a_num = a_input.get()
            b_num = b_input.get()
            c_num = c_input.get()
            d_num = d_input.get()
            try:
                wrong_input.destroy()
            except:
                pass
            try:
                x_values.destroy()
                x.destroy()
            except:
                pass
            try:
                eq_label.destroy()
                equation.destroy()
            except:
                pass
            try:
                a_float = float(a_num)
                b_float = float(b_num)
                c_float = float(c_num)
                d_float = float(d_num)
                ans = numpy.roots([a_float, b_float, c_float, d_float])
                ans_1 = numpy.round(ans[0], 3)
                ans_2 = numpy.round(ans[1], 3)
                ans_3 = numpy.round(ans[2], 3)
                x_values = tk.Label(frame, text="Roots of x: ", fg="#ff9999", bg="#262626",
                                    font=("Consolas", 15))
                x_values.grid(row=8, column=0, padx=20, pady=20)
                x = tk.Label(frame, text=str(ans_1) + ", " + str(ans_2) + ", " + str(ans_3), fg="white", bg="#262626",
                            font=("Consolas", 15))

                x.grid(row=8, column=1, padx=100, pady=20)
            except:
                wrong_input = tk.Label(frame, text="Error: Invalid Input", fg="#ff0000", bg="#262626", font=("Consolas", 15))
                wrong_input.grid(row=7, column=0, pady=20)

        def cubic_clear_button():
            global wrong_input
            global x_values
            global x
            global eq_label
            global equation
            a_input.delete(0, "end")
            b_input.delete(0, "end")
            c_input.delete(0, "end")
            d_input.delete(0, "end")
            try:
                wrong_input.destroy()
            except:
                pass
            try:
                x_values.destroy()
                x.destroy()
            except:
                pass
            try:
                eq_label.destroy()
                equation.destroy()
            except:
                pass

        submit_button = tk.Button(frame, text="Submit", fg="#66FF99", bg="#737373", font=("Consolas", 12), command=cubic_submit_button,
                                width=30)
        clear_button = tk.Button(frame, text="Clear", fg="#66FF99", bg="#737373", font=("Consolas", 12), command=cubic_clear_button,
                                width=30)

        submit_button.grid(row=6, column=1, padx=100, pady=20)
        clear_button.grid(row=7, column=1, padx=100, pady=20)

        #End
        return_button()
    sound()
    cubic_inner()

def quartic():
    def quartic_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Math â Polynomials â Quartic Equation", bg="#5be471")
        path.place(x = pathx, y = pathy)
    

        #Quartic Equation code
        frame = tk.Frame(new_window, bg="#262626")
        frame.place(x = quarticx, y = quarticy)

        new_label = tk.Label(frame, text="Quartic Equation Calculator", font=("Consolas", 22), bg="#262626", fg="#ff99cc")
        new_label.grid(row=0, column=0, columnspan=4)

        equation_label = tk.Label(frame, text="axâ´ + bxÂ³ + cxÂ² + dx + e = 0", font=("Consolas", 18), bg="#262626", fg="#ff9999")
        equation_label.grid(row=1, column=0, columnspan=4)

        a_value = tk.Label(frame, text="Value of a: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        b_value = tk.Label(frame, text="Value of b: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        c_value = tk.Label(frame, text="Value of c: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        d_value = tk.Label(frame, text="Value of d: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))
        e_value = tk.Label(frame, text="Value of e: ", bg="#262626", fg="#ffff99", font=("Consolas", 15))

        a_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")
        b_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")
        c_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")
        d_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")
        e_input = tk.Entry(frame, width=40, borderwidth=2, fg="white", bg="#737373", font="Consolas")

        a_value.grid(row=2, column=0, padx=20, pady=20)
        b_value.grid(row=3, column=0, padx=20, pady=20)
        c_value.grid(row=4, column=0, padx=20, pady=20)
        d_value.grid(row=5, column=0, padx=20, pady=20)
        e_value.grid(row=6, column=0, padx=20, pady=20)

        a_input.grid(row=2, column=1, padx=100, pady=20)
        b_input.grid(row=3, column=1, padx=100, pady=20)
        c_input.grid(row=4, column=1, padx=100, pady=20)
        d_input.grid(row=5, column=1, padx=100, pady=20)
        e_input.grid(row=6, column=1, padx=100, pady=20)

        def quartic_submit_button():
            global wrong_input
            global x_values
            global x
            global eq_label
            global equation
            a_num = a_input.get()
            b_num = b_input.get()
            c_num = c_input.get()
            d_num = d_input.get()
            e_num = e_input.get()
            try:
                wrong_input.destroy()
            except:
                pass
            try:
                x_values.destroy()
                x.destroy()
            except:
                pass
            try:
                eq_label.destroy()
                equation.destroy()
            except:
                pass
            try:
                a_float = float(a_num)
                b_float = float(b_num)
                c_float = float(c_num)
                d_float = float(d_num)
                e_float = float(e_num)
                ans = numpy.roots([a_float, b_float, c_float, d_float, e_float])
                ans_1 = numpy.round(ans[0], 3)
                ans_2 = numpy.round(ans[1], 3)
                ans_3 = numpy.round(ans[2], 3)
                ans_4 = numpy.round(ans[3], 3)
                x_values = tk.Label(frame, text="Roots of x: ", fg="#ff9999", bg="#262626", font=("Consolas", 15))
                x_values.grid(row=9, column=0, padx=20, pady=20)
                x = tk.Label(frame, text=str(ans_1) + ", " + str(ans_2) + ", " + str(ans_3) + ", " + str(ans_4), fg="white",
                            bg="#262626", font=("Consolas", 11))

                x.grid(row=9, column=1, padx=100, pady=20)
            except:
                wrong_input = tk.Label(frame, text="Error: Invalid Input", fg="#ff0000", bg="#262626", font=("Consolas", 15))
                wrong_input.grid(row=8, column=0, pady=20)

        def quartic_clear_button():
            global wrong_input
            global x_values
            global x
            global eq_label
            global equation
            a_input.delete(0, "end")
            b_input.delete(0, "end")
            c_input.delete(0, "end")
            d_input.delete(0, "end")
            e_input.delete(0, "end")
            try:
                wrong_input.destroy()
            except:
                pass
            try:
                x_values.destroy()
                x.destroy()
            except:
                pass
            try:
                eq_label.destroy()
                equation.destroy()
            except:
                pass

        submit_button = tk.Button(frame, text="Submit", fg="#66FF99", bg="#737373", font=("Consolas", 12), command=quartic_submit_button,
                                width=30)
        clear_button = tk.Button(frame, text="Clear", fg="#66FF99", bg="#737373", font=("Consolas", 12), command=quartic_clear_button,
                                width=30)

        submit_button.grid(row=7, column=1, padx=100, pady=20)
        clear_button.grid(row=8, column=1, padx=100, pady=20)

        #End
        return_button()
    sound()
    quartic_inner()

#Math Applications
def calculator():
    def calculator_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Math â Calculator", bg="#5be471")
        path.place(x = pathx, y = pathy)

        frame = tk.Frame(new_window, pady=35, bg="#262626")
        frame.place(x = calculatorx, y = calculatory)


        new_label = tk.Label(frame, text="Calculator", font=("Consolas", 25), bg="#262626", fg="#ff99cc")
        new_label.grid(row=0, column=0, columnspan=4)

        #Calculator code
        num = tk.Entry(frame, width=30, borderwidth=5, font="Consolas", bg="#262626", fg="white")
        num.grid(row=1, column=0, columnspan=4, padx=20, pady=40)

        def button_click(number):
            current = num.get()
            num.delete(0, "end")
            num.insert(0, str(current) + str(number))

        def button_erase():
            length = num.get()
            num.delete(len(length) - 1)

        def button_clear():
            num.delete(0, "end")

        def button_add():
            global operation
            global f_num
            first_number = num.get()
            f_num = float(first_number)
            operation = "addition"
            num.delete(0, "end")

        def button_subtract():
            global operation
            global f_num
            first_number = num.get()
            f_num = float(first_number)
            operation = "subtraction"
            num.delete(0, "end")

        def button_multiply():
            global operation
            global f_num
            first_number = num.get()
            f_num = float(first_number)
            operation = "multiplication"
            num.delete(0, "end")

        def button_divide():
            global operation
            global f_num
            first_number = num.get()
            f_num = float(first_number)
            operation = "division"
            num.delete(0, "end")

        def button_equal():
            global operation
            global f_num
            second_number = num.get()
            num.delete(0, "end")
            if operation == "addition":
                num.insert(0, f_num + float(second_number))
            elif operation == "subtraction":
                num.insert(0, f_num - float(second_number))
            elif operation == "multiplication":
                num.insert(0, f_num * float(second_number))
            elif operation == "division":
                num.insert(0, f_num / float(second_number))

        button_point = tk.Button(frame, text=".", padx=53, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                                command=lambda: button_click("."))
        button_0 = tk.Button(frame, text="0", padx=61, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(0))
        button_1 = tk.Button(frame, text="1", padx=61, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(1))
        button_2 = tk.Button(frame, text="2", padx=53, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(2))
        button_3 = tk.Button(frame, text="3", padx=51, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(3))
        button_4 = tk.Button(frame, text="4", padx=61, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(4))
        button_5 = tk.Button(frame, text="5", padx=53, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(5))
        button_6 = tk.Button(frame, text="6", padx=51, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(6))
        button_7 = tk.Button(frame, text="7", padx=61, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(7))
        button_8 = tk.Button(frame, text="8", padx=53, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(8))
        button_9 = tk.Button(frame, text="9", padx=51, pady=20, fg="white", bg="#4d4d4d", font="Consolas",
                            command=lambda: button_click(9))
        button_divide = tk.Button(frame, text="Ã·", padx=50, pady=20, fg="white", bg="#737373", font="Consolas",
                                command=button_divide)
        button_multiply = tk.Button(frame, text="Ã", padx=50, pady=20, fg="white", bg="#737373", font="Consolas",
                                    command=button_multiply)
        button_subtract = tk.Button(frame, text="-", padx=50, pady=20, fg="white", bg="#737373", font="Consolas",
                                    command=button_subtract)
        button_add = tk.Button(frame, text="+", padx=50, pady=20, fg="white", bg="#737373", font="Consolas",
                            command=button_add)
        button_equal = tk.Button(frame, text="=", padx=51, pady=20, fg="white", bg="#737373", font="Consolas",
                                command=button_equal)
        button_clear = tk.Button(frame, text="C", padx=125, pady=20, fg="white", bg="#737373", font="Consolas",
                                command=button_clear)
        button_erase = tk.Button(frame, text="â«", padx=106, pady=20, fg="white", bg="#737373", font="Consolas",
                                command=button_erase)

        button_clear.grid(row=2, column=0, columnspan=2)
        button_erase.grid(row=2, column=2, columnspan=2)

        button_7.grid(row=3, column=0)
        button_8.grid(row=3, column=1)
        button_9.grid(row=3, column=2)
        button_divide.grid(row=3, column=3)

        button_4.grid(row=4, column=0)
        button_5.grid(row=4, column=1)
        button_6.grid(row=4, column=2)
        button_multiply.grid(row=4, column=3)

        button_1.grid(row=5, column=0)
        button_2.grid(row=5, column=1)
        button_3.grid(row=5, column=2)
        button_subtract.grid(row=5, column=3)

        button_0.grid(row=6, column=0)
        button_point.grid(row=6, column=1)
        button_equal.grid(row=6, column=2)
        button_add.grid(row=6, column=3)


        #End
        return_button()
    sound()
    calculator_inner()

def polynomials():
    def polynomials_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Math â Polynomials", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Polynomials code
        heading = tk.Label(new_window, text="Polynomials", bg="#262626", fg="#99ccff", font=("Calibri", 25))
        heading.place(x = 553, y = pathy)
    
        #Buttons Color execution functions
        def quadratic_enter(nul):
            quadratic_button.config(bg="#46d149", width=32, height=3)

        def quadratic_leave(nul):
            quadratic_button.config(bg="SystemButtonFace", width=30, height=2)

        def cubic_enter(nul):
            cubic_button.config(bg="#46d149", width=32, height=3)

        def cubic_leave(nul):
            cubic_button.config(bg="SystemButtonFace", width=30, height=2)

        def quartic_enter(nul):
            quartic_button.config(bg="#46d149", width=32, height=3)

        def quartic_leave(nul):
            quartic_button.config(bg="SystemButtonFace", width=30, height=2)

        #Quadratic Equation button
        quadratic_button = tk.Button(new_window, text = "Quadratic Equation", command = quadratic, width = 30, height = 2, font = "Consolas", activebackground="pink")
        quadratic_button.place(x = for3x1, y = for3y)

        #Cubic Equation button
        cubic_button = tk.Button(new_window, text = "Cubic Equation", command = cubic, width = 30, height = 2, font = "Consolas", activebackground="pink")
        cubic_button.place(x = for3x2, y = for3y)

        #Quartic Equation button
        quartic_button = tk.Button(new_window, text = "Quartic Equation", command = quartic, width = 30, height = 2, font = "Consolas", activebackground="pink")
        quartic_button.place(x = for3x3, y = for3y)

        #Buttons Color execution
        quadratic_button.bind("<Enter>", quadratic_enter)
        quadratic_button.bind("<Leave>", quadratic_leave)

        cubic_button.bind("<Enter>", cubic_enter)
        cubic_button.bind("<Leave>", cubic_leave)

        quartic_button.bind("<Enter>", quartic_enter)
        quartic_button.bind("<Leave>", quartic_leave)

        #End
        return_button()
    sound()
    polynomials_inner()

def conversions():
    def conversions_inner():
        design()
        logo()
        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Math â Digital Storage Converter", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Digial storage conversions code

        frame = tk.Frame(new_window, bg="#262626")
        frame.place(x = converterx, y = convertery)

        def selectedOption1(event):
            selected1 = drop1.get()
            selected2 = drop2.get()
            if selected1 == selected2:
                drop2.delete(0, "end")

        def selectedOption2(event):
            selected1 = drop1.get()
            selected2 = drop2.get()
            if selected1 == selected2:
                drop1.delete(0, "end")

        def conversion():
            selected1 = drop1.get()
            selected2 = drop2.get()
            if selected1 == "Bit" or selected2 == "Bit":
                bit()
            if selected1 == "Byte" or selected2 == "Byte":
                byte()
            if selected1 == "Kilobyte" or selected2 == "Kilobyte":
                kilobyte()
            if selected1 == "Megabyte" or selected2 == "Megabyte":
                megabyte()
            if selected1 == "Gigabyte" or selected2 == "Gigabyte":
                gigabyte()
            if selected1 == "Terabyte" or selected2 == "Terabyte":
                terabyte()

        def bit():
            selected1 = drop1.get()
            selected2 = drop2.get()
            num1 = unit_1.get()
            num2 = unit_2.get()

            if selected1 == "Byte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / 8
                unit_1.insert(0, str(ans))
            if selected2 == "Byte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / 8
                unit_2.insert(0, str(ans))

            if selected1 == "Kilobyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (8 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Kilobyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (8 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Megabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (8 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Megabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (8 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Gigabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (8 * 1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Gigabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (8 * 1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Terabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (8 * 1000 * 1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Terabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (8 * 1000 * 1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

        def byte():
            selected1 = drop1.get()
            selected2 = drop2.get()
            num1 = unit_1.get()
            num2 = unit_2.get()

            if selected1 == "Bit":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * 8
                unit_1.insert(0, str(ans))
            if selected2 == "Bit":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * 8
                unit_2.insert(0, str(ans))

            if selected1 == "Kilobyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / 1000
                unit_1.insert(0, str(ans))
            if selected2 == "Kilobyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / 1000
                unit_2.insert(0, str(ans))

            if selected1 == "Megabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Megabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Gigabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Gigabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Terabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (1000 * 1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Terabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (1000 * 1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

        def kilobyte():
            selected1 = drop1.get()
            selected2 = drop2.get()
            num1 = unit_1.get()
            num2 = unit_2.get()

            if selected1 == "Bit":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (8 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Bit":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (8 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Byte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * 1000
                unit_1.insert(0, str(ans))
            if selected2 == "Byte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * 1000
                unit_2.insert(0, str(ans))

            if selected1 == "Megabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / 1000
                unit_1.insert(0, str(ans))
            if selected2 == "Megabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / 1000
                unit_2.insert(0, str(ans))

            if selected1 == "Gigabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Gigabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Terabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Terabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

        def megabyte():
            selected1 = drop1.get()
            selected2 = drop2.get()
            num1 = unit_1.get()
            num2 = unit_2.get()

            if selected1 == "Bit":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (8 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Bit":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (8 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Byte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Byte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Kilobyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * 1000
                unit_1.insert(0, str(ans))
            if selected2 == "Kilobyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * 1000
                unit_2.insert(0, str(ans))

            if selected1 == "Gigabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / 1000
                unit_1.insert(0, str(ans))
            if selected2 == "Gigabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / 1000
                unit_2.insert(0, str(ans))

            if selected1 == "Terabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / (1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Terabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / (1000 * 1000)
                unit_2.insert(0, str(ans))

        def gigabyte():
            selected1 = drop1.get()
            selected2 = drop2.get()
            num1 = unit_1.get()
            num2 = unit_2.get()

            if selected1 == "Bit":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (8 * 1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Bit":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (8 * 1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Byte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Byte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Kilobyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Kilobyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Megabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * 1000
                unit_1.insert(0, str(ans))
            if selected2 == "Megabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * 1000
                unit_2.insert(0, str(ans))

            if selected1 == "Terabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 / 1000
                unit_1.insert(0, str(ans))
            if selected2 == "Terabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 / 1000
                unit_2.insert(0, str(ans))

        def terabyte():
            selected1 = drop1.get()
            selected2 = drop2.get()
            num1 = unit_1.get()
            num2 = unit_2.get()

            if selected1 == "Bit":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (8 * 1000 * 1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Bit":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (8 * 1000 * 1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Byte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (1000 * 1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Byte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (1000 * 1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Kilobyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (1000 * 1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Kilobyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (1000 * 1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Megabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * (1000 * 1000)
                unit_1.insert(0, str(ans))
            if selected2 == "Megabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * (1000 * 1000)
                unit_2.insert(0, str(ans))

            if selected1 == "Gigabyte":
                try:
                    num2 = float(num2)
                except:
                    return
                try:
                    unit_1.delete(0, "end")
                except:
                    pass
                ans = num2 * 1000
                unit_1.insert(0, str(ans))
            if selected2 == "Gigabyte":
                try:
                    num1 = float(num1)
                except:
                    return
                try:
                    unit_2.delete(0, "end")
                except:
                    pass
                ans = num1 * 1000
                unit_2.insert(0, str(ans))

        def clear_converter():
            unit_1.delete(0, "end")
            unit_2.delete(0, "end")

        new_label = tk.Label(frame, text="Digital Storage Converter", font=("Consolas", 27), bg="#262626", fg="#ff99cc")
        unit_1 = tk.Entry(frame, width=20, borderwidth=2, fg="white", bg="#737373", font=("Consolas", 15))
        equal_label = tk.Label(frame, text="=", fg="white", bg="#262626", font=("Consolas", 30))
        unit_2 = tk.Entry(frame, width=20, borderwidth=2, fg="white", bg="#737373", font=("Consolas", 15))

        new_label.grid(row=0, column=0, columnspan=4)
        unit_1.grid(row=1, column=0, pady=20, padx=30)
        equal_label.grid(row=1, column=1, pady=20)
        unit_2.grid(row=1, column=2, pady=20, padx=30)

        options_1 = [
            "Bit",
            "Byte",
            "Kilobyte",
            "Megabyte",
            "Gigabyte",
            "Terabyte"
        ]

        options_2 = [
            "Bit",
            "Byte",
            "Kilobyte",
            "Megabyte",
            "Gigabyte",
            "Terabyte"
        ]

        drop1 = ttk.Combobox(frame, values=options_1, width=20, font=("Consolas", 14))
        drop2 = ttk.Combobox(frame, values=options_2, width=20, font=("Consolas", 14))

        drop1.set("Select")
        drop1.bind("<<ComboboxSelected>>", selectedOption1)

        drop2.set("Select")
        drop2.bind("<<ComboboxSelected>>", selectedOption2)

        convert_button = tk.Button(frame, text="Convert", fg="white", bg="#737373", font="Consolas", command=conversion)
        clear_button = tk.Button(frame, text="Clear", fg="white", bg="#737373", font="Consolas", command=clear_converter)

        drop1.grid(row=2, column=0)
        drop2.grid(row=2, column=2)
        convert_button.grid(row=3, column=0, columnspan=4, pady=50)
        clear_button.grid(row=4, column=0, columnspan=4)

        #End
        return_button()
    sound()
    conversions_inner()

#Time Applications
def clock():
    def clock_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Time â Clock", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Clock code
        frame = tk.Frame(new_window, bg="#262626")
        frame.place(x = clockx, y = clocky)

        def clock_time():
            string = strftime('%H:%M:%S %p')
            lbl.config(text=string)
            lbl.after(1000, clock_time)

        new_label = tk.Label(frame, text="Digital Clock", font=("Consolas", 35), bg="#262626", fg="#ff99cc")
        lbl = tk.Label(frame, font=('calibri', 100, 'bold'),
                        foreground='white', bg="#262626")

        new_label.grid(row=0, column=0, columnspan=4, pady=20)
        lbl.grid(row=1, column=0, pady=20, padx=30)
        clock_time()

        #End
        return_button()
    sound()
    clock_inner()

def timer():
    def timer_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Time â Timer", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Timer code
        new_window.option_add("*insertBackground", "#262626")

        frame = tk.Frame(new_window, bg="#262626")
        frame.place(x=stopwatchx, y=stopwatchy)

        def start():
            global times
            global seconds
            global hours
            global minutes
            global count
            global running
            running = True
            times = int(hrs.get()) * 3600 + int(mins.get()) * 60 + int(sec.get())
            while times > -1:
                if running is False:
                    break
                else:
                    minutes, seconds = (times // 60, times % 60)

                    if minutes >= 60:
                        hours, minutes = (minutes // 60, minutes % 60)
                        if len(str(hours)) > 1:
                            hrs.set(str(hours))
                        else:
                            hrs.set("0" + str(hours))

                    if minutes > 0:
                        if len(str(minutes)) > 1:
                            mins.set(str(minutes))
                        else:
                            mins.set("0" + str(minutes))
                    else:
                        mins.set("00")

                    if seconds > 0:
                        if len(str(seconds)) > 1:
                            sec.set(str(seconds))
                        else:
                            sec.set("0" + str(seconds))
                    else:
                        sec.set("00")

                    new_window.update()
                    sleep(1)

                    if times == 0:
                        ringtone = pygame.mixer.Sound(ringtone_path)
                        ringtone.play()

                    count += 1
                    times -= 1

        def stop():
            global times
            global seconds
            global hours
            global minutes
            global count
            global running
            running = False
            count -= 1

        def reset():
            global times
            global count
            global running
            if running is False:
                running = True
                times = int(hrs.get()) * 3600 + int(mins.get()) * 60 + int(sec.get()) + count - 1
                count = 1
                while times > -1:
                    if running is False:
                        break
                    else:
                        minutes, seconds = (times // 60, times % 60)

                        if minutes >= 60:
                            hours, minutes = (minutes // 60, minutes % 60)
                            if len(str(hours)) > 1:
                                hrs.set(str(hours))
                            else:
                                hrs.set("0" + str(hours))

                        if minutes > 0:
                            if len(str(minutes)) > 1:
                                mins.set(str(minutes))
                            else:
                                mins.set("0" + str(minutes))
                        else:
                            mins.set("00")

                        if seconds > 0:
                            if len(str(seconds)) > 1:
                                sec.set(str(seconds))
                            else:
                                sec.set("0" + str(seconds))
                        else:
                            sec.set("00")

                        new_window.update()
                        sleep(1)

                        if times == 0:
                            ringtone = pygame.mixer.Sound(ringtone_path)
                            ringtone.play()

                        count += 1
                        times -= 1
            else:
                times = int(hrs.get()) * 3600 + int(mins.get()) * 60 + int(sec.get()) + count
                count = 0

        new_label = tk.Label(frame, text="Timer", font=("Consolas", 22), bg="#262626", fg="#ff99cc")

        colon_label1 = tk.Label(frame, text=":", font=("Consolas", 22), bg="#262626", fg="white")
        colon_label2 = tk.Label(frame, text=":", font=("Consolas", 22), bg="#262626", fg="white")

        hrs = tk.StringVar()
        hrs_input = tk.Entry(frame, textvariable=hrs, bg="#262626", fg="white", font=("Consolas", 22), width=2, bd=0)
        hrs.set("00")

        mins = tk.StringVar()
        min_input = tk.Entry(frame, textvariable=mins, bg="#262626", fg="white", font=("Consolas", 22), width=2, bd=0)
        mins.set("00")

        sec = tk.StringVar()
        sec_input = tk.Entry(frame, textvariable=sec, bg="#262626", fg="white", font=("Consolas", 22), width=2, bd=0)
        sec.set("00")

        start_button = tk.Button(frame, text="â¶", fg="white", bg="#737373", font=("Consolas", 22), command=start)
        stop_button = tk.Button(frame, text="â¸", fg="white", bg="#737373", font=("Consolas", 22), command=stop)
        reset_button = tk.Button(frame, text="â»", fg="white", bg="#737373", font=("Consolas", 22), command=reset)

        new_label.grid(pady=50, columnspan=5)
        hrs_input.grid(row=1, column=0, padx=10)
        colon_label1.grid(row=1, column=1)
        min_input.grid(row=1, column=2, padx=10)
        colon_label2.grid(row=1, column=3)
        sec_input.grid(row=1, column=4, padx=10)
        start_button.grid(row=2, column=0, pady=40, ipadx=20)
        stop_button.grid(row=2, column=2, ipadx=15)
        reset_button.grid(row=2, column=4, ipadx=18)

        #End
        return_button()
    sound()
    timer_inner()

def stopwatch():
    def stopwatch_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Time â Stopwatch", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Stopwatch code
        frame = tk.Frame(new_window, bg="#262626")
        frame.place(x = stopwatchx, y = stopwatchy)


        def milliseconds_label(lab):
            def count():
                if running:
                    global milliseconds
                    tt = datetime.fromtimestamp(milliseconds)
                    if milliseconds > 600:
                        date_object = tt.strftime('%H:%M:%S')
                    elif milliseconds > 60:
                        date_object = tt.strftime('%M:%S:%f')[:-4]
                    else:
                        date_object = tt.strftime('%M:%S:%f')[:-4]
                    display = date_object

                    lab['text'] = display

                    lab.after(10, count)
                    milliseconds += 0.01

            count()

        def Start(label):
            global running
            running = True
            outside_timer = False
            milliseconds_label(label)

            start['state'] = 'disabled'
            start['highlightbackground'] = 'black'

            stop['state'] = 'normal'
            stop['highlightbackground'] = 'red'

            reset['state'] = 'normal'
            reset['highlightbackground'] = 'dark grey'

        def Stop():
            global running
            start['state'] = 'normal'
            start['highlightbackground'] = 'green'

            stop['state'] = 'disabled'
            stop['highlightbackground'] = 'black'

            reset['state'] = 'normal'
            reset['highlightbackground'] = 'dark grey'

            running = False

        def Reset(label):
            global milliseconds
            milliseconds = 00000
            if running == False:
                reset['state'] = 'disabled'
                reset['highlightbackground'] = 'black'

            label['text'] = "00:00:00"

        new_label = tk.Label(frame, text="Stopwatch", font=("Consolas", 30), bg="#262626", fg="#ff99cc")
        new_label.pack(pady=25)
        label = Label(frame, text="00:00:00", fg="white", font="Geneva 45 bold", bg="#262626")
        label.pack()

        start = Button(frame, text='Start', width=7, height=3, command=lambda: Start(label), font="Geneva 15 bold", fg="white", bg="#737373")
        reset = Button(frame, text='Reset', width=7, height=3, state='disabled', command=lambda: Reset(label), font="Geneva 15 bold", borderwidth=0, fg="white", bg="#737373")
        stop = Button(frame, text='Stop', width=7, height=3, state='disabled', command=Stop, font="Geneva 15 bold", fg="white", bg="#737373")


        start.pack(side="left", pady=40)
        reset.pack(side="left", pady=40)
        stop.pack(side="left", pady=40)


        #End
        return_button()
    sound()
    stopwatch_inner()

#Other Applications
def notepad():
    def notepad_inner():
        logo()
        new_notepad_window = tk.Toplevel(window)
        new_notepad_window.attributes('-fullscreen', True)
        new_notepad_window.configure(bg='#262626')

        #Start
        path = tk.Label(new_notepad_window, text="MAIN â Applications â Other â Notepad", bg="#5be471")
        path.place(x = pathx, y = pathy)

        notepad_logo = tk.Label(new_notepad_window, text="MathLab GUI", bg="#7cd8e0")
        notepad_logo.place(x = logox, y = pathy)

        #Notepad code
        heading = tk.Label(new_notepad_window, text="Notepad", bg="#262626", fg="#ff99cc", font=("Calibri", 25))
        heading.place(x = 577, y = pathy)

        notepad = tk.Text(new_notepad_window)
        notepad.place(x = notepadx, y = notepady)

        #Notepad Exit Button Color execution functions
        def notepad_exit_enter(nul):
            notepad_exit_button.config(bg="#e05122", width=17, height=1)

        def notepad_exit_leave(nul):
            notepad_exit_button.config(bg="SystemButtonFace", width=15, height=1)

        #Notepad Exit button
        notepad_exit_button = tk.Button(new_notepad_window, text = "Close Notepad", command = new_notepad_window.destroy, activebackground="red", width=15, height=1, font = ("Consolas", 10))
        notepad_exit_button.place(x = 1130, y = 660)

        #Notepad Button Color execution
        notepad_exit_button.bind("<Enter>", notepad_exit_enter)
        notepad_exit_button.bind("<Leave>", notepad_exit_leave)

        #End
        return_button()
    sound()
    notepad_inner()
    
def form():
    def form_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Other â Student Form", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Form code
        heading = tk.Label(new_window, text="Student Form", bg="#262626", fg="#ff99cc", font=("Calibri", 25))
        heading.place(x = 540, y = pathy)

        wb = load_workbook(sheet_path)
        sheet = wb.active

        #Initialize excel sheet
        def excel():
            sheet.column_dimensions['A'].width = 15
            sheet.column_dimensions['B'].width = 13
            sheet.column_dimensions['C'].width = 12
            sheet.column_dimensions['D'].width = 17
            sheet.column_dimensions['E'].width = 17
            sheet.column_dimensions['F'].width = 20
            sheet.column_dimensions['G'].width = 18

            sheet.cell(row=1, column=1).value = "Name"
            sheet.cell(row=1, column=2).value = "Student ID"
            sheet.cell(row=1, column=3).value = "Grade"
            sheet.cell(row=1, column=4).value = "Section"
            sheet.cell(row=1, column=5).value = "Phone"
            sheet.cell(row=1, column=6).value = "Email"
            sheet.cell(row=1, column=7).value = "Address"

        #Refreshing
        def clear_form():
            name_field.delete(0, END)
            student_id_field.delete(0, END)
            grade_field.delete(0, END)
            section_field.delete(0, END)
            phone_field.delete(0, END)
            email_field.delete(0, END)
            address_field.delete(0, END)

        #Data In
        def insert():
            if (name_field.get() == "" and student_id_field.get() == "" and grade_field.get() == "" and section_field.get() == "" and
                phone_field.get() == "" and email_field.get() == "" and address_field.get() == ""):

                def message():
                    empty_promt['text'] = ("")
                    empty_promt['background'] = "#262626"


                def delay():
                    empty_promt['text'] = "No data entered, fill in the information"
                    empty_promt['font'] = "Calibri"
                    empty_promt['background'] = "#262626"
                    empty_promt['foreground'] = "light green"
                    new_window.after(1000, message)

                empty_promt = Label(new_window)
                empty_promt.place(x = formx + 100, y = 500)

            else:
                current_row = sheet.max_row

                sheet.cell(row=current_row + 1, column=1).value = name_field.get()
                sheet.cell(row=current_row + 1, column=2).value = student_id_field.get()
                sheet.cell(row=current_row + 1, column=3).value = grade_field.get()
                sheet.cell(row=current_row + 1, column=4).value = section_field.get()
                sheet.cell(row=current_row + 1, column=5).value = phone_field.get()
                sheet.cell(row=current_row + 1, column=6).value = email_field.get()
                sheet.cell(row=current_row + 1, column=7).value = address_field.get()

                wb.save(sheet_path)
                name_field.focus_set()
                clear_form()
            delay()

        #Start with sheet initializing
        excel()

        #Submit button
        submit = Button(new_window, text="Submit", fg="Black", bg="light blue", command=insert)
        submit.place(x = 600, y = 550)

        #Frames
        name_frame = Frame(new_window, bg="#262626")
        name_frame.place(x=formx, y=150)

        student_id_frame = Frame(new_window, bg="#262626")
        student_id_frame.place(x=formx, y=200)

        grade_frame = Frame(new_window, bg="#262626")
        grade_frame.place(x=formx, y=250)

        section_frame = Frame(new_window, bg="#262626")
        section_frame.place(x=formx, y=300)

        phone_frame = Frame(new_window, bg="#262626")
        phone_frame.place(x=formx, y=350)

        email_frame = Frame(new_window, bg="#262626")
        email_frame.place(x=formx, y=400)

        address_frame = Frame(new_window, bg="#262626")
        address_frame.place(x=formx, y=450)

        #Labels & Entries
        name_label = Label(name_frame, text="Name               ", bg="#262626", fg="#ffff99", font=("Calibri", 17))
        name_field = Entry(name_frame)
        name_label.grid(row=0, column=0)
        name_field.grid(row=0, column=1, ipadx="100")

        student_id_label = Label(student_id_frame, text="Student ID      ", bg="#262626", fg="#ffff99", font=("Calibri", 17))
        student_id_field = Entry(student_id_frame)
        student_id_label.grid(row=0, column=0)
        student_id_field.grid(row=0, column=1, ipadx="100")

        grade_label = Label(grade_frame, text="Grade               ", bg="#262626", fg="#ffff99", font=("Calibri", 17))
        grade_field = Entry(grade_frame)
        grade_label.grid(row=0, column=0)
        grade_field.grid(row=0, column=1, ipadx="100")

        section_label = Label(section_frame, text="Section            ", bg="#262626", fg="#ffff99", font=("Calibri", 17))
        section_field = Entry(section_frame)
        section_label.grid(row=0, column=0)
        section_field.grid(row=0, column=1, ipadx="100")

        phone_label = Label(phone_frame, text="Phone              ", bg="#262626", fg="#ffff99", font=("Calibri", 17))
        phone_field = Entry(phone_frame)
        phone_label.grid(row=0, column=0)
        phone_field.grid(row=0, column=1, ipadx="100")

        email_label = Label(email_frame, text="Email                ", bg="#262626", fg="#ffff99", font=("Calibri", 17))
        email_field = Entry(email_frame)
        email_label.grid(row=0, column=0)
        email_field.grid(row=0, column=1, ipadx="100")

        address_label = Label(address_frame, text="Address           ", bg="#262626", fg="#ffff99", font=("Calibri", 17))
        address_field = Entry(address_frame)
        address_label.grid(row=0, column=0)
        address_field.grid(row=0, column=1, ipadx="100")

        #End
        return_button()
    sound()
    form_inner()

#Applications
def math():
    def math_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Math", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Math code
        heading = tk.Label(new_window, text="Math", bg="#262626", fg="#99ccff", font=("Calibri", 25))
        heading.place(x = 595, y = pathy)

        #Buttons Color execution functions
        def calculator_enter(nul):
            calculator_button.config(bg="#2c7d88", width=32, height=3)

        def calculator_leave(nul):
            calculator_button.config(bg="SystemButtonFace", width=30, height=2)

        def polynomials_enter(nul):
            polynomials_button.config(bg="#2c7d88", width=32, height=3)

        def polynomials_leave(nul):
            polynomials_button.config(bg="SystemButtonFace", width=30, height=2)

        def conversions_enter(nul):
            conversions_button.config(bg="#2c7d88", width=32, height=3)

        def conversions_leave(nul):
            conversions_button.config(bg="SystemButtonFace", width=30, height=2)

        #Calculator button
        calculator_button = tk.Button(new_window, text = "Calculator", command = calculator, width = 30, height = 2, font="Consolas", activebackground="pink")
        calculator_button.place(x = for3x1, y = for3y)

        #Polynomials button
        polynomials_button = tk.Button(new_window, text = "Polynomials", command = polynomials, width = 30, height = 2, font = "Consolas", activebackground="pink")
        polynomials_button.place(x = for3x2, y = for3y)

        #Conversions button
        conversions_button = tk.Button(new_window, text = "Digital Storage Converter", command = conversions, width = 30, height = 2, font="Consolas", activebackground="pink")
        conversions_button.place(x = for3x3, y = for3y)

        #Buttons Color execution
        calculator_button.bind("<Enter>", calculator_enter)
        calculator_button.bind("<Leave>", calculator_leave)

        polynomials_button.bind("<Enter>", polynomials_enter)
        polynomials_button.bind("<Leave>", polynomials_leave)

        conversions_button.bind("<Enter>", conversions_enter)
        conversions_button.bind("<Leave>", conversions_leave)
        
        #End
        return_button()
    sound()
    math_inner()

def time():
    def time_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Time", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Time code
        heading = tk.Label(new_window, text="Time", bg="#262626", fg="#99ccff", font=("Calibri", 25))
        heading.place(x = 598, y = pathy)

        #Buttons Color execution functions
        def clock_enter(nul):
            clock_button.config(bg="#5bc9d6", width=32, height=3)

        def clock_leave(nul):
            clock_button.config(bg="SystemButtonFace", width=30, height=2)

        def timer_enter(nul):
            timer_button.config(bg="#5bc9d6", width=32, height=3)

        def timer_leave(nul):
            timer_button.config(bg="SystemButtonFace", width=30, height=2)

        def stopwatch_enter(nul):
            stopwatch_button.config(bg="#5bc9d6", width=32, height=3)

        def stopwatch_leave(nul):
            stopwatch_button.config(bg="SystemButtonFace", width=30, height=2)

        #Clock button
        clock_button = tk.Button(new_window, text = "Clock", command = clock, width = 30, height = 2, font="Consolas", activebackground="pink")
        clock_button.place(x = for3x1, y = for3y)

        #Timer button
        timer_button = tk.Button(new_window, text = "Timer", command = timer, width = 30, height = 2, font="Consolas", activebackground="pink")
        timer_button.place(x = for3x2, y = for3y)

        #Stopwatch button
        stopwatch_button = tk.Button(new_window, text = "Stopwatch", command = stopwatch, width = 30, height = 2, font="Consolas", activebackground="pink")
        stopwatch_button.place(x=for3x3, y=for3y)
        
        #Buttons Color execution
        clock_button.bind("<Enter>", clock_enter)
        clock_button.bind("<Leave>", clock_leave)

        timer_button.bind("<Enter>", timer_enter)
        timer_button.bind("<Leave>", timer_leave)

        stopwatch_button.bind("<Enter>", stopwatch_enter)
        stopwatch_button.bind("<Leave>", stopwatch_leave)

        #End
        return_button()
    sound()
    time_inner()

def other():
    def other_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications â Other", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Other code
        heading = tk.Label(new_window, text="Other", bg="#262626", fg="#99ccff", font=("Calibri", 25))
        heading.place(x = 593, y = pathy)

        #Buttons Color execution functions
        def notepad_enter(nul):
            notepad_button.config(bg="#f3de63", width=32, height=3)

        def notepad_leave(nul):
            notepad_button.config(bg="SystemButtonFace", width=30, height=2)

        def form_enter(nul):
            form_button.config(bg="#f3de63", width=32, height=3)

        def form_leave(nul):
            form_button.config(bg="SystemButtonFace", width=30, height=2)

        #Notepad button
        notepad_button = tk.Button(new_window, text = "Notepad", command = notepad, width = 30, height = 2, font="Consolas", activebackground="pink")
        notepad_button.place(x=250, y=350)
        
        form_button = tk.Button(new_window, text = "Student Form", command = form, width = 30, height = 2, font="Consolas", activebackground="pink")
        form_button.place(x=750, y=350)

        #Buttons Color execution
        notepad_button.bind("<Enter>", notepad_enter)
        notepad_button.bind("<Leave>", notepad_leave)

        form_button.bind("<Enter>", form_enter)
        form_button.bind("<Leave>", form_leave)

        #End
        return_button()
    sound()
    other_inner()

#Main Page
def docs():
    def docs_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Documentation", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Docs code
        heading = tk.Label(new_window, text="Documentation", bg="#262626", fg="#99ccff", font=("Calibri", 25))
        heading.place(x = 526, y = pathy)

        #Heading
        text = tk.Label(new_window, text="Project Statistics", height=1, width=20, font=("Calibri", 22), bg="#262626", fg="#1ce2e2")
        text.place(x = for3x1 + 390, y = for3y - 230)

        #Stats headings
        text = tk.Label(new_window,
                            text=f"Project duration\n{i}lines\n{i}pages\n{i}buttons\n{i}color codes\n{i}entry boxes\n{i}frames\n{i}grids\n{i}labels\n{i}functions\n{i}conditions\n{i}libraries imported\n{i}validations",
                            height=20, width=40, font=("Arial", 14), anchor="center", bg="#151516", fg="#e90eb9",
                            justify="left")

        text.place(x = for3x1 + 180, y = for3y - 160)

        #Stats values
        text = tk.Label(new_window,
                            text=f"2.5 months\n2,300+\n18\n67\n242\n25\n8\n98\n80\n117\n95\n10\n141",
                            height=20, width=30, font=("Arial", 14), anchor="center", bg="#151516", fg="#1ad41a",
                            justify="left")

        text.place(x = for3x1 + 580, y = for3y - 160)

        #End
        return_button()
    sound()
    docs_inner()

def applications():
    def applications_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Applications", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Applications code
        heading = tk.Label(new_window, text="Applications", bg="#262626", fg="#99ccff", font=("Calibri", 25))
        heading.place(x = 534, y = pathy)

        #Buttons Color execution functions
        def math_enter(nul):
            math_button.config(bg="#b06188", width=32, height=3)

        def math_leave(nul):
            math_button.config(bg="SystemButtonFace", width=30, height=2)

        def time_enter(nul):
            time_button.config(bg="#b06188", width=32, height=3)

        def time_leave(nul):
            time_button.config(bg="SystemButtonFace", width=30, height=2)

        def other_enter(nul):
            other_button.config(bg="#b06188", width=32, height=3)

        def other_leave(nul):
            other_button.config(bg="SystemButtonFace", width=30, height=2)

        #Math button
        math_button = tk.Button(new_window, text = "Math", command = math, width = 30, height = 2, font = "Consolas", activebackground="pink",)
        math_button.place(x = for3x1, y = for3y)

        #Time button
        time_button = tk.Button(new_window, text = "Time", command = time, width = 30, height = 2, font = "Consolas", activebackground="pink")
        time_button.place(x = for3x2, y = for3y)

        #Other button
        other_button = tk.Button(new_window, text = "Other", command = other, width = 30, height = 2, font = "Consolas", activebackground="pink")
        other_button.place(x = for3x3, y = for3y)

        #Buttons Color execution
        math_button.bind("<Enter>", math_enter)
        math_button.bind("<Leave>", math_leave)

        time_button.bind("<Enter>", time_enter)
        time_button.bind("<Leave>", time_leave)

        other_button.bind("<Enter>", other_enter)
        other_button.bind("<Leave>", other_leave)

        #End
        return_button()
    sound()
    applications_inner()

def credits():
    def credits_inner():
        design()
        logo()

        #Start
        path = tk.Label(new_window, text="MAIN â Credits", bg="#5be471")
        path.place(x = pathx, y = pathy)

        #Credits code
        heading = tk.Label(new_window, text="Credits", bg="#262626", fg="#99ccff", font=("Calibri", 25))
        heading.place(x = 583, y = pathy)

        #Credits Titles
        text = tk.Label(new_window, text="Shariq", height=1, width=10, font=("Calibri", 25), bg="#262626", fg="#1ce2e2")
        text.place(x = for3x1 + 55, y = for3y - 200)

        text = tk.Label(new_window, text="Arub", height=1, width=10, font=("Calibri", 25), bg="#262626", fg="#1ce2e2")
        text.place(x = for3x2 + 55, y = for3y - 200)

        text = tk.Label(new_window, text="Ahmed", height=1, width=10, font=("Calibri", 25), bg="#262626", fg="#1ce2e2")
        text.place(x = for3x3 + 55, y = for3y - 200)

        #Credits Content
        text = tk.Label(new_window,
                            text="\nCalculator\nQuadratic\nCubic\nQuartic\nConversions\nClock\nTimer\nStopwatch\n\nFrames\nGrids\nValidations\nNests & Logic",
                            height=18, width=30,
                                font=("Arial", 14), anchor="center", bg="#151516", fg="#1ad41a",
                                justify="left")
        text.place(x = for3x1 - 20, y = for3y - 130)

        text = tk.Label(new_window,
                            text="\nStudent Form\nNotepad\nStructure\nPages\nButtons\nSounds\nBackgrounds\nDesign\nXLSX link\nFunctions\nIncased modules\nPaths\nLabels",
                            height=18, width=30,
                            font=("Arial", 14), anchor="center", bg="#151516", fg="#1ad41a",
                                justify="left")
        text.place(x = for3x2 - 20, y = for3y - 130)

        text = tk.Label(new_window,
                            text="\nStructure Diagram\nFlowchart\nDocs\nCredits\nChart\nPresentation\nProject research\nTesting\nFlyers",
                            height=18, width=30,
                            font=("Arial", 14), anchor="center", bg="#151516", fg="#1ad41a",
                                justify="left")
        text.place(x = for3x3 - 20, y = for3y - 130)

        #Credits Headings
        #Shariq - Modules
        text = tk.Label(new_window, text="Modules", height=1, width=10, font=("Arial", 14), bg="#151516", fg="#e90eb9")
        text.place(x = for3x1 + 39, y = for3y - 85)

        #Shariq - Core Skills
        text = tk.Label(new_window, text="Core Skills", height=1, width=10, font=("Arial", 14), bg="#151516", fg="#e90eb9")
        text.place(x = for3x1 + 45, y = for3y + 112)
        
        #Arub - Modules
        text = tk.Label(new_window, text="Modules", height=1, width=10, font=("Arial", 14), bg="#151516", fg="#e90eb9")
        text.place(x = for3x1 + 435, y = for3y - 87)
        
        #Arub - Structure
        text = tk.Label(new_window, text="Structure", height=1, width=10, font=("Arial", 14), bg="#151516", fg="#e90eb9")
        text.place(x = for3x1 + 435, y = for3y - 20)

        #Ahmed - Representation
        text = tk.Label(new_window, text="Representation", height=1, width=15, font=("Arial", 14), bg="#151516", fg="#e90eb9")
        text.place(x = for3x1 + 820, y = for3y - 43)

        #End
        return_button()
    sound()
    credits_inner()

#Window & BG - MAIN PAGE
window = tk.Tk()
window.attributes('-fullscreen', True)
window.configure(bg = 'black')

#Background
background = PhotoImage(file = wallpaper_path)
background_label = tk.Label(window, image = background)
background_label.place(x = -330, y = -300)

#Buttons on Main Page
def main():

    #Buttons Color execution functions
    def docs_enter(nul):
        docs_button.config(bg="#c5861e", width=32, height=3)

    def docs_leave(nul):
        docs_button.config(bg="SystemButtonFace", width=30, height=2)

    def applications_enter(nul):
        applications_button.config(bg="#24ac72", width=32, height=3)

    def applications_leave(nul):
        applications_button.config(bg="SystemButtonFace", width=30, height=2)

    def credits_enter(nul):
        credits_button.config(bg="#992da3", width=32, height=3)

    def credits_leave(nul):
        credits_button.config(bg="SystemButtonFace", width=30, height=2)


    #Docs button
    docs_button = tk.Button(window, text = "Documentation", command = docs, width = 30, height = 2, font = "Consolas", activebackground="pink")
    docs_button.place(x = for3x1, y = for3y)

    #Applications button
    applications_button = tk.Button(window, text = "Applications", command = applications, width = 30, height = 2, font = "Consolas", activebackground="pink")
    applications_button.place(x = for3x2, y = for3y)

    #Credits button
    credits_button = tk.Button(window, text = "Credits", command = credits, width = 30, height = 2, font = "Consolas", activebackground="pink")
    credits_button.place(x = for3x3, y = for3y)

    #Buttons Color execution
    docs_button.bind("<Enter>", docs_enter)
    docs_button.bind("<Leave>", docs_leave)

    applications_button.bind("<Enter>", applications_enter)
    applications_button.bind("<Leave>", applications_leave)

    credits_button.bind("<Enter>", credits_enter)
    credits_button.bind("<Leave>", credits_leave)

    #Exit button
    #Buttons Color execution functions
    def exit_enter(nul):
        exit_button.config(bg="#e05122", width=13, height=1)

    def exit_leave(nul):
        exit_button.config(bg="SystemButtonFace", width=10, height=1)

    #Main exit button
    exit_button = tk.Button(window, text = "Exit", command=window.destroy, activebackground="red", width=7, height=1, font = ("Consolas", 10))
    exit_button.place(x = 1165, y = 660)

    #Buttons Color execution
    exit_button.bind("<Enter>", exit_enter)
    exit_button.bind("<Leave>", exit_leave)

#Run
main()
window.mainloop()</code></pre>
                            <div class="button-container">
                                <button class="see-more-btn" onclick="showModal(this)">
                                    <i class="language-icon more"></i>
                                    See More
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://github.com/arubbinali/github-projects/blob/main/Mathematical%20%26%20Utility%20GUI%20software/MathLab%20GUI.py', '_blank')">
                                    <i class="language-icon github"></i>
                                    GitHub
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://arubbinali.github.io/Projects.html#gui-projects', '_blank')">
                                    <i class="language-icon project"></i>
                                    View Project
                                </button>
                            </div>
                        </div>
                    </div>

                    <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;2,334 lines (1,983 loc)</h5>

                </section>
                </div>

                <!-- MySQL Workbench (Prototype)-->
                <div id="mysql-docs">
                <section class="info-section">
                    <h2 class="project-heading">MySQL Query Executor & Visualizer</h2>
                    <div class="code-snippet">
                        <div class="code-snippet-header">
                            <h5 class="code-snippet-title">
                                <div class="code-language">
                                    <i class="language-icon python"></i>
                                </div>
                                main.py
                            </h5>
                            <button class="code-snippet-toggle">+</button>
                        </div>
    
                        <div class="code-snippet-content">
                            <pre class="code-snippet-code"><code class="language-python">#importing libraries
import tkinter as tk
import customtkinter as ctk

#importing modules
from DMLExecutor import dml
from DQLExecutor import dql
from TableDescription import table

#creating main window
window = ctk.CTk()

#configure window settings & appearance
window.geometry(f"{window.winfo_screenwidth()}x{window.winfo_screenheight()}+0+0")
window.overrideredirect(True)
ctk.set_appearance_mode("dark")

#fixed parameters
exitx, exity = 1491, 0
returnx, returny, return_text = 1360, 740, "Back [Escape]"
firstx, firsty = 400, 100

#colors
title_bar_color = "#1e1f1c"
main_color = "#272822"
button_color = "#313338"
return_color = "#3c3d3a"

#functions  
def showframe(frame):
    for f in [main_frame, dev_tools, dql_executor, dml_executor, table_description]:
        f.place_forget()
    frame.place(relx = 0, rely = 0.08 if frame != navigation_frame else 0, relwidth = 1, relheight = 0.92 if frame != navigation_frame else 0.08)

    global current_frame
    current_frame = frame
    frame.focus_set()
    
def close_window(event = None):
    window.destroy()

def return_main(event = None):
    showframe(main_frame)

def return_dev_tool_frame(event = None):
    showframe(dev_tools)

def handle_escape(event):
    if current_frame == main_frame:
        close_window()
    elif current_frame == dev_tools:
        return_main()
    elif current_frame == dql_executor or dml_executor or table_description:
        return_dev_tool_frame()

#frames
navigation_frame = ctk.CTkFrame(window, fg_color = title_bar_color)
navigation_frame.place(relx = 0, rely = 0, relwidth = 1, relheight = 0.08)

main_frame = ctk.CTkFrame(window, fg_color = main_color)
main_frame.place(relx = 0, rely = 0.08, relwidth = 1, relheight = 0.92)

dev_tools = ctk.CTkFrame(window)
dql_executor = ctk.CTkFrame(window)
dml_executor = ctk.CTkFrame(window)
table_description = ctk.CTkFrame(window)

#buttons
#navigation - main buttons
dev_tool_button = ctk.CTkButton(navigation_frame, text = "Dev tools", command = lambda:showframe(dev_tools), fg_color=button_color, hover_color = return_color)
dev_tool_button.place(x = 500, y = 35)

#navigation - exit button
exit_button = ctk.CTkButton(navigation_frame, text = "â", command = close_window, fg_color = title_bar_color, hover_color = "#FF0000", width = 45, height = 33)
exit_button.place(x = exitx, y = exity)

#dev tools - main buttons
dml_executor_button = ctk.CTkButton(dev_tools, text = "DML Executor", command = lambda:showframe(dml_executor), fg_color=button_color, hover_color = return_color)
dql_executor_button = ctk.CTkButton(dev_tools, text = "DQL Executor", command = lambda:showframe(dql_executor), fg_color=button_color, hover_color = return_color)
table_description_button = ctk.CTkButton(dev_tools, text = "Table Description", command = lambda:showframe(table_description), fg_color=button_color, hover_color = return_color)

dml_executor_button.place(x = firstx, y = firsty)
dql_executor_button.place(x = firstx + 300, y = firsty)
table_description_button.place(x = firstx + 600, y = firsty)

#dev tools - back buttons
back_dev_tool_button = ctk.CTkButton(dev_tools, text = return_text, command = lambda:showframe(main_frame), fg_color=button_color, hover_color = return_color)
back_dql_executor_button = ctk.CTkButton(dql_executor, text = return_text, command = lambda:showframe(dev_tools), fg_color=button_color, hover_color = return_color)
back_dml_exectuor_button = ctk.CTkButton(dml_executor, text = return_text, command = lambda:showframe(dev_tools), fg_color=button_color, hover_color = return_color)
back_table_description_button = ctk.CTkButton(table_description, text = return_text, command = lambda:showframe(dev_tools), fg_color=button_color, hover_color = return_color)

back_dev_tool_button.place(x = returnx, y = returny)
back_dql_executor_button.place(x = returnx, y = returny)
back_dml_exectuor_button.place(x = returnx, y = returny)
back_table_description_button.place(x = returnx, y = returny)

#calling module file
dml(dml_executor)
dql(dql_executor)
table(table_description)

#set current frame
current_frame = main_frame

#key bindings
window.bind('<Escape>', handle_escape)

#run event controller    
window.mainloop()</code></pre>
                            <h5 class="code-snippet-title">&nbsp;</h5>
                            <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;109 lines (85 loc)</h5>
                            <div class="button-container">
                                <button class="see-more-btn" onclick="showModal(this)">
                                    <i class="language-icon more"></i>
                                    See More
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://github.com/arubbinali/github-projects/blob/main/MySQL%20Workbench%20(Prototype)/main.py', '_blank')">
                                    <i class="language-icon github"></i>
                                    GitHub
                                </button>
                            </div>

                        </div>
                    </div>

                    <div class="code-snippet">
                        <div class="code-snippet-header">
                            <h5 class="code-snippet-title">
                                <div class="code-language">
                                    <i class="language-icon python"></i>
                                </div>
                                DQLExecutor.py
                            </h5>
                            <button class="code-snippet-toggle">+</button>
                        </div>
    
                        <div class="code-snippet-content">
                            <pre class="code-snippet-code"><code class="language-python">#importing libraries
import tkinter as tk
import customtkinter as ctk
import mysql.connector as sql

#importing password
from passwords import password as key

def dql(frame):
    
    #fixed parameters
    firstx, firsty = 40, 70
    secondx = 770
    thirdx = 1160
    gap = '*' * 256
    password = key()
    button_color = "#313338"

    #functions
    def run_table(event = None):
        global table
        result_textbox.delete(1.0, tk.END)
        current_query_textbox.delete(1.0, tk.END)
        table = table_in.get()
        try:
            if table:
                show_table(table)
            else:
                result_textbox.insert(tk.END, f"{gap}\nInitialization\n{gap}\n\nError: No table given, enter a table name")
        except:
            result_textbox.insert(tk.END, f"{gap}\nInitialization\n{gap}\n\nError: No database given, enter a database name")
        table_in.delete(0, tk.END)

    def run_query(event = None):
        global query
        result_textbox.delete(1.0, tk.END)
        query = query_in.get().strip()
        if query:
            history_textbox.insert(tk.END, query + "\n")
            output(query)
        else:
            result_textbox.insert(tk.END, f"{gap}\nInitialization\n{gap}\n\nError: No query given, enter a query")
        query_in.delete(0, tk.END)

    def clear_history():
        history_textbox.delete(1.0, tk.END)

    def clear_result():
        result_textbox.delete(1.0, tk.END)
        current_query_textbox.delete(1.0, tk.END)

    def get_prev_query(event = None):
        if not query_in.get():
            index = history_textbox.index("end-1c").split(".")[0]
            query_in.insert(tk.END, history_textbox.get(f"{int(index) - 1}.0", f"{index}.end-1c"))

    def clear_query_in(event = None):
        query_in.delete(0, tk.END)

    def show_current_query(query_status):
        if query_status:
            current_query_textbox.delete(1.0, tk.END)
            current_query_textbox.insert(tk.END, query)
        else:
            current_query_textbox.delete(1.0, tk.END)
            current_query_textbox.insert(tk.END, "Invalid query")

    def get_database(event = None):
        global database
        result_textbox.delete(1.0, tk.END)
        current_query_textbox.delete(1.0, tk.END)
        database = database_in.get()
        if database:
            result_textbox.insert(1.0, f"{gap}\nInitialization\n{gap}\n\nDatabase name entered: {database}")
        else:
            result_textbox.insert(tk.END, f"{gap}\nInitialization\n{gap}\n\nError: No database given, enter a database name")
        database_in.delete(0, tk.END)
        
    def show_table(table):
        try:
            connection = sql.connect(
                host = "localhost",
                user = "root",
                password = password,
                database = database
            )
            
            if connection.is_connected():
                result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\n")
            
            cursor = connection.cursor()
            cursor.execute(f"select * from {table}")

            if cursor.description:
                fields = [field[0] for field in cursor.description]
                result_textbox.insert(tk.END, "\t\t".join(fields) + "\n")
                result_textbox.insert(tk.END, "-" * 448 + "\n")

                for record in cursor.fetchall():
                    record_data = "\t\t".join([str(item) for item in record])
                    result_textbox.insert(tk.END, record_data + "\n")
            else:
                result_textbox.insert(tk.END, f"Query executed successfully: {query}\n")

            cursor.close()
            connection.close()

        except sql.Error as e:
            result_textbox.delete(1.0, tk.END)
            result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\nError: {e}\n")

    def show_databases():
        result_textbox.delete(1.0, tk.END)
        current_query_textbox.delete(1.0, tk.END)
        try:
            connection = sql.connect(
                host = "localhost",
                user = "root",
                password = password,
            )
            
            if connection.is_connected():
                result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\n")
            
            cursor = connection.cursor()

            cursor.execute("show databases")

            if cursor.description:
                fields = [field[0] for field in cursor.description]
                result_textbox.insert(tk.END, "\t\t".join(fields) + "\n")
                result_textbox.insert(tk.END, "-" * 448 + "\n")

                for record in cursor.fetchall():
                    record_data = "\t\t".join([str(item) for item in record])
                    result_textbox.insert(tk.END, record_data + "\n")

            cursor.close()
            connection.close()
        except sql.Error as e:
            result_textbox.delete(1.0, tk.END)
            result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\nError: {e}\n")

    def show_tables():
        result_textbox.delete(1.0, tk.END)
        current_query_textbox.delete(1.0, tk.END)
        try:
            connection = sql.connect(
                host = "localhost",
                user = "root",
                password = password,
            )
            
            if connection.is_connected():
                result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\n")
            
            cursor = connection.cursor()

            try:
                cursor.execute(f"show tables in {database}")
            except:
                result_textbox.insert(tk.END, f"Error: No database selected, enter a database to use first")

            if cursor.description:
                fields = [field[0] for field in cursor.description]
                result_textbox.insert(tk.END, "\t\t".join(fields) + "\n")
                result_textbox.insert(tk.END, "-" * 448 + "\n")

                for record in cursor.fetchall():
                    record_data = "\t\t".join([str(item) for item in record])
                    result_textbox.insert(tk.END, record_data + "\n")

            cursor.close()
            connection.close()
        except sql.Error as e:
            result_textbox.delete(1.0, tk.END)
            result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\nError: {e}\n") 

    def output(query):
        try:
            connection = sql.connect(
                host = "localhost",
                user = "root",
                password = password,
                database = database
            )
            if connection.is_connected():
                result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\n")
            
            cursor = connection.cursor()

            cursor.execute(query)
            operation = query.split()[0]
            if operation.lower() == "delete":
                table = query.split()[2]
                cursor.execute(query)
            elif operation.lower() == "update":
                table = query.split()[1]
                cursor.execute(query)
            else:
                table = query.split()[2][0 : query.split()[2].find("(")]
                cursor.execute(query)

            cursor.execute(f"select * from {table}")

            if cursor.description:
                fields = [field[0] for field in cursor.description]
                result_textbox.insert(tk.END, "\t\t".join(fields) + "\n")
                result_textbox.insert(tk.END, "-" * 448 + "\n")

                for record in cursor.fetchall():
                    record_data = "\t\t".join([str(item) for item in record])
                    result_textbox.insert(tk.END, record_data + "\n")
            else:
                result_textbox.insert(tk.END, f"Query executed successfully: {query}\n")

            cursor.close()
            connection.close()
            valid_query = True
        except sql.Error as e:
            result_textbox.delete(1.0, tk.END)
            result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\nError: {e}\n")
            valid_query = False
        except:
            result_textbox.delete(1.0, tk.END)
            result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\nError: No database given, first enter database to use")
            valid_query = False
        show_current_query(valid_query)

    #title
    dml_title = ctk.CTkLabel(frame, text = "Data Query Language Executor", font = ("Roboto", 24), text_color = "#FFD700")
    dml_title.place(x = 590, y = 20)

    #headings
    history_text = ctk.CTkLabel(frame, text = "Query history")
    history_text.place(x = firstx, y = firsty)
    query_text = ctk.CTkLabel(frame, text = "Enter the table to view\n\n\n\n\n\n\n\n\nEnter an insert, update or delete query", justify = "left")
    query_text.place(x = secondx, y = firsty + 10)
    select_database_text = ctk.CTkLabel(frame, text = "Enter database to use")
    select_database_text.place(x = thirdx, y = firsty + 140)
    current_query_text = ctk.CTkLabel(frame, text = "Current query")
    current_query_text.place(x = thirdx, y = firsty)
    result_text = ctk.CTkLabel(frame, text = "Result")
    result_text.place(x = firstx, y = firsty + 260)

    #output
    history_textbox = ctk.CTkTextbox(frame, width = 680, height = 150, state = tk.NORMAL)
    history_textbox.place(x = firstx, y = firsty + 40)
    result_textbox = ctk.CTkTextbox(frame, width = 1460, height = 350, state = tk.NORMAL)
    result_textbox.place(x = firstx, y = firsty + 300)
    current_query_textbox = ctk.CTkTextbox(frame, width = 340, height = 20, state = tk.NORMAL)
    current_query_textbox.place(x = thirdx, y = firsty + 40)

    #entry
    query_in = ctk.CTkEntry(frame, placeholder_text = "Type in your query here", width = 350)
    query_in.place(x = secondx, y = firsty + 173)
    table_in = ctk.CTkEntry(frame, placeholder_text = "Type in the table name here", width = 350)
    table_in.place(x = secondx, y = firsty + 40)
    database_in = ctk.CTkEntry(frame, placeholder_text = "Type in the database name here", width = 350)
    database_in.place(x = thirdx, y = firsty + 173)

    #buttons
    show_table_button = ctk.CTkButton(frame, text = "Show table [ENTER]", command = run_table, width = 200, fg_color=button_color, hover_color="#494D54")
    show_table_button.place(x = secondx, y = firsty + 78)
    run_query_button = ctk.CTkButton(frame, text = "Run query [ENTER]", command = run_query, width = 200, fg_color=button_color, hover_color="#494D54")
    run_query_button.place(x = secondx, y = firsty + 210)
    clear_history_button = ctk.CTkButton(frame, text = "Clear history", command = clear_history, fg_color=button_color, hover_color="#494D54")
    clear_history_button.place(x = firstx, y = firsty + 210)
    clear_result_button = ctk.CTkButton(frame, text = "Clear result window", command = clear_result, fg_color=button_color, hover_color="#494D54")
    clear_result_button.place(x = firstx, y = firsty + 670)
    show_databases_button = ctk.CTkButton(frame, text = "Show databases", command = show_databases, fg_color=button_color, hover_color="#494D54")
    show_databases_button.place(x = firstx + 150, y = firsty + 670)
    show_tables_button = ctk.CTkButton(frame, text = "Show tables", command = show_tables, fg_color=button_color, hover_color="#494D54")
    show_tables_button.place(x = firstx + 301, y = firsty + 670)
    select_database_button = ctk.CTkButton(frame, text = "Select database", command = get_database, fg_color=button_color, hover_color="#494D54")
    select_database_button.place(x = thirdx, y = firsty + 210)

    #key bindings
    query_in.bind('<Return>', run_query)
    query_in.bind('<Up>', get_prev_query)
    query_in.bind('<Down>', clear_query_in)
    table_in.bind('<Return>', run_table)
    database_in.bind('<Return>', get_database)</code></pre>
                            <h5 class="code-snippet-title">&nbsp;</h5>
                            <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;283 lines (238 loc)</h5>
                            <div class="button-container">
                                <button class="see-more-btn" onclick="showModal(this)">
                                    <i class="language-icon more"></i>
                                    See More
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://github.com/arubbinali/github-projects/blob/main/MySQL%20Workbench%20(Prototype)/DQLExecutor.py', '_blank')">
                                    <i class="language-icon github"></i>
                                    GitHub
                                </button>
                            </div>

                        </div>
                    </div>

                    <div class="code-snippet">
                        <div class="code-snippet-header">
                            <h5 class="code-snippet-title">
                                <div class="code-language">
                                    <i class="language-icon python"></i>
                                </div>
                                DMLExecutor.py
                            </h5>
                            <button class="code-snippet-toggle">+</button>
                        </div>
    
                        <div class="code-snippet-content">
                            <pre class="code-snippet-code"><code class="language-python">#importing libraries
import tkinter as tk
import customtkinter as ctk
import mysql.connector as sql

#importing password
from passwords import password as key

def dml(frame):
    
    #fixed parameters
    firstx, firsty = 40, 70
    secondx = 770
    thirdx = 1160
    gap = '*' * 256
    password = key()
    button_color = "#313338"

    #functions
    def run_query():
        global query
        result_textbox.delete(1.0, tk.END)
        query = query_in.get().strip()
        if query:
            history_textbox.insert(tk.END, query + "\n")
            output(query)
        else:
            result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\nError: No query given, enter a query")
        query_in.delete(0, tk.END)

    def execute(event = None):
        run_query()

    def clear_history():
        history_textbox.delete(1.0, tk.END)

    def clear_result():
        result_textbox.delete(1.0, tk.END)
        current_query_textbox.delete(1.0, tk.END)

    def get_prev_query(event = None):
        if not query_in.get():
            index = history_textbox.index("end-1c").split(".")[0]
            query_in.insert(tk.END, history_textbox.get(f"{int(index) - 1}.0", f"{index}.end-1c"))

    def clear_query_in(event = None):
        query_in.delete(0, tk.END)

    def show_current_query(query_status):
        if query_status:
            current_query_textbox.delete(1.0, tk.END)
            current_query_textbox.insert(tk.END, query)
        else:
            current_query_textbox.delete(1.0, tk.END)
            current_query_textbox.insert(tk.END, "Invalid query")

    def output(query):
        try:
            connection = sql.connect(
                host = "localhost",
                user = "root",
                password = password
            )
            
            if connection.is_connected():
                result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\n")
            
            cursor = connection.cursor()
            cursor.execute(query)

            if cursor.description:
                fields = [field[0] for field in cursor.description]
                result_textbox.insert(tk.END, "\t\t".join(fields) + "\n")
                result_textbox.insert(tk.END, "-" * 448 + "\n")

                for record in cursor.fetchall():
                    record_data = "\t\t".join([str(item) for item in record])
                    result_textbox.insert(tk.END, record_data + "\n")
            else:
                result_textbox.insert(tk.END, f"Query executed successfully: {query}\n")

            cursor.close()
            connection.close()
            valid_query = True
        except sql.Error as e:
            result_textbox.delete(1.0, tk.END)
            result_textbox.insert(tk.END, f"{gap}\nConnected to MySQL Server\n{gap}\n\nError: {e}\n")
            valid_query = False
        show_current_query(valid_query)

    #title
    dml_title = ctk.CTkLabel(frame, text = "Data Manipulation Language Executor", font = ("Roboto", 24), text_color = "#FFD700")
    dml_title.place(x = 580, y = 20)

    #headings
    history_text = ctk.CTkLabel(frame, text = "Query history")
    query_text = ctk.CTkLabel(frame, text = "Enter a select query")
    current_query_text = ctk.CTkLabel(frame, text = "Current query")
    result_text = ctk.CTkLabel(frame, text = "Result")
    
    current_query_text.place(x = thirdx, y = firsty)
    query_text.place(x = secondx, y = firsty)
    history_text.place(x = firstx, y = firsty)
    result_text.place(x = firstx, y = firsty + 260)

    #output
    history_textbox = ctk.CTkTextbox(frame, width = 680, height = 150, state = tk.NORMAL)
    result_textbox = ctk.CTkTextbox(frame, width = 1460, height = 350, state = tk.NORMAL)
    current_query_textbox = ctk.CTkTextbox(frame, width = 340, height = 20, state = tk.NORMAL)
    
    history_textbox.place(x = firstx, y = firsty + 40)
    result_textbox.place(x = firstx, y = firsty + 300)
    current_query_textbox.place(x = thirdx, y = firsty + 50)

    #entry
    query_in = ctk.CTkEntry(frame, placeholder_text = "Type in your query here", width = 350)
    query_in.place(x = secondx, y = firsty + 50)

    #buttons
    run_query_button = ctk.CTkButton(frame, text = "Run query [ENTER]", command = run_query, width = 200, fg_color=button_color, hover_color="#494D54")
    clear_history_button = ctk.CTkButton(frame, text = "Clear history", command = clear_history, fg_color=button_color, hover_color="#494D54")
    clear_result_button = ctk.CTkButton(frame, text = "Clear result window", command = clear_result, fg_color=button_color, hover_color="#494D54")
    
    run_query_button.place(x = secondx, y = firsty + 100)
    clear_history_button.place(x = firstx, y = firsty + 210)
    clear_result_button.place(x = firstx, y = firsty + 670)

    #key bindings
    query_in.bind('<Return>', execute)
    query_in.bind('<Up>', get_prev_query)
    query_in.bind('<Down>', clear_query_in)</code></pre>
                            <h5 class="code-snippet-title">&nbsp;</h5>
                            <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;131 lines (106 loc)</h5>
                            <div class="button-container">
                                <button class="see-more-btn" onclick="showModal(this)">
                                    <i class="language-icon more"></i>
                                    See More
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://github.com/arubbinali/github-projects/blob/main/MySQL%20Workbench%20(Prototype)/DMLExecutor.py', '_blank')">
                                    <i class="language-icon github"></i>
                                    GitHub
                                </button>
                            </div>

                        </div>
                    </div>

                    <div class="code-snippet">
                        <div class="code-snippet-header">
                            <h5 class="code-snippet-title">
                                <div class="code-language">
                                    <i class="language-icon python"></i>
                                </div>
                                TableDescription.py
                            </h5>
                            <button class="code-snippet-toggle">+</button>
                        </div>
    
                        <div class="code-snippet-content">
                            <pre class="code-snippet-code"><code class="language-python">#importing libraries
import tkinter as tk
import customtkinter as ctk
import mysql.connector as sql

#importing password
from passwords import password as key

def table(frame):
    #fixed parameters
    firstx, secondx, thirdx = 50, 400, 770
    firsty, secondy = 80, 275
    password = key()
    run = True
    tables = []

    #functions
    def initialization():
        global run
        current_status.delete(1.0, tk.END)
        try:
            connection = sql.connect(
                host = "localhost",
                user = "root",
                password = password
            )

            if connection.is_connected():
                frame.after(1000, lambda: current_status.insert(tk.END, "Connected to MySQL server"))
                run = True


        except sql.Error as e:
            databases_menu.configure(values = tables)
            error = str(e)
            current_status.delete(1.0, tk.END)
            frame.after(1000, lambda: current_status.insert(tk.END, f"Couldn't connect to MySQL server\n"))
            frame.after(1050, lambda: current_status.insert(tk.END, f"Error: {error}"))
            run = False

        except:
            current_status.delete(1.0, tk.END)
            frame.after(1000, lambda: current_status.insert(tk.END, f"Couldn't connect to MySQL server\n"))
            run = False

    def get_databases():
        databases = []
        if run:
            try:
                connection = sql.connect(
                    host = "localhost",
                    user = "root",
                    password = password
                )

                cursor = connection.cursor()
                cursor.execute("show databases")
                
                for data in cursor.fetchall():
                    database = "\t\t".join([str(item) for item in data])
                    databases.append(database)

                return databases
            
            except sql.Error as e:
                current_status.delete(1.0, tk.END)
                current_status.insert(tk.END, f"Error: {e}")

    def get_tables(get_database):
        global db, tables
        tables = []
        if run and db:
            try:
                connection = sql.connect(
                    host = "localhost",
                    user = "root",
                    password = password,
                    database = get_database
                )

                cursor = connection.cursor()
                cursor.execute(f"show tables")
                for data in cursor.fetchall():
                    table = "\t\t".join([str(item) for item in data])
                    tables.append(table)

                return tables
            
            except sql.Error as e:
                current_status.delete(1.0, tk.END)
                current_status.insert(tk.END, f"Error: {e}")

    def handle_db_selection(selected):
        global selected_db, db
        selected_db = selected.strip()
        db = True
        tables_menu.set("Select a table")
        tables = get_tables(selected_db)
        tables_menu.configure(values = tables)   

    def show_description(table):
        global selected_table, selected_db
        try:
            all = []
            connection = sql.connect(
                host = "localhost",
                user = "root",
                password = password,
                database = selected_db
            )
            
            selected_table = table
            cursor = connection.cursor()
            cursor.execute(f"describe {selected_table}")
    
            if cursor.description:
                table_description.delete(1.0, tk.END)
                fields = [field[0] for field in cursor.description]
                table_description.insert(tk.END, "\t\t\t".join(fields) + "\n")
                table_description.insert(tk.END, "-" * 445 + "\n")

                for data in cursor.fetchall():
                    line = "\t\t\t".join([str(item) for item in data])
                    table_description.insert(tk.END, f"{line}\n")
                    all.append(line)

            show_table(table)
            return tables

        except sql.Error as e:
            current_status.delete(1.0, tk.END)
            current_status.insert(tk.END, f"Er3ror: {e}")

    def show_table(table):
        global selected_db
        try:
            connection = sql.connect(
                host = "localhost",
                user = "root",
                password = password,
                database = selected_db
            )
                
            cursor = connection.cursor()
            cursor.execute(f"select * from {table}")

            if cursor.description:
                table_textbox.delete(1.0, tk.END)
                fields = [field[0] for field in cursor.description]
                table_textbox.insert(tk.END, "\t\t".join(fields) + "\n")
                table_textbox.insert(tk.END, "-" * 445 + "\n")

                for record in cursor.fetchall():
                    record_data = "\t\t".join([str(item) for item in record])
                    table_textbox.insert(tk.END, record_data + "\n")

            cursor.close()
            connection.close()

        except sql.Error as e:
            table_textbox.delete(1.0, tk.END)
            current_status.delete(1.0, tk.END)
            current_status.insert(tk.END, f"Error: {e}")

    def clear():
        table_description.delete(1.0, tk.END)
        table_textbox.delete(1.0, tk.END)
        databases_menu.set("Select a database")
        tables_menu.set("Select a table")
        tables_menu.configure(values = [])

    #title
    dml_title = ctk.CTkLabel(frame, text = "Table schema viewer", font = ("Roboto", 24), text_color = "#FFD700")
    dml_title.place(x = 620, y = 20)

    #headings
    current_status_text = ctk.CTkLabel(frame, text = "Current status")
    table_description_text = ctk.CTkLabel(frame, text = "Table description")
    table_textbox_text = ctk.CTkLabel(frame, text = "Table")

    current_status_text.place(x = thirdx, y = firsty - 10)
    table_description_text.place(x = firstx, y = secondy - 35)
    table_textbox_text.place(x = firstx, y = secondy + 215)

    #output
    current_status = ctk.CTkTextbox(frame, width = 730, height = 100, state = tk.NORMAL)
    table_description = ctk.CTkTextbox(frame, width = 1450, height = 200, state = tk.NORMAL)
    table_textbox = ctk.CTkTextbox(frame, width = 1450, height = 200, state = tk.NORMAL)

    current_status.place(x = thirdx, y = firsty + 25)
    table_description.place(x = 50, y = secondy)
    table_textbox.place(x = 50, y = secondy + 250)

    #drop downs
    databases_menu = ctk.CTkComboBox(frame, width = 300, values = get_databases(), command = handle_db_selection)
    databases_menu.set("Select a database")
    databases_menu.place(x = firstx, y = firsty)

    tables_menu = ctk.CTkComboBox(frame, width = 300, command = lambda selected_table: show_description(selected_table), values = [])
    tables_menu.set("Select a table")
    tables_menu.place(x = secondx, y = firsty)

    #buttons
    clear_button = ctk.CTkButton(frame, text = "Clear", command = clear, fg_color="#313338", hover_color="#494D54")
    clear_button.place(x = firstx, y = secondy + 465)

    #initialize drop downs
    initialization()</code></pre>
                            <h5 class="code-snippet-title">&nbsp;</h5>
                            <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;208 lines (169 loc)</h5>
                            <div class="button-container">
                                <button class="see-more-btn" onclick="showModal(this)">
                                    <i class="language-icon more"></i>
                                    See More
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://github.com/arubbinali/github-projects/blob/main/MySQL%20Workbench%20(Prototype)/TableDescription.py', '_blank')">
                                    <i class="language-icon github"></i>
                                    GitHub
                                </button>
                            </div>

                        </div>
                    </div>

                    <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;731 lines (598 loc)</h5>
                    <button class="see-more-btn" onclick="window.open('https://arubbinali.github.io/Projects.html#mysql-projects', '_blank')">
                        <i class="language-icon project"></i>
                        View Project
                    </button>

                </section>
                </div>
                
            </div>
            
            
            <h2 class="project-heading">Certifications</h2>
            <div class="glow-line"></div>


            <div class="code-snippets-container">
            
            
                <!-- Certifications -->
                <!-- PCAP -->
                <div id="pcap-docs">
                <section class="info-section">
                    <h2 class="project-heading">PCAPâ¢ â Certified Associate Python Programmer</h2>
                    <div class="code-snippet">
                        <div class="code-snippet-header">
                            <h5 class="code-snippet-title">
                                <div class="code-language">
                                    <i class="language-icon python"></i>
                                </div>
                                PCAP.py
                            </h5>
                            <button class="code-snippet-toggle">+</button>
                        </div>
    
                        <div class="code-snippet-content">
                            
                            <pre class="code-snippet-code"><code class="language-python">Ø¨Ø³Ù Ø§ÙÙÙ Ø§ÙØ±Ø­ÙØ§Ù Ø§ÙØ±Ø­ÙÙ


-------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------
                                                    Module 1
-------------------------------------------------------------------------------------------------------------------



1) import <library>, <library>...
        â library.identity()
2) from <library> import *
        â identity() 
        â `from x import y` tries to access y at import time.  `import x .....  def func(): x.y` doesn't access y until the function is run
3) from <library> import <identity>, <identity>...
4) import <library> as <alias>
5) from <library> import <identity> as <alias>, <identity> as <alias>...
6) dir(module)
        â Returns an alphabetically sorted list containing all entities' names available in the module
7) end="\t"
        â tab, moves the cursor (the textual one, like, where text is printed) to the next "tab stop"
8) math functions
        sin(x) â the sine of x
        cos(x) â the cosine of x
        tan(x) â the tangent of x
        asin(x) â the arcsine of x
        acos(x) â the arccosine of x
        atan(x) â the arctangent of x
        pi â a constant with a value that is an approximation of Ï
        radians(x) â a function that converts x from degrees to radians
        degrees(x) â acting in the other direction (from radians to degrees)
        sinh(x) â the hyperbolic sine
        cosh(x) â the hyperbolic cosine
        tanh(x) â the hyperbolic tangent
        asinh(x) â the hyperbolic arcsine
        acosh(x) â the hyperbolic arccosine
        atanh(x) â the hyperbolic arctangent
        e â a constant with a value that is an approximation of Euler's number (e)
        exp(x) â finding the value of e^x
        log(x) â the natural logarithm of x
        log(x, b) â the logarithm of x to base b
        log10(x) â the decimal logarithm of x (more precise than log(x, 10))
        log2(x) â the binary logarithm of x (more precise than log(x, 2))
        pow(x, y) â finding the value of x^y (mind the domains)
        ceil(x) â the ceiling of x (the smallest integer greater than or equal to x)
        floor(x) â the floor of x (the largest integer less than or equal to x)
        trunc(x) â the value of x truncated to an integer (be careful - it's not an equivalent either of ceil or floor)
        factorial(x) â returns x! (x has to be an integral and not a negative)
        hypot(x, y) â returns the length of the hypotenuse of a right-angle triangle with the leg lengths equal to x and y 
            â (the same as sqrt(pow(x, 2) + pow(y, 2)) but more precise)
10) seed() â to fix the random values for each time the program runs
        â seed() - sets the seed with the current time;
        â seed(int_value) - sets the seed with the integer value int_value
11) random module
        range â 0.0 <= random number < 1.0
        range(end)
        range(beg, end)
        range(beg, end, step)
        randrange(end)
        randrange(beg, end)
        randrange(beg, end, step)
        randint(left, right)
        range(end)
        range(beg, end)
        range(beg, end, step)
            â end is not included
12) choice function
        â inputs a sequence and returns a random number from the sequence
        â choice(sequence)
13) sample function
        â inputs a sequence and returns specified number of non repeating random numbers from the sequence
        â sample(sequence, elements_to_choose
14) platform function
        â to access the underlying platform's data, i.e., hardware, operating system, and interpreter version information
        â platform(aliased = False, terse = True) = platform(0, 1)
        â platform()
        â aliased â when set to True (or any non-zero value) it may cause the function to present the alternative underlying layer names instead of the common ones;
        â terse â when set to True (or any non-zero value) it may convince the function to present a briefer form of the result (if possible)
            â machine function
                â to know the generic name of the processor which runs your OS together with Python and your code
                â machine()
            â processor function
                â returns a string filled with the real processor name (if possible)
                â processor()
            â system function
                â returns the generic OS name as a string
                â system()
            â version function
                â returns OS version as a string
                â version()
            â python version function
                â python_implementation() â returns a string denoting the Python implementation
                â python_version_tuple() â returns a three-element tuple filled with:
                    â the major part of Python's version
                    â the minor part
                    â the patch level number
15) Python Module Index
        â https://docs.python.org/3/py-modindex.html
16) Auto generated module variables
        â when you run a file directly, its __name__ variable is set to __main__;
        â when a file is imported as a module, its __name__ variable is set to the file's name (excluding .py)
17) #!/usr/bin/env python3
18) sys library
        â import sys / from sys import path
19) path.append('..\\modules') / path.insert(index, '..\\modules')
20) pip (ON CMD commands)
        pip --version for current pip version
        pip help
            shows brief pip's description
        pip help <package name>
        pip list
            shows list of currently installed packages
        pip search <anystring>
            searches through PyPI directories in order to find packages which name contains <anystring>
        pip show <package name>
        pip install <package name>
            installs <package name> system-wide (expect problems when you don't have administrative rights)
        pip install --user <package name>
            install <package name> for you only; no other your platform's user will be able to use it
        pip install -U <package name>
            updates previously installed package
        pip install <package name> == <package version>
            e.g: pip install pygame == 1.9.2
        pip uninstall package_name
            uninstalls previously installed package


            
--------------------------------------------------------------------------------------------------------------------------
                                                        Module 2
--------------------------------------------------------------------------------------------------------------------------



21) Character sets / encoding schemes
        â ASCII
            â American Standard Code for Information Interchange
            â used mainly to encode the Latin alphabet and some of its derivates
        â Unicode
            â able to encode virtually all alphabets being used by humans
            â UCS-4 & UTF-8            
22) codepoint
        â a number corresponding to a particular character
23) BOM
        â Byte Order Mark, a special combination of bits announcing the encoding used by a file's contents (e.g. UCS-4 or UTF-8)
24) strings
        â len()
            â returns length of a string
        â backslash (\)
            â used as an escape character
            â e.g: print(len('I\'m')) outputs 3
        â multilines
            â a whitespace would add to the length of the string at every new line added
                multiline = '''Line #1
                Line #2'''
        â concatenation
        â replication
        â ord()
            â as in ordinal, to know a specific character's ASCII/UNICODE code point value
            â print(ord('a')) returns 97
        â chr()
            â takes a code point and returns its character
            â print(chr(97)) returns a
        â iteration through a string (using for loop)
        â slices
            â sample code
                
                alpha = "abdefg"

                print(alpha[1:3])   returns bd
                print(alpha[3:])    returns efg
                print(alpha[:3])    returns abd
                print(alpha[3:-2])  returns e
                print(alpha[-3:4])  returns e
                print(alpha[::2])   returns adf
                print(alpha[1::2])  returns beg

        â not
            â returns the inverse of the truth value of the operand it precedes
        â in
            â returns boolean
            â print("a" in "abc") returns TRUE
        â not in
            â returns boolean
            â print("a" not in "abc") returns FALSE
        â del
            â deletes a string or a list or an element from a list
        â min()
            â min("aA") returns A and not a since ASCII of A is 65 and the ASCII of a is 97
            â min([0, 1, 2]) returns 0
        â max()
            â max("aA") returns a and not A since ASCII of a is 97 and the ASCII of A is 65
            â max([0, 1, 2]) returns 2
        â index()
            â method, not a function
            â searches the sequence from the beginning, in order to find the first element of the value specified in its argument
            â its absence will cause a ValueError exception
            â print("abcabc".index("c")) returns 2
        â list()
            â takes its argument (a string) and creates a new list containing all the string's characters, one per list element
            â list("abcabc") returns ['a', 'b', 'c', 'a', 'b', 'c']
        â count()
            â counts all occurrences of the element inside the sequence
            â counts all occurrences of the element inside the sequence
            â print("abcabc".count("x")) returns 0
        â center()
            â adds spaces before and after a string
            â sample code

                print("[" + "house".center(5) + "]") returns [house]
                    â no spaces as house is 5 letters already

                print("[" + "house".center(10) + "]") returns [  house   ]
                    â 5 spaces left as house is 5 letters, 2 and 2 go on both sides, the 1 left over is added to the end (right)
        â startswith()
            â takes a string and returns boolean
            â checks if a given string starts with the specified substring
        â endswith()
            â takes a string and returns boolean
            â checks if a given string ends with the specified substring
        â find()
            â takes a string and returns the index of the string from where the string to find starts
            â returns -1 if a non existent substring is fed as a parameter
        â rfind()
            â starts the search from the end of the string
            â syntax: string.rfind(search_string, start, end)
            â print("Python is awesome, isn't it?".rfind('is'))         returns 7
            â print("Python is awesome, isn't it?".rfind('is', 7, 18))  returns 19
        â isalnum()
            â as in, is a letter number
            â returns boolean
            â returns True if the string fed only contains digits and letters
        â isalpha()
            â returns boolean
            â returns True only if the string fed only contains letters
        â isdigit()
            â returns boolean
            â returns True only if the string fed only contains digits
        â isspace()
            â returns boolean
            â returns True when the string fed only contains whitespaces
        â islower()
            â returns boolean
            â returns True if the string fed only consists of lower case letters
        â isupper()
            â returns boolean
            â returns True if the string fed only consists of lower case letters
        â join()
            â performs a join, expects one argument as a list and all elements must be strings
            â print(",".join(["a", "b", "c"])) returns a,b,c
        â upper()
            â makes a copy of a source string, replaces all lower-case letters with their upper-case counterparts
        â lower()
            â makes a copy of a source string, replaces all upper-case letters with their lower-case counterparts
        â swapcase()
            â makes a new string by swapping the case of all letters within the source string
        â strip()
            â checks if a given string starts with the specified substring
            â combines the effects caused by rstrip() and lstrip()
            â print("[" + "   abcde   ".strip() + "]") returns [abcde]
        â lstrip()
            â returns a newly created string formed from the original one by removing all leading whitespaces
            â print("[" + " abc ".lstrip() + "]") returns [abc ]
            â print("www.cisco.com".lstrip("w.")) returns cisco.com
            â returns the main string if the substring fed is the last part of the main string
        â rstrip()
            â returns a newly created string formed from the original one by removing all whitespaces from the end of the 
            â print("[" + " abc ".rstrip() + "]") returns [ abc]
            â print("[" + "  a b c d e f  ".rstrip("e f") + "]") returns [a b c d]
            â returns the main string if the substring fed is the first part of the main string
        â replace()
            â print("apple juice".replace("apple", "mango")) returns mango juice
            â print("apple apple apple apple juice".replace("apple", "mango", 2)) returns mango mango apple apple juice
        â split()
            â splits the string and builds a list of all detected substrings, assumes that the substrings are delimited by whitespaces
            â print("a       b\nc".split()) returns ['a', 'b', 'c']
        â title()
            â changes every word's first letter to upper-case, turning all other ones to lower-case
        â capatilize()
            â converts the letter at index 0 to upper case and the rest to lower case
        â comparison operators
            â compares code point values, character by character
            â
                ==  â equals to
                !=  â not equals to
                >   â greater than
                >=  â greater than and equals to
                <   â lesser than
                <=  â lesser than and equals to

            â 'beta' > 'Beta' returns True
            â upper-case letters are taken as lesser than lower-case
            â
            
                '10' == '010'   returns False
                '10' > '010'    returns True
                '10' > '8'      returns False
                '20' < '8'      returns True
                '20' < '80'     returns True
                '10' == 10      returns False
                '10' != 10      returns True
                '10' == 1       returns False
                '10' != 1       returns True
                '10' > 10       TypeError exception
                'smith' > 'Smith'   returns True
                    â 's' > 'S' as 115 > 83
                'Smiths' < 'Smith'  returns False
                    â 's' > '' (an empty string, which is considered to have a value less than any character)
                'Smith' > '1000'    returns True
                    â 'S' > '1' as 83 > 49
                '11' < '8'          returns True
                    â '1' < '8' as 49 < 56

        â sorting 
            â to sort elements in a list
            â sort()
                â list.sort()
                â returns a new list
            â sorted()
                â sorted(list)
                â no new list is created
            â str()
                â converts a number to a string
            â int()
                â converts a string to an integer
            â float()
                â converts a string to a decimal point number
25) Projects:
        1) A LED Display
    
            digits = [ '1111110',  	# 0
            '0110000',	# 1
            '1101101',	# 2
            '1111001',	# 3
            '0110011',	# 4
            '1011011',	# 5
            '1011111',	# 6
            '1110000',	# 7
            '1111111',	# 8
            '1111011',	# 9]


            def print_number(num):
                global digits
                digs = str(num)
                lines = [ '' for lin in range(5) ]
                for d in digs:
                    segs = [ [' ',' ',' '] for lin in range(5) ]
                    ptrn = digits[int(d)]
                    if ptrn[0] == '1':
                        segs[0][0] = segs[0][1] = segs[0][2] = '#'
                    if ptrn[1] == '1':
                        segs[0][2] = segs[1][2] = segs[2][2] = '#'
                    if ptrn[2] == '1':
                        segs[2][2] = segs[3][2] = segs[4][2] = '#'
                    if ptrn[3] == '1':
                        segs[4][0] = segs[4][1] = segs[4][2] = '#'
                    if ptrn[4] == '1':
                        segs[2][0] = segs[3][0] = segs[4][0] = '#'
                    if ptrn[5] == '1':
                        segs[0][0] = segs[1][0] = segs[2][0] = '#'
                    if ptrn[6] == '1':
                        segs[2][0] = segs[2][1] = segs[2][2] = '#'
                    for lin in range(5):
                        lines[lin] += ''.join(segs[lin]) + ' '
                for lin in lines:
                    print(lin)


            print_number(int(input("Enter the number you wish to display: ")))

        2) Split function
            
                def mysplit(string):
                    list_form = list(string)
                    if string.isspace() == True or string == "":
                        return []
                    elif list_form[0].isspace() and list_form[-1].isspace():
                        return string.strip()
                    else:
                        out_list = []        
                        temp_string = ""
                        for element in list_form:
                            if not element.isspace():
                                temp_string = temp_string + element
                            if element.isspace():
                                out_list.append(temp_string)
                                temp_string = ""
                        out_list.append(temp_string)
                        return out_list
                    

                print(mysplit("To be or not to be, that is the question"))
                print(mysplit("To be or not to be,that is the question"))
                print(mysplit("   "))
                print(mysplit(" abc "))
            
            3) Encryption

                def encrypt(line, shift):
                    outline = ""
                    for character in line:
                        outcharacter = character
                        if character.isdigit(): outline += character

                        elif character.isalpha():
                            if character.isupper():
                            outcharacter.upper()
                            ascii = ord(outcharacter) + int(shift)
                            if ascii <= 90: outcharacter = chr(ascii)
                            else: outcharacter = chr(ascii - 26)
                            else:
                            outcharacter.lower()
                            ascii = ord(outcharacter) + int(shift)
                            if ascii <= 122: outcharacter = chr(ascii)
                            else: outcharacter = chr(ascii - 26)

                            outline += outcharacter

                        elif character.isspace(): outline += character
                    print(outline)

                line = input("Enter text: ")

                while True:
                    try:
                        shift = int(input("Enter number of shifts: "))
                        if shift in range(1, 26):
                            break
                    except:
                        print("go again")

                encrypt(line, shift)

            4) Palindromes

                def palindrome(line):
                    count = 0
                    length = len(line) - 1
                    lineupper = line.upper()

                    if (length + 1) % 2 == 1:
                        lineodd = lineupper.replace(lineupper[int(length/2)], "")
                        
                    for letter in range(int((length)/2)):
                    if (length + 1) % 2 == 1:
                        if lineodd[letter] == lineodd[-letter - 1]:
                            count += 1
                    else:
                        if lineupper[letter] == lineupper[-letter - 1]:
                            count += 1
                    
                    if count == int((length)/2):
                        print("It's a palindrome")
                    else:
                        print("It's not a palindrome")
                        
                palindrome("Eleven animals I slam in a net")
            
            5) Anagrams

                def anagram(line1, line2):
                    global count
                
                    line1upper = line1.upper()
                    line2upper = line2.upper()
                    
                    for letter in range(len(line1)):
                        if not line1upper[letter].isspace(): list1.append(line1upper[letter])
                        if not line2upper[letter].isspace(): list2.append(line2upper[letter])
                    
                    if not (line1 == "" and line2 == ""):
                            
                    list1.sort()
                    list2.sort()
                    
                    string1 = "".join(list1)
                    string2 = "".join(list2)

                    if string1 == string2:
                        print("Anagrams")
                    else: print("Not anagrams")

                    else: print("Not anagrams")
                        
                count, list1, list2 = 0, [], []
                first = input()
                second = input()
                anagram(first, second)

                OR (solution):
                str_1 = input("Enter the first string: ")
                str_2 = input("Enter the second string: ")

                strx_1 = ''.join(sorted(list(str_1.upper().replace(' ',''))))
                strx_2 = ''.join(sorted(list(str_2.upper().replace(' ',''))))
                if len(strx_1) > 0 and strx_1 == strx_2:
                    print("Anagrams")
                else:
                    print("Not anagrams")


            6) Sum of dates
                
                def lifedigits(date): #YYYYMMDD
    
                    sum, final = 0, 0
                    
                    for _ in range(len(date)):
                    sum +=  int(date[_])
                    
                    if len(str(sum)) < 10:
                    print(sum)
                    else:
                    nsum = str(sum)
                    for _ in range(len(nsum)):
                        final += int(nsum[_])
                    print(final)
                    
                lifedigits(input())

            7) Finding a word in a string
                
                def wordfind(word, line):
                    found, start = True, 0

                    for character in word:
                        
                        pos = line.find(character, start)
                        
                        if pos == -1:
                            found = False
                            break
                        start = pos + 1

                    if found:        print("Yes")
                    else: print("No")

                word = input().lower()
                line = input().lower()

                wordfind(word, line)
                
            8) Sudoku

                def sudoku(datatype):

                    if datatype == "custom":
                    
                        board = [([[] for _ in range(9)]) for x in range(9)]


                        for row in range(3):
                            line = input()
                            for column in range(3):
                                board[row][column] = line[column]
                    
                    if datatype == "grid":
                        #sample board (correct)
                        board = [
                        ['2', '9', '5', '7', '4', '3', '8', '6', '1'],
                        ['4', '3', '1', '8', '6', '5', '9', '2', '7'],
                        ['8', '7', '6', '1', '9', '2', '5', '4', '3'],
                        ['3', '8', '7', '4', '5', '9', '2', '1', '6'],
                        ['6', '1', '2', '3', '8', '7', '4', '9', '5'],
                        ['5', '4', '9', '2', '1', '6', '7', '3', '8'],
                        ['7', '6', '3', '5', '2', '4', '1', '8', '9'],
                        ['9', '2', '8', '6', '7', '1', '3', '5', '4'],
                        ['1', '5', '4', '9', '3', '8', '6', '7', '2']]


                        numbers, blockcount, rowcount, columncount = [1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 0, 0
                        
                        #rows check
                        row1 = board[0]
                        row2 = board[1]
                        row3 = board[2]
                        row4 = board[3]
                        row5 = board[4]
                        row6 = board[5]
                        row7 = board[6]
                        row8 = board[7]
                        row9 = board[8]

                        for x in range(9):
                            if str(numbers[x]) in str(row1):
                                rowcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(row2):
                                rowcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(row3):
                                rowcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(row4):
                                rowcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(row5):
                                rowcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(row6):
                                rowcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(row7):
                                rowcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(row8):
                                rowcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(row9):
                                rowcount += 1

                        #columns check
                        col1, col2, col3, col4, col5, col6, col7, col8, col9 = [], [], [], [], [], [], [], [], []

                        #create columns' lists
                        for _ in range(9):
                            col1.append(board[_][0])

                        for _ in range(9):
                            col2.append(board[_][1])

                        for _ in range(9):
                            col3.append(board[_][2])

                        for _ in range(9):
                            col4.append(board[_][3])

                        for _ in range(9):
                            col5.append(board[_][4])

                        for _ in range(9):
                            col6.append(board[_][5])

                        for _ in range(9):
                            col7.append(board[_][6])

                        for _ in range(9):
                            col8.append(board[_][7])

                        for _ in range(9):
                            col9.append(board[_][8])


                        #check columns
                        for x in range(9):
                            if str(numbers[x]) in str(col1):
                                columncount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(col2):
                                columncount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(col3):
                                columncount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(col4):
                                columncount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(col5):
                                columncount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(col6):
                                columncount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(col7):
                                columncount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(col8):
                                columncount += 1

                        for x in range(9):
                            if str(numbers[x]) in str(col9):
                                columncount += 1


                        #blocks check
                        block1 = board[0][:3],  board[1][:3],   board[2][:3]
                        block2 = board[0][3:6], board[1][3:6],  board[2][3:6]
                        block3 = board[0][6:],  board[1][6:],   board[2][6:]
                        block4 = board[3][:3],  board[4][:3],   board[5][:3]
                        block5 = board[3][3:6], board[4][3:6],  board[5][3:6]
                        block6 = board[3][6:],  board[4][6:],   board[5][6:]
                        block7 = board[6][:3],  board[7][:3],   board[8][:3]
                        block8 = board[6][3:6], board[7][3:6],  board[8][3:6]
                        block9 = board[6][6:],  board[7][6:],   board[8][6:]



                        for x in range(9):
                            if str(numbers[x]) in str((block1)):
                                blockcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str((block2)):
                                blockcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str((block3)):
                                blockcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str((block4)):
                                blockcount += 1
                            
                        for x in range(9):
                            if str(numbers[x]) in str((block5)):
                                blockcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str((block6)):
                                blockcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str((block7)):
                                blockcount += 1

                        for x in range(9):
                            if str(numbers[x]) in str((block8)):
                                blockcount += 1
                            
                        for x in range(9):
                            if str(numbers[x]) in str((block9)):
                                blockcount += 1


                    if rowcount + columncount + blockcount == (9*9*3):
                        print("Yes")
                    else:
                        print("No")

                try:
                    datatype = input("What data do you want to use? Type \"custom\" and hit enter to enter your own sudoku puzzle, or \"grid\" to use an exisent grid:   ")
                    sudoku(datatype)
                except:
                    print("run the program again, either the text or board you entered, was erroneous...")

            OR

                # A function that checks whether a list passed as an argument contains
                # nine digits from '1' to '9'.
                def checkset(digs):
                    return sorted(list(digs)) == [chr(x + ord('0')) for x in range(1, 10)]



                # A list of rows representing the sudoku.
                rows = [ ]
                for r in range(9):
                    ok = False
                    while not ok:
                        row = input("Enter row #" + str(r + 1) + ": ")
                        ok = len(row) == 9 and row.isdigit()
                        if not ok:
                            print("Incorrect row data - 9 digits required")
                    rows.append(row)

                ok = True

                # Check if all rows are good.
                for r in range(9):
                    if not checkset(rows[r]):
                        ok = False
                        break

                # Check if all columns are good.	
                if ok:
                    for c in range(9):
                        col = []
                        for r in range(9):
                            col.append(rows[r][c])
                        if not checkset(col):
                            ok = False
                            break


                # Check if all sub-squares (3x3) are good.
                if ok:
                    for r in range(0, 9, 3):
                        for c in range(0, 9, 3):
                            sqr = ''
                            # Make a string containing all digits from a sub-square.
                            for i in range(3):
                                sqr += rows[r+i][c:c+3]
                            if not checkset(list(sqr)):
                                ok = False
                                break


                # Print the final verdict.
                if ok:
                    print("Yes")
                else:
                    print("No")

26) Execptions:
        ValueError
            raised when a function receives an argument of the correct type but an inappropriate value
            e.g:
                import math
                x = -1
                y = math.sqrt(x)
        ZeroDivisionError
            raised when an attempt is made to divide a number by zero
            e.g:
                value = 1
                value /= 0
        IndexError
            raised when you try to access an index that is out of the range of a sequence (such as a list, tuple, or string)
            e.g:
                my_list = []
                x = my_list[0]

27) Exceptions' mechanism
        1) if an error is encountered inside of the try block, the instructions after the specific line would be ignored:

                try:
                    print("1")
                    x = 1 / 0
                    print("2")
                except:
                    print("Oh dear, something went wrong...")

                print("3")

            output:
                1
                Oh dear, something went wrong...
                3
            
        2) Specifying exceptions
            if the try branch raises the exc1 exception, it will be handled by the except exc1: block;
            similarly, if the try branch raises the exc2 exception, it will be handled by the except exc2: block;
            if the try branch raises any other exception, it will be handled by the unnamed except block:
        
                try:
                    :
                except exc1:
                    :
                except exc2:
                    :
                except:
                    :

                --------------------------------------
                    
                try:
                    x = int(input("Enter a number: "))
                    y = 1 / x
                    print(y)
                except ZeroDivisionError:
                    print("You cannot divide by zero, sorry.")
                except ValueError:
                    print("You must enter an integer value.")
                except:
                    print("Oh dear, something went wrong...")

                print("THE END.")

        3) A drawback of specifying the exception
            e.g:
            
                try:
                    x = int(input("Enter a number: "))
                    y = 1 / x
                    print(y)
                except ValueError:
                    print("You must enter an integer value.")

                print("THE END.")

            the exception raised won't be handled by ValueError - it has nothing to do with it;
            as there's no other branch, you should to see this message:

            Traceback (most recent call last):
            File "exc.py", line 3, in 
            y = 1 / x
            ZeroDivisionError: division by zero

        4) tree-shaped hierarchy of the 63 buuilt in functions python 3 defines

            ZeroDivisionError is a special case of more a general exception class named ArithmeticError;
            ArithmeticError is a special case of a more general exception class named just Exception;
            Exception is a special case of a more general class named BaseException;
            We can describe it in the following way (note the direction of the arrows - they always point to the more general entity):

                BaseException
                    â
                Exception
                    â
                ArithmeticError
                    â
                ZeroDivisionError

        5) the hierarchy, how it functions
            1) e.g:

                    #code 1
                        try:
                            y = 1 / 0
                        except ZeroDivisionError:
                            print("Oooppsss...")

                        print("THE END.")

                    #code 2
                        try:
                            y = 1 / 0
                        except ArithemticError:
                            print("Oooppsss...")

                        print("THE END.")

                    output (both them codes outuput the same result):

                        Oooppsss...
                        THE END.

                to summarize:
                    each exception raised falls into the first matching branch;
                    the matching branch doesn't have to specify the same exception exactly - 
                    it's enough that the exception is more general (more abstract) than the raised one.

            2)e.g:

                #code 1
                    try:
                        y = 1 / 0
                    except ZeroDivisionError:
                        print("Zero Division!")
                    except ArithmeticError:
                        print("Arithmetic problem!")

                    print("THE END.")

                output 1:
                    Zero division!
                    THE END.

                
                #code 2
                    try:
                        y = 1 / 0
                    except ArithmeticError:
                        print("Arithmetic problem!")
                    except ZeroDivisionError:
                        print("Zero Division!")

                    print("THE END.")

                output 2:
                    Arithmetic problem!
                    THE END.
                

            Why, if the exception raised is the same as previously?

            The exception is the same, but the more general exception is now listed first - 
            it will catch all zero divisions too. It also means that there's no chance that any exception hits the ZeroDivisionError branch
            This branch is now completely unreachable

            Remember:

            the order of the branches matters!
            don't put more general exceptions before more concrete ones;
            this will make the latter one unreachable and useless;
            moreover, it will make your code messy and inconsistent;


        6) Handling 2 or more exceptions in one instruction

            try:
                :
            except (exc1, exc2):
                :

        7) Raised exceptions handled inside and outside of functions
            1) exceptions inside of functions
                e.g:

                    def bad_fun(n):
                        try:
                            return 1 / n
                        except ArithmeticError:
                            print("Arithmetic Problem!")
                        return None

                    bad_fun(0)

                    print("THE END.")

                output:
                    Arithmetic problem!
                    THE END.

            2) exceptions outside of functions
                e.g:

                    def bad_fun(n):
                        return 1 / n

                    try:
                        bad_fun(0)
                    except ArithmeticError:
                        print("What happened? An exception was raised!")

                    print("THE END.")

                output:
                    What happened? An exception was raised!
                    THE END.

            the exception raised can cross function and module boundaries, and travel through the invocation chain looking for a 
            matching except clause able to handle it.

            If there is no such clause, the exception remains unhandled, and Python solves the problem in its standard way - 
            by terminating your code and emitting a diagnostic message.

28) raise
        raises the specified exception named exc as if it was raised in a normal (natural) way
        
        The raise instruction may also be utilized in the following way (note the absence of the exception's name):
            raise
        
        There is one serious restriction: 
            this kind of raise instruction may be used inside the except branch only; using it in any other context causes an error.

        The instruction will immediately re-raise the same exception as currently handled.

        e.g:

            code:
                def bad_fun(n):
                    try:
                        return n / 0
                    except:
                        print("I did it again!")
                        raise


                try:
                    bad_fun(0)
                except ArithmeticError:
                    print("I see!")

                print("THE END.")
            
            outputs:

                I did it again!
                I see!
                THE END.

        
        The ZeroDivisionError is raised twice:
            first, inside the try part of the code (this is caused by actual zero division)
            second, inside the except part by the raise instruction.

29) assert
        assert is a statement, tests that a condition is true. If it's false, it raises AssertionError, otherwise nothing happens

        if the condition of the assert is true, the program does nothing on that line and continues running
        only if the assert is false does it raise an exception, which may stop the program if that exception is not caught

        e.g:
            
            import math

            x = int(input("Enter a number: "))
            assert x >= 0
            x = math.sqrt(x)
            print(x)

        output(input: 25):
            5.0
        
        outut(input: -1):
            Traceback (most recent call last):
            File "c:\Users\Micro\Desktop\desk\Code\PCAP\testing.py", line 4, in <module>
                assert x >= 0
                    ^^^^^^
            AssertionError

        e.g:

            def foo(x):
                assert x
                return 1/x


            try:
                print(foo(0))
            except ZeroDivisionError:
                print("zero")
            except:
                print("some")

        output:
            some

        reason:
            assertion error raised since any nunmber != 0 is True and 0 = False, so line 3 is skipped, and since the line's skipped, 
            no ZeroDivisionError either, this leaves us with the except block only since AssertionError isnt specified separately

30) Built-in exceptions
    1) ArithmeticError
        Location: BaseException â Exception â ArithmeticError
        Description: an abstract exception including all exceptions caused by arithmetic operations like zero division 
                        or an argument's invalid domain

    2) AssertionError
        Location: BaseException â Exception â AssertionError
        Description: a concrete exception raised by the assert instruction when its argument evaluates to False, None, 0, or an empty string
        e.g:    

            from math import tan, radians
            angle = int(input('Enter integral angle in degrees: '))

            # We must be sure that angle != 90 + k * 180
            assert angle % 180 != 90
            print(tan(radians(angle)))

    3) BaseException
        Location: BaseException
        Description: the most general (abstract) of all Python exceptions - all other exceptions are included in this one;
                        it can be said that the following two except branches are equivalent: except: and except BaseException:.
    
    4) IndexError
        Location: BaseException â Exception â LookupError â IndexError
        Description: a concrete exception raised when you try to access a non-existent sequence's element (e.g., a list's element)
        e.g:

                # The code shows an extravagant way of leaving the loop.

                the_list = [1, 2, 3, 4, 5]
                ix = 0
                do_it = True

                while do_it:
                    try:
                        print(the_list[ix])
                        ix += 1
                    except IndexError:
                        do_it = False

                print('Done')

    5) KeyboardInterrupt
        Location: BaseException â KeyboardInterrupt
        Description: a concrete exception raised when the user uses a keyboard shortcut designed to terminate a  program's execution 
                        (Ctrl-C in most OSs); if handling this exception doesn't lead to program termination,
                        the program continues its execution.
                        Note: this exception is not derived from the Exception class. Run the program in IDLE.
        e.g:

            # This code cannot be terminated by pressing Ctrl-C.

            from time import sleep

            seconds = 0

            while True:
                try:
                    print(seconds)
                    seconds += 1
                    sleep(1)
                except KeyboardInterrupt:
                    print("Don't do that!")

    6) LookupError
        Location: BaseException â Exception â LookupError
        Description: an abstract exception including all exceptions caused by errors resulting from invalid references to different 
                        collections (lists, dictionaries, tuples, etc.)

    7) MemoryError
        Location: BaseException â Exception â MemoryError
        Description: a concrete exception raised when an operation cannot be completed due to a lack of free memory.
        e.g:

            # This code causes the MemoryError exception.
            # Warning: executing this code may affect your OS.
            # Don't run it in production environments!

            string = 'x'
            try:
                while True:
                    string = string + string
                    print(len(string))
            except MemoryError:
                print('This is not funny!')

    8) OverflowError
        Location: BaseException â Exception â ArithmeticError â OverflowError
        Description: a concrete exception raised when an operation produces a number too big to be successfully stored
        e.g:

            # The code prints subsequent values of exp(k), k = 1, 2, 4, 8, 16, ...

            from math import exp

            ex = 1

            try:
                while True:
                    print(exp(ex))
                    ex *= 2
            except OverflowError:
                print('The number is too big.')

    9) ImportError
        Location: BaseException â Exception â StandardError â ImportError
        Description: a concrete exception raised when an import operation fails
        e.g:

            # One of these imports will fail - which one?

            try:
                import math
                import time
                import abracadabra

            except:
                print('One of your imports has failed.')

    10) KeyError
            Location: BaseException â Exception â LookupError â KeyError
            Description: a concrete exception raised when you try to access a collection's non-existent element (e.g., a dictionary's element)
            e.g:

            # How to abuse the dictionary and how to deal with it?

            dictionary = { 'a': 'b', 'b': 'c', 'c': 'd' }
            ch = 'a'

            try:
                while True:
                    ch = dictionary[ch]
                    print(ch)
            except KeyError:
                print('No such key:', ch)

31) Mini task: Numbers in a range

    def read_int(prompt, min, max):
        run = True
        
        while run:
            try:
                prompt = int(input("Enter a number from -10 to 10: "))
                if min <= prompt <= max:
                        return prompt
                else:
                    print(f"Error: the value is not within permitted range ({min}..{max}) ")
            except ValueError:
                print("Error: wrong input")

    v = read_int("Enter a number from -10 to 10: ", -10, 10)
    print("The number is:", v)

32) Abstract and concrete exceptions
    1) Some abstract built-in Python exceptions are:

        ArithmeticError,
        BaseException,
        LookupError.

    2) Some concrete built-in Python exceptions are:

        AssertionError,
        ImportError,
        IndexError,
        KeyboardInterrupt,
        KeyError,
        MemoryError,
        OverflowError.

33) Exceptions' tree-shaped hierarchy

        BaseException
            Exception
                MemoryError
                AssertionError
                ArithmeticError
                    ZeroDivisionError
                    OverflowError
                LookUpError
                    IndexError
                    KeyError
            StandardError
                ImportError
            KeyboardInterrupt



--------------------------------------------------------------------------------------------------------------------------
                                                        Module 3
--------------------------------------------------------------------------------------------------------------------------



34) Classes & methods
        â A class is an idea (more or less abstract) which can be used to create a number of incarnations,
            such an incarnation is called an object.
        â A class is a set of objects
        â Classes form a hierarchy
        â If we want to hide any of a class's components from the outside world, we should start its name with __.
            Such components are called private.

35) Objects
        â An object is a being belonging to a class
        â An object is an incarnation of the requirements, traits, and qualities assigned to a specific class
        â This may mean that an object belonging to a specific class belongs to all the superclasses at the same time. 
            It may also mean that any object belonging to a superclass may not belong to any of its subclasses
        â Each subclass is more specialized (or more specific) than its superclass. 
            Conversely, each superclass is more general (more abstract) than any of its subclasses.
        â Its 3 group of attributes:
            â a name                                                - a noun
            â a set of individual properties                        - an adjective
            â a set of abilities to perform specific activities     - a verb
        â The part of the Python class responsible for creating new objects is called the constructor,
            and it's implemented as a method of the name __init__.

36) Inheritance
        â Any object bound to a specific level of a class hierarchy inherits all the traits 
            (as well as the requirements and qualities) defined inside any of the superclasses.
        â There's no obstacle to defining new, more precise subclasses. 
            They'll inherit everything from their superclass, so the work that went into its creation isn't wasted.
        â The new class may add new properties and new activities, and therefore may be more useful in specific applications. 
            Obviously, it may be used as a superclass for any number of newly created subclasses.

        â The process doesn't need to have an end. You can create as many classes as you need.
        â The class you define has nothing to do with the object: the existence of a class does not mean that any of the compatible 
            objects will automatically be created. 
        â The class itself isn't able to create an object - you have to create it yourself, and Python allows you to do this.

        â When a class is derived from another class, their relation is named inheritance. 
        â The class which derives from the other class is named a subclass. The second side of this relation is named superclass. 
        â A way to present such a relation is an inheritance diagram, where:
            â superclasses are always presented above their subclasses;
            â relations between classes are shown as arrows directed from the subclass toward its superclass.

37) Encapsulation
        â the ability to hide (protect) selected values against unauthorized access
        â the encapsulated values can be neither accessed nor modified if you want to use them exclusively
        â When any class component has a name starting with two underscores (__), it becomes private - 
            this means that it can be accessed only from within the class.
        â You cannot see it from the outside world. This is how Python implements the encapsulation concept.
    
38) Defining a class and an object

        class TheSimplestClass:
            pass
        
        my_first_object = TheSimplestClass()
        
39) Stacks
        â LIFO
        â An object with 2 elementary operations:
            â push (when a new element is put on the top)
            â pop (when an existing element is taken away from the top)

        â The procedural approach

            code:

                stack = []

                def push(number):
                    stack.append(number)
                def pop():
                    output = stack[-1]
                    del stack[-1]
                    return output

                push(1)
                push(2)
                push(3)

                print(pop())
                print(pop())
                print(pop())

                print(stack)

            output:

                3
                2
                1
                []

        â The object approach
                
            code:

                class Stack():
                    def __init__(self):
                        self.__stack = []

                    def push(self, val):
                        self.__stack.append(val)

                    def pop(self):
                        output = self.__stack[-1]
                        del self.__stack[-1]
                        return output
                    
                    def show(self):
                        print(self.__stack)
                        
                stack_object = Stack()

                stack_object.push(1)
                stack_object.push(2)
                stack_object.push(3)

                print(stack_object.pop())
                print(stack_object.pop())
                print(stack_object.pop())

                stack_object.show()

            output:

                3
                2
                1
                []

40) 2+ objects in a class

    code:

        class Stack:
            def __init__(self):
                self.__stack_list = []

            def push(self, val):
                self.__stack_list.append(val)

            def pop(self):
                val = self.__stack_list[-1]
                del self.__stack_list[-1]
                return val
            
            def show(self):
                print(self.__stack_list)


        stack_object_1 = Stack()
        stack_object_2 = Stack()

        stack_object_1.push(3)
        stack_object_2.push(stack_object_1.pop())

        print(stack_object_2.pop())

        stack_object_1.show()
        stack_object_2.show()

    output:

        3
        []
        []


    code:

        class Stack:
            def __init__(self):
                self.__stack_list = []

            def push(self, val):
                self.__stack_list.append(val)

            def pop(self):
                val = self.__stack_list[-1]
                del self.__stack_list[-1]
                return val
            
            def show(self):
                print(self.__stack_list)


        little_stack = Stack()
        another_stack = Stack()
        funny_stack = Stack()

        little_stack.push(1)
        another_stack.push(little_stack.pop() + 1)
        funny_stack.push(another_stack.pop() - 2)

        print(funny_stack.pop())

        little_stack.show()
        another_stack.show()
        funny_stack.show()


    output:

        0
        []
        []
        []

41) Creating a subclass

        code:

            class Stack:
                def __init__(self):
                    self.__stack_list = []

                def push(self, val):
                    self.__stack_list.append(val)

                def pop(self):
                    val = self.__stack_list[-1]
                    del self.__stack_list[-1]
                    return val


            class AddingStack(Stack):
                def __init__(self):
                    Stack.__init__(self)        # This line ensures the parent class is properly initialized
                    self.__sum = 0

        Contrary to many other languages, Python forces you to explicitly invoke a superclass's constructor. 
        Omitting this point will have harmful effects - the object will be deprived of the __stack_list list. 
        Such a stack will not function properly.

        This is the only time you can invoke any of the available constructors explicitly - it can be done inside the subclass's constructor.

42) Adding 2 methods


        class Stack:
            def __init__(self):
                self.__stackList = []

            def push(self, val):
                self.__stackList.append(val)

            def pop(self):
                val = self.__stackList[-1]
                del self.__stackList[-1]
                return val
            
            def show(self):
                print(self.__stack_list)


        class AddingStack(Stack):
            def __init__(self):
                Stack.__init__(self)            # This line ensures the parent class is properly initialized
                self.__sum = 0

            def push(self, val):
                self.__sum += val
                Stack.push(self, val)

        
    The line Stack.push(self, val) ensures that the push method from the superclass Stack is invoked.
    This preserves the functionality of adding the value to the internal stack list (__stackList) in the superclass,
    while also allowing the subclass AddingStack to add its own additional functionality (such as updating the sum).
        
43) Getting and outputting the sum of the stack

        class Stack:
            def __init__(self):
                self.__stackList = []

            def push(self, val):
                self.__stackList.append(val)

            def pop(self):
                val = self.__stackList[-1]
                del self.__stackList[-1]
                return val
            
            def show(self):
                return self.__stackList


        class AddingStack(Stack):
            def __init__(self):
                Stack.__init__(self)
                self.__sum = 0

            def get_sum(self):
                return self.__sum

            def push(self, val):
                self.__sum += val
                Stack.push(self, val)

            def pop(self):
                val = Stack.pop(self)
                self.__sum -= val
                return val
            

        stack_object = AddingStack()

        for _ in range(5):
            stack_object.push(_)

        print(stack_object.show())
        print(stack_object.get_sum())

        for _ in range(5):
            stack_object.pop()

44) Project: Count the number of elements pushed on and popped from stack (Output 100, count only pop)

        code:

                class Stack:
                    def __init__(self):
                        self.__stk = []

                    def push(self, val):
                        self.__stk.append(val)

                    def pop(self):
                        val = self.__stk[-1]
                        del self.__stk[-1]
                        return val

                class CountingStack(Stack):
                    def __init__(self):
                        Stack.__init__(self)
                        self.__count = 0

                    def get_counter(self):
                        return self.__count

                    def pop(self):
                        self.__count += 1
                        return Stack.pop(self)
                
                stk = CountingStack()
                for i in range(100):
                    stk.push(i)
                    stk.pop()
                print(stk.get_counter())

        output:

            100

45) Project: Create a queue & add validation

        code:

            class QueueError(IndexError):
                pass

            class Queue:
                def __init__(self):
                    self.queue = []

                def put(self, elem):
                    self.queue.insert(0, elem)

                def get(self):
                    if len(self.queue) > 0:
                        val = self.queue[-1]
                        del self.queue[-1]
                        return val
                    else:
                        raise QueueError

            que = Queue()
            que.put(1)
            que.put("dog")
            que.put(False)

            try:
                for i in range(4):
                    print(que.get())
            except:
                print("Queue error")

46) Project: Call a list from the superclass in its subclass

        code:

            class QueueError(IndexError):
                pass

            class Queue:
                def __init__(self):
                    self.queue = []

                def put(self,elem):
                    self.queue.insert(0,elem)

                def get(self):
                    if len(self.queue) > 0:
                        elem = self.queue[-1]
                        del self.queue[-1]
                        return elem
                    else:
                        raise QueueError
                    
            class SuperQueue(Queue):
                def __init__(self):             # This and
                    Queue.__init__(self)        # this line isnt required

                def isempty(self):
                    return len(self.queue) == 0

            que = SuperQueue()
            que.put(1)
            que.put("dog")
            que.put(False)
            for i in range(4):
                if not que.isempty():
                    print(que.get())
                else:
                    print("Queue empty")


        The 2 lines mentioned are not really required since __init__ is automatically inherited from Queue
        This means that when an instance of SuperQueue is created, it will call the __init__ method from Queue,
            initializing self.queue as an empty list.

        Properties and Methods: SuperQueue inherits all the properties and methods of Queue, including put, get, and queue.

        No Need for Redefinition: Redefining the __init__ method in SuperQueue without adding any new functionality is redundant,
            as it simply calls the superclass's __init__ method.

47) Instance variables

        An instance variable is a variable accessible on an instance
            OR:
                An instance variable is a property whose existence depends on the creation of an object. 
                Every object can have a different set of instance variables
        "instance variable" is also known as an attribute
        An instance variable can be private when its name starts with __, but don't forget that such a property
            is still accessible from outside the class using a mangled name constructed as _ClassName__PrivatePropertyName.

        Class variables are shared among all instances of the class. They are defined within the class but outside any instance methods.
        Instance variables are unique to each instance and are typically defined within the __init__ method or elsewhere within the instance.

        The __dict__ attribute of an instance contains only the instance-specific attributes. It does not include class variables.




        code:

            class ExampleClass:
                def __init__(self, val = 1):
                    self.first = val

                def set_second(self, val):
                    self.second = val


            example_object_1 = ExampleClass()
            example_object_2 = ExampleClass(2)

            example_object_2.set_second(3)

            example_object_3 = ExampleClass(4)
            example_object_3.third = 5

            print(example_object_1.__dict__)
            print(example_object_2.__dict__)
            print(example_object_3.__dict__)

        output:

            {'first': 1}
            {'second': 3, 'first': 2}
            {'third': 5, 'first': 4}

        code:

            class Car:

                def __init__(self, make, model, colour):
                    self.make = make
                    self.model = model
                    self.colour = colour


            new_car = Car('Ford', 'Escape', 'Silver')

            print(new_car.__dict__)

        output:

            {'make': 'Ford', 'model': 'Escape', 'colour': 'Silver'}

48) Class variables
        A class variable is a property which exists in exactly one copy and is stored outside any object,
            and doesn't need any created object to be accessible. Such variables are not shown as __dict__ content.
        All a class's class variables are stored inside a dedicated dictionary named __dict__, contained in every class separately.
        
        Class variables are shared among all instances of the class. They are defined within the class but outside any instance methods.
        Instance variables are unique to each instance and are typically defined within the __init__ method or elsewhere within the instance.

        The __dict__ attribute of an instance contains only the instance-specific attributes. It does not include class variables.

        e.g:

            code:

                class ExampleClass:
                    counter = 0
                    def __init__(self, val = 1):
                        self.__first = val
                        ExampleClass.counter += 1


                example_object_1 = ExampleClass()
                example_object_2 = ExampleClass(2)
                example_object_3 = ExampleClass(4)

                print(example_object_1.__dict__, example_object_1.counter)
                print(example_object_2.__dict__, example_object_2.counter)
                print(example_object_3.__dict__, example_object_3.counter)

            output:

                {'_ExampleClass__first': 1} 3
                {'_ExampleClass__first': 2} 3
                {'_ExampleClass__first': 4} 3

        e.g:

            code:

                class ExampleClass:
                    varia = 1
                    def __init__(self, val):
                        ExampleClass.varia = val


                print(ExampleClass.__dict__)
                example_object = ExampleClass(2)

                print(ExampleClass.__dict__)
                print(example_object.__dict__)

            output:

                {'__module__': '__main__', 'varia': 1, '__init__': <function ExampleClass.__init__ at 0x0000028B72D58D60>, '__dict__': <attribute '__dict__' of 'ExampleClass' objects>, '__weakref__': <attribute '__weakref__' of 'ExampleClass' objects>, '__doc__': None}
                {'__module__': '__main__', 'varia': 2, '__init__': <function ExampleClass.__init__ at 0x0000028B72D58D60>, '__dict__': <attribute '__dict__' of 'ExampleClass' objects>, '__weakref__': <attribute '__weakref__' of 'ExampleClass' objects>, '__doc__': None}
                {}

49) Checking an attribute's (instance variable's) existence
        accessing a non-existing object (class) attribute causes an AttributeError exception
        The object created by the constructor can have only one of two possible attributes: a or b

        code:

            class ExampleClass:
                def __init__(self, val):
                    if val % 2 != 0:
                        self.a = 1
                    else:
                        self.b = 1


            example_object = ExampleClass(1)

            print(example_object.a)
            print(example_object.b)

        output:

            1
            Traceback (most recent call last):
            File ".main.py", line 11, in 
                print(example_object.b)
            AttributeError: 'ExampleClass' object has no attribute 'b'

50) hasattr
        checks if any object/class contains a specified property
        expects two arguments to be passed to it:
            the class or the object being checked;
            the name of the property whose existence has to be reported (has to be a string containing the attribute name)
        The function returns True or False
        
        code:

            class ExampleClass:
                def __init__(self, val):
                    if val % 2 != 0:
                        self.a = 1
                    else:
                        self.b = 1


            example_object = ExampleClass(2)
            print(example_object.a)

            if hasattr(example_object, 'b'):
                print(example_object.b)

        output:

            1

            
        the hasattr() function can operate on classes, too. You can use it to find out if a class variable is available
        code:

            class ExampleClass:
                attr = 1

            print(hasattr(ExampleClass, 'attr'))
            print(hasattr(ExampleClass, 'prop'))

        output:

            True
            False
        
        code:

            class ExampleClass:
                a = 1
                def __init__(self):
                    self.b = 2

            example_object = ExampleClass()

            print(hasattr(example_object, 'b'))
            print(hasattr(example_object, 'a'))
            print(hasattr(ExampleClass, 'b'))
            print(hasattr(ExampleClass, 'a'))

        output:

            True
            True
            False
            True

            
        final example:
        code:

            class Sample:
                gamma = 0 # Class variable.
                def __init__(self):
                    self.alpha = 1 # Instance variable.
                    self.__delta = 3 # Private instance variable.


            obj = Sample()
            obj.beta = 2  # Another instance variable (existing only inside the "obj" instance.)
            print(obj.__dict__)

        output:

            {'alpha': 1, '_Sample__delta': 3, 'beta': 2}

51) Methods (basics)
        a function declared/embedded inside the class and able to access all the class's components
        The first (or only) parameter of each method is usually named self, which is designed to identify the object for
            which the method is invoked in order to access the object's properties or invok
        it identifies the object for which the method is invoked.
        If you're going to invoke a method, you mustn't pass the argument for the self parameter - Python will set it for you
        e its methods

        code:

            class Classy:
                def method(self):
                    print("method")

            obj = Classy()
            obj.method()

        output:

            method

        Note the way we've created the object - we've treated the class name like a function, 
        returning a newly instantiated object of the class.

        If you want the method to accept parameters other than self, you should:
            place them after self in the method's definition;
            deliver them during invocation without specifying self (as previously)

        code:

            class Classy:
                def method(self, par):
                    print("method:", par)


            obj = Classy()
            obj.method(1)
            obj.method(2)
            obj.method(3)

        output:

            method: 1
            method: 2
            method: 3

        
        The self parameter is used to obtain access to the object's instance and class variables.

        code:

            class Classy:
                varia = 2
                def method(self):
                    print(self.varia, self.var)


            obj = Classy()
            obj.var = 3
            obj.method()

        output:

            2 3

        code:

            class Classy:
                def other(self):
                    print("other")

                def method(self):
                    print("method")
                    self.other()


            obj = Classy()
            obj.method()

        output:

            method
            other

        If you name a method like this: __init__, it won't be a regular method - it will be a constructor.
        
        The constructor:

            is obliged to have the self parameter (it's set automatically, as usual);
            may (but doesn't need to) have more parameters than just self; if this happens, 
                the way in which the class name is used to create the object must reflect the __init__ definition;
            can be used to set up the object, i.e., properly initialize its internal state,
                create instance variables, instantiate any other objects if their existence is needed, etc.
            if a class contains a constructor (a method named __init__) it cannot return any value and cannot be invoked directly.
            
        code:

            class Classy:
                def __init__(self, value):
                    self.var = value


            obj_1 = Classy("object")

            print(obj_1.var)

        output:

            object

        Note that the constructor:

            cannot return a value, as it is designed to return a newly created object and nothing else;
        
            cannot be invoked directly either from the object or from inside the class
                (you can invoke a constructor from any of the object's subclasses, but we'll discuss this issue later.)

        code:

            class Classy:
                def __init__(self, value = None):
                    self.var = value

            obj_1 = Classy("object")
            obj_2 = Classy()

            print(obj_1.var)
            print(obj_2.var)

        output:

            object
            None

52) Mangling in methods
        property name mangling applies to method names, too - a method whose name starts with __ is (partially) hidden

        code:

            class Classy:
                def visible(self):
                    print("visible")
                def __hidden(self):
                    print("hidden")

            obj = Classy()
            obj.visible()

            try:
                obj.__hidden()
            except:
                print("failed")

            obj._Classy__hidden()

        output:

            visible
            failed
            hidden

        code:

            class Classy:
                varia = 1
                def __init__(self):
                    self.var = 2
                def method(self):
                    pass
                def __hidden(self):
                    pass

            obj = Classy()
            print(obj.__dict__)
            print(Classy.__dict__)

        output:

            {'var': 2}
            {'__module__': '__main__', 'varia': 1, '__init__': <function Classy.__init__ at 0x00000135C8678CC0>, 
            'method': <function Classy.method at 0x00000135C8678D60>, '_Classy__hidden': <function Classy.__hidden at 0x00000135C86FA660>,
            '__dict__': <attribute '__dict__' of 'Classy' objects>, '__weakref__': <attribute '__weakref__' of 'Classy' objects>,
            '__doc__': None}

53) __name__
        a built in property that contains the name of the class
        note: the __name__ attribute is absent from the object - it exists only inside classes.

        code:

            class Classy:
                pass
            print(Classy.__name__)

        output:

            Classy

        note: print(obj.__name__) will cause an error

54) type()
        to find the class of a particular object
        
        code:

            class Classy:
                pass
            obj = Classy()
            print(type(obj).__name__)

        output:

            Classy
    
55) __module__
        it stores the name of the module which contains the definition of the class
        any module named __main__ is actually not a module, but the file currently being run

        code:

            class Classy:
                pass
            print(Classy.__module__)
            obj = Classy()
            print(obj.__module__)

        output:

            __main__
            __main__

56) __bases__
        a tuple containing a class's superclasses
        a tuple that contains classes (not class names) which are direct superclasses for the class
        only classes have this attribute - objects don't
        a class without explicit superclasses points to object (a predefined Python class) as its direct ancestor

        code:
        
            class SuperOne:
                pass


            class SuperTwo:
                pass


            class Sub(SuperOne, SuperTwo):
                pass


            def printBases(cls):
                print('( ', end='')

                for x in cls.__bases__:
                    print(x.__name__, end=' ')

                print(')')

            printBases(SuperOne)
            printBases(SuperTwo)
            printBases(Sub)

        output:

            ( object )
            ( object )
            ( SuperOne SuperTwo )

57) Reflection and introspection
        1) introspection 
            â the ability of a program to examine the type or properties of an object at runtime
        2) reflection
            â which goes a step further, and is the ability of a program to manipulate the values,
                properties and/or functions of an object at runtime.

58) keys()
        a method used with dictionaries to return a view object that displays a list of all the keys in the dictionary
        this view object can be iterated over to access each key individually

59) items()
        this method returns a view object that displays a list of the dictionaryâs key-value tuple pairs

        code:

            my_dict = {"name": "Alice", "age": 30, "city": "New York"}

            items_view = my_dict.items()
            print(items_view)

            my_dict["country"] = "USA"
            print(items_view)

            for key, value in items_view:
                print(f"Key: {key}, Value: {value}")
        
        output:

            dict_items([('name', 'Alice'), ('age', 30), ('city', 'New York')])
            dict_items([('name', 'Alice'), ('age', 30), ('city', 'New York'), ('country', 'USA')])
            Key: name, Value: Alice
            Key: age, Value: 30
            Key: city, Value: New York
            Key: country, Value: USA

60) getattr
        get attribute
        this function is used to retrieve the value of an attribute of an object
        to access an attribute dynamically by name, 
            which is useful when the attribute name is stored in a variable or constructed at runtime

        code:

            class MyClass:
                def __init__(self):
                    self.attribute = "value"

            obj = MyClass()

            # Using getattr to access the 'attribute'
            attr_value = getattr(obj, 'attribute')
            print(attr_value)  # Output: value

            # Using getattr with a non-existent attribute and a default value
            non_existent_attr = getattr(obj, 'non_existent', 'default_value')
            print(non_existent_attr)  # Output: default_value

        output:
        
            value
            default_value

61) setattr
        set attribute
        to set the value of an attribute of an object, dynamically by name

        code:

            class MyClass:
                def __init__(self):
                    self.attribute = "initial value"

            obj = MyClass()

            # Using setattr to set the value of 'attribute'
            setattr(obj, 'attribute', 'new value')
            print(obj.attribute)  # Output: new value

            # Using setattr to create a new attribute
            setattr(obj, 'new_attribute', 'new attribute value')
            print(obj.new_attribute)  # Output: new attribute value

        output:

            new value
            new attribute value

62) isinstance()
        function is used to check if an object is an instance or subclass of a class or a tuple of classe
        returns True if the object is an instance or subclass of the class (or any of the classes in the tuple), and False otherwise
        syntax
            isinstance(object, classinfo)
        
        code:

            # Check if 5 is an instance of int
            print(isinstance(5, int))  # Output: True

            # Check if 'hello' is an instance of str
            print(isinstance('hello', str))  # Output: True

            # Check if 5.0 is an instance of int or float
            print(isinstance(5.0, (int, float)))  # Output: True

            # Custom class example
            class MyClass:
                pass

            obj = MyClass()

            # Check if obj is an instance of MyClass
            print(isinstance(obj, MyClass))  # Output: True

        output:

            True
            True
            True
            True

63) Investigating classes

    code

        class MyClass:
            pass


        obj = MyClass()
        obj.a = 1
        obj.b = 2
        obj.i = 3
        obj.ireal = 3.5
        obj.integer = 4
        obj.z = 5


        def incIntsI(obj):
            for name in obj.__dict__.keys():
                if name.startswith('i'):
                    val = getattr(obj, name)
                    if isinstance(val, int):
                        setattr(obj, name, val + 1)


        print(obj.__dict__)
        incIntsI(obj)
        print(obj.__dict__)

    output:

        {'a': 1, 'integer': 4, 'b': 2, 'i': 3, 'z': 5, 'ireal': 3.5}
        {'a': 1, 'integer': 5, 'b': 2, 'i': 4, 'z': 5, 'ireal': 3.5}

64) examples of predefined properties used in sample programs

        code:

            class Sample:
                def __init__(self):
                    self.name = Sample.__name__
                def myself(self):
                    print("My name is " + self.name + " living in a " + Sample.__module__)


            obj = Sample()
            obj.myself()

        output:

            My name is Sample living in a __main__

        Exercise 1

            The declaration of the Snake class is given below. Enrich the class with a method named increment(),
                adding 1 to the victims property.

            class Snake:
                def __init__(self):
                    self.victims = 0

        Solution 1

            class Snake:
            def __init__(self):
                self.victims = 0

            def increment(self):
                self.victims += 1

        Exercise 2

            Redefine the Snake class constructor so that is has a parameter to initialize the victims field with a value passed to the object during construction.

        Solution 2

            class Snake:
                def __init__(self, victims):
                self.victims = victims

        Exercise 3

            Can you predict the output of the following code?

            class Snake:
                pass

            class Python(Snake):
                pass

            print(Python.__name__, 'is a', Snake.__name__)
            print(Python.__bases__[0].__name__, 'can be a', Python.__name__)

        Solution 3

            Python is a Snake
            Snake can be a Python

65) Project: The timer class

        my code:
    
            class Timer:
                def __init__(self, hours = 0, mins = 0, secs = 0):
                    self.__seconds = (hours * 3600) + (mins * 60) + secs

                def __str__(self):
                    h = self.__seconds // 3600
                    m = (self.__seconds % 3600) // 60
                    s = (self.__seconds % 3600) % 60
                    return f"{h:02}:{m:02}:{s:02}"

                def next_second(self):
                    self.__seconds += 1
                    if self.__seconds == 86400: self.__seconds = 0

                def prev_second(self):
                    self.__seconds -= 1
                    if self.__seconds == -1: self.__seconds += 86400

            timer = Timer(23, 59, 59)
            print(timer)
            timer.next_second()
            print(timer)
            timer.prev_second()
            print(timer)

        their code:

            def two_digits(val):
                s = str(val)
                if len(s) == 1:
                    s = '0' + s
                return s


            class Timer:
                def __init__(self, hours=0, minutes=0, seconds=0):
                    self.__hours = hours
                    self.__minutes = minutes
                    self.__seconds = seconds

                def __str__(self):
                    return two_digits(self.__hours) + ":" + \
                        two_digits(self.__minutes) + ":" + \
                        two_digits(self.__seconds)

                def next_second(self):
                    self.__seconds += 1
                    if self.__seconds > 59:
                        self.__seconds = 0
                        self.__minutes += 1
                        if self.__minutes > 59:
                            self.__minutes = 0
                            self.__hours += 1
                            if self.__hours > 23:
                                self.__hours = 0

                def prev_second(self):
                    self.__seconds -= 1
                    if self.__seconds < 0:
                        self.__seconds = 59
                        self.__minutes -= 1
                        if self.__minutes < 0:
                            self.__minutes = 59
                            self.__hours -= 1
                            if self.__hours < 0:
                                self.__hours = 23


            timer = Timer(23, 59, 59)
            print(timer)
            timer.next_second()
            print(timer)
            timer.prev_second()
            print(timer)

66) Project: Days of the week

        my code:

            class WeekDayError(Exception):
                pass	

            class Weeker:
                def __init__(self, day):
                    self.__week = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
                    if day not in self.__week: raise WeekDayError
                    self.__org_index = self.__week.index(day)
                    self.__dif = 0
                    
                def __str__(self):
                    self.__new_index = (self.__org_index + self.__dif) % 7
                    return self.__week[self.__new_index]

                def add_days(self, n):
                    self.__dif += n

                def subtract_days(self, n):
                    self.__dif -= n

            try:
                weekday = Weeker('Mon')
                print(weekday)
                weekday.add_days(15)
                print(weekday)
                weekday.subtract_days(23)
                print(weekday)
                weekday = Weeker('Monday')
            except WeekDayError:
                print("Sorry, I can't serve your request.")

        their code:

            class WeekDayError(Exception):
                pass

            class Weeker:
                __names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']

                def __init__(self, day):
                    try:
                        self.__current = Weeker.__names.index(day)
                    except ValueError:
                        raise WeekDayError

                def __str__(self):
                    return Weeker.__names[self.__current]

                def add_days(self, n):
                    self.__current = (self.__current + n) % 7

                def subtract_days(self, n):
                    self.__current = (self.__current - n) % 7

            try:
                weekday = Weeker('Mon')
                print(weekday)
                weekday.add_days(15)
                print(weekday)
                weekday.subtract_days(23)
                print(weekday)
                weekday = Weeker('Monday')
            except WeekDayError:
                print("Sorry, I can't serve your request.")

67) Project: Points on a plane

        my code:

            import math

            class Point:
                def __init__(self, x = 0.0, y = 0.0):
                    self.__firstx = x
                    self.__firsty = y
                    
                def getx(self):
                    return abs(self.__firstx - self.__secondx)
                
                def gety(self):
                    return abs(self.__firsty - self.__secondy)
                
                def distance_from_xy(self, x, y):
                    self.__secondx = x
                    self.__secondy = y
                    distance = math.hypot(self.getx(), self.gety())
                    return distance

                def distance_from_point(self, point):
                    self.__secondx = point.__firstx
                    self.__secondy = point.__firsty
                    distance = math.hypot(self.getx(), self.gety())
                    return distance

            point1 = Point(0, 0)
            point2 = Point(1, 1)
            print(point1.distance_from_point(point2))
            print(point2.distance_from_xy(2, 0))

        their code:

            import math

            class Point:
                def __init__(self, x=0.0, y=0.0):
                    self.__x = x
                    self.__y = y

                def getx(self):
                    return self.__x

                def gety(self):
                    return self.__y

                def distance_from_xy(self, x, y):
                    return math.hypot(abs(self.__x - x), abs(self.__y - y))

                def distance_from_point(self, point):
                    return self.distance_from_xy(point.getx(), point.gety())

            point1 = Point(0, 0)
            point2 = Point(1, 1)
            print(point1.distance_from_point(point2))
            print(point2.distance_from_xy(2, 0))

68) Project: Triangle

        my code:

            import math

            class Point:
                def __init__(self, x = 0.0, y = 0.0):
                    self.__firstx = x
                    self.__firsty = y

                def getx(self):
                    return abs(self.__firstx - self.__secondx)

                def gety(self):
                    return abs(self.__firsty - self.__secondy)

                def distance_from_point(self, point):
                    self.__secondx = point.__firstx
                    self.__secondy = point.__firsty
                    distance = math.hypot(self.getx(), self.gety())
                    return distance
                
            class Triangle:
                def __init__(self, vertice1, vertice2, vertice3):
                    self.__first, self.__second, self.__third, = vertice1, vertice2, vertice3

                def perimeter(self):
                    distance1 = Point.distance_from_point(self.__first, self.__second)
                    distance2 = Point.distance_from_point(self.__second, self.__third)
                    distance3 = Point.distance_from_point(self.__first, self.__third)
                    return distance1 + distance2 + distance3

            triangle = Triangle(Point(4, 5), Point(1, 2), Point(5, 7))
            print(triangle.perimeter())

        gpt code:

            import math

            class Point:
                def __init__(self, x=0.0, y=0.0):
                    self.__x = x
                    self.__y = y

                def distance_from_point(self, point):
                    return math.hypot(self.__x - point.__x, self.__y - point.__y)

            class Triangle:
                def __init__(self, vertice1, vertice2, vertice3):
                    self.__vertice1 = vertice1
                    self.__vertice2 = vertice2
                    self.__vertice3 = vertice3

                def perimeter(self):
                    side1 = self.__vertice1.distance_from_point(self.__vertice2)
                    side2 = self.__vertice2.distance_from_point(self.__vertice3)
                    side3 = self.__vertice3.distance_from_point(self.__vertice1)
                    return side1 + side2 + side3

            # Example usage:
            triangle = Triangle(Point(9, 0), Point(3, 1), Point(0, 1))
            print(triangle.perimeter())  # Output should be the perimeter of the triangle

        their code:

            import math

            class Point:
                def __init__(self, x=0.0, y=0.0):
                    self.__x = x
                    self.__y = y

                def getx(self):
                    return self.__x

                def gety(self):
                    return self.__y

                def distance_from_xy(self, x, y):
                    return math.hypot(abs(self.__x - x), abs(self.__y - y))

                def distance_from_point(self, point):
                    return self.distance_from_xy(point.getx(), point.gety())

            class Triangle:
                def __init__(self, vertice1, vertice2, vertice3):
                    self.__vertices = [vertice1, vertice2, vertice3]

                def perimeter(self):
                    per = 0
                    for i in range(3):
                        per += self.__vertices[i].distance_from_point(self.__vertices[(i + 1) % 3])
                    return per

            triangle = Triangle(Point(4, 5), Point(1, 2), Point(5, 7))
            print(triangle.perimeter())

69) __str__()
        a method defined in a class to control how an instance of that class is converted to a string and printed in a human-readable way
        e.g:

            class Star:
                def __init__(self, name, galaxy):
                    self.name = name
                    self.galaxy = galaxy

                def __str__(self):
                    return self.name + ' in ' + self.galaxy


            sun = Star("Sun", "Milky Way")
            print(sun)

        output:

            Sun in Milky Way

70) Inheritance
        passing attributes and methods from the superclass (defined and existing) to a newly created class, called the subclass
        a way of building a new class, not from scratch, but by using an already defined repertoire of traits

71) issubclass()
        issubclass(ClassOne, ClassTwo)
        The function returns True if ClassOne is a subclass of ClassTwo, and False otherwise
        e.g:

            class Vehicle:
                pass

            class LandVehicle(Vehicle):
                pass

            class TrackedVehicle(LandVehicle):
                pass

            for cls1 in [Vehicle, LandVehicle, TrackedVehicle]:
                for cls2 in [Vehicle, LandVehicle, TrackedVehicle]:
                    print(issubclass(cls1, cls2), end="\t")
                print()

        output:

            True	False	False	
            True	True	False	
            True	True	True

        more like:

            â is a subclass of â	Vehicle	    LandVehicle	    TrackedVehicle
            Vehicle	                True	    False	        False
            LandVehicle	            True	    True	        False
            TrackedVehicle	        True	    True	        True

73) isinstance()
        isinstance(objectName, ClassName)
        The functions returns True if the object is an instance of the class, or False otherwise.
        e.g:

            class Vehicle:
                pass

            class LandVehicle(Vehicle):
                pass

            class TrackedVehicle(LandVehicle):
                pass

            my_vehicle = Vehicle()
            my_land_vehicle = LandVehicle()
            my_tracked_vehicle = TrackedVehicle()

            for obj in [my_vehicle, my_land_vehicle, my_tracked_vehicle]:
                for cls in [Vehicle, LandVehicle, TrackedVehicle]:
                    print(isinstance(obj, cls), end="\t")
                print()

        output:

            True	False	False	
            True	True	False	
            True	True	True	

        more like:

            â is an instance of â	Vehicle	    LandVehicle	    TrackedVehicle
            my_vehicle	            True	    False	        False
            my_land_vehicle	        True	    True	        False
            my_tracked_vehicle	    True	    True	        True
            
74) is
        The is operator checks whether two variables (object_one and object_two here) refer to the same object
        e.g:

            class SampleClass:
                def __init__(self, val):
                    self.val = val


            object_1 = SampleClass(0)
            object_2 = SampleClass(2)
            object_3 = object_1
            object_3.val += 1

            print(object_1 is object_2)
            print(object_2 is object_3)
            print(object_3 is object_1)
            print(object_1.val, object_2.val, object_3.val)

            string_1 = "Mary had a little "
            string_2 = "Mary had a little lamb"
            string_1 += "lamb"

            print(string_1 == string_2, string_1 is string_2)

        output:

            False
            False
            True
            1 2 1
            True False
            
        The results prove that object_1 and object_3 are actually the same objects, while string_1 and string_2 aren't,
            despite their contents being the same
            
75) Inhertiting methods
        As there is no __str__() method within the Sub class, the printed string is to be produced within the Super class.
            This means that the __str__() method has been inherited by the Sub class.

        code:

            class Super:
                def __init__(self, name):
                    self.name = name

                def __str__(self):
                    return "My name is " + self.name + "."

            class Sub(Super):
                def __init__(self, name):
                    Super.__init__(self, name)

            obj = Sub("Andy")

            print(obj)

        output:

            My name is Andy.

76) super()
        This function accesses the superclass without needing to know its name        
        The super() function creates a context in which you don't have to (moreover, you mustn't) pass the self argument
            to the method being invoked - this is why it's possible to activate the superclass constructor using only one argument

        Note: you can use this mechanism not only to invoke the superclass constructor,
            but also to get access to any of the resources available inside the superclass

        code:

            class Super:
                def __init__(self, name):
                    self.name = name

                def __str__(self):
                    return "My name is " + self.name + "."


            class Sub(Super):
                def __init__(self, name):
                    super().__init__(name)


            obj = Sub("Andy")

            print(obj)
            
77) Testing properties: class variables & instance variables
    
        code:
            
            # Testing properties: class variables
            class Super:
                supVar = 1

            class Sub(Super):
                subVar = 2

            obj = Sub()

            print(obj.subVar)
            print(obj.supVar)

        output:

            2
            1

        code:

            # Testing properties: instance variables
            class Super:
                def __init__(self):
                    self.supVar = 11


            class Sub(Super):
                def __init__(self):
                    super().__init__()
                    self.subVar = 12


            obj = Sub()

            print(obj.subVar)
            print(obj.supVar)

        output:

            12
            11

        Note: the existence of the supVar variable is obviously conditioned by the Super class constructor invocation.
                Omitting it would result in the absence of the variable in the created object (try it yourself).


        code:

            class Level1:
                variable_1 = 100
                def __init__(self):
                    self.var_1 = 101

                def fun_1(self):
                    return 102


            class Level2(Level1):
                variable_2 = 200
                def __init__(self):
                    super().__init__()
                    self.var_2 = 201
                
                def fun_2(self):
                    return 202


            class Level3(Level2):
                variable_3 = 300
                def __init__(self):
                    super().__init__()
                    self.var_3 = 301

                def fun_3(self):
                    return 302


            obj = Level3()

            print(obj.variable_1, obj.var_1, obj.fun_1())
            print(obj.variable_2, obj.var_2, obj.fun_2())
            print(obj.variable_3, obj.var_3, obj.fun_3())

        output:

            100 101 102
            200 201 202        
            300 301 302
                
78) Multiple inheritance
        Multiple inheritance occurs when a class has more than one superclass.
        Syntactically,such inheritance is presented as a comma-separated list of superclasses put inside parentheses after
            the new class name - just like here:

                class SuperA:
                    var_a = 10
                    def fun_a(self):
                        return 11


                class SuperB:
                    var_b = 20
                    def fun_b(self):
                        return 21


                class Sub(SuperA, SuperB):
                    pass


                obj = Sub()

                print(obj.var_a, obj.fun_a())
                print(obj.var_b, obj.fun_b())

            The Sub class has two superclasses: SuperA and SuperB.
            This means that the Sub class inherits all the goods offered by both SuperA and SuperB.

            The code prints:

                10 11
                20 21
                
79) Overriding
        The entity defined later (in the inheritance sense) overrides the same entity defined earlier
        Python looks for an entity from bottom to top
        code:
        
            class Level1:
                var = 100
                def fun(self):
                    return 101


            class Level2(Level1):
                var = 200
                def fun(self):
                    return 201


            class Level3(Level2):
                pass


            obj = Level3()

            print(obj.var, obj.fun())

        output:

            200 201

            
        code:

            class Left:
                var = "L"
                var_left = "LL"
                def fun(self):
                    return "Left"

            class Right:
                var = "R"
                var_right = "RR"
                def fun(self):
                    return "Right"

            class Sub(Left, Right):
                pass

            obj = Sub()

            print(obj.var, obj.var_left, obj.var_right, obj.fun())

        output:

            L LL RR Left
            
        When obj.var is accessed, Python first looks in the Sub class,
            then in the Left class (because it's the first in the MRO after Sub), and finds var = "L".
        When obj.var_left is accessed, it follows the same MRO and finds var_left = "LL" in the Left class.
        When obj.var_right is accessed, it follows the MRO and finds var_right = "RR" in the Right class.
        When obj.fun() is called, it follows the MRO and finds the fun method in the Left class and returns "Left".

        the methods are not being overwritten, but instance variables

        Methods are not being overwritten because the method resolution order (MRO) dictates which method is found and called first.
        Instance variables (attributes) are found based on the MRO, so if an attribute is not found in the first class in the MRO,
            Python continues to the next class.
        Thus, attributes like var, var_left, and var_right are accessed based on their presence in the classes according to the MRO, 
            while methods are resolved in a similar manner but are not overwritten unless explicitly done so in a subclass.

80) How to build a hierarchy of classes
        code:

            class One:
                def do_it(self):
                    print("do_it from One")

                def doanything(self):
                    self.do_it()

            class Two(One):
                def do_it(self):
                    print("do_it from Two")

            one = One()
            two = Two()

            one.doanything()
            two.doanything()

        output:

            do_it from One
            do_it from Two
        
        The first invocation seems to be simple, and it is simple,
            actually - invoking doanything() from the object named one will obviously activate the first of the methods.

        The second invocation needs some attention. It's simple, too if you keep in mind how Python finds class components.
        The second invocation will launch do_it() in the form existing inside the Two class,
            regardless of the fact that the invocation takes place within the One class.

81) Abstract methods
        an empty method, as it only demonstrates some possibility which will be instantiated later

82) Inheritance: Vehicles example using inheritance
        code:

            import time

            class Vehicle:
                def change_direction(left, on):
                    pass

                def turn(left):
                    change_direction(left, True)
                    time.sleep(0.25)
                    change_direction(left, False)


            class TrackedVehicle(Vehicle):
                def control_track(left, stop):
                    pass

                def change_direction(left, on):
                    control_track(left, on)


            class WheeledVehicle(Vehicle):
                def turn_front_wheels(left, on):
                    pass

                def change_direction(left, on):
                    turn_front_wheels(left, on)

                    
        The most important advantage (omitting readability issues) is that this form of code enables you to implement a brand new turning
            algorithm just by modifying the turn() method, which can be done in just one place, as all the vehicles will obey it.

        This is how polymorphism helps the developer to keep the code clean and consistent.

83) Composition
        process of composing an object using other different objects

        inheritance extends a class's capabilities by adding new components and modifying existing ones;
            in other words, the complete recipe is contained inside the class itself and all its ancestors;
            the object takes all the class's belongings and makes use of them

        composition projects a class as a container able to store and use other objects (derived from other classes)
            where each of the objects implements a part of a desired class's behavior.

84) Inheritance: Vehicles example using composition
        code:

            import time

            class Tracks:
                def change_direction(self, left, on):
                    print("tracks: ", left, on)

            class Wheels:
                def change_direction(self, left, on):
                    print("wheels: ", left, on)

            class Vehicle:
                def __init__(self, controller):
                    self.controller = controller

                def turn(self, left):
                    self.controller.change_direction(left, True)
                    time.sleep(0.25)
                    self.controller.change_direction(left, False)

            wheeled = Vehicle(Wheels())
            tracked = Vehicle(Tracks())

            wheeled.turn(True)
            tracked.turn(False)

        output:

            wheels:  True True
            wheels:  True False
            tracks:  False True
            tracks:  False False
        
        Classes Defined
    
            Tracks Class:
                Defines a Tracks class with a method change_direction(self, left, on) that prints the direction change for tracks.
        
            Wheels Class:
                Defines a Wheels class with a method change_direction(self, left, on) that prints the direction change for wheels.
            
            Vehicle Class:
                Defines a Vehicle class with an __init__ method that initializes with a controller object (either Wheels or Tracks).
                Contains a turn(self, left) method that simulates the vehicle turning left or right:
                    Calls self.controller.change_direction(left, True) to initiate the turn.
                    Pauses execution for 0.25 seconds (time.sleep(0.25)) to simulate the turn.
                    Calls self.controller.change_direction(left, False) to end the turn.

        Initialization and Usage
            Creates instances of Vehicle named wheeled (with Wheels controller) and tracked (with Tracks controller).
            Calls the turn(True) method on the wheeled instance to simulate turning left using wheels.

        Output Explanation
            When wheeled.turn(True) is called:
            It first calls Wheels.change_direction(True, True) to simulate turning left.
            Pauses for 0.25 seconds.
            Then calls Wheels.change_direction(True, False) to stop the turn.

85) What is Method Resolution Order (MRO) and why is it that not all inheritances make sense?
        code:

            class Top:
                def m_top(self):
                    print("top")


            class Middle(Top):
                def m_middle(self):
                    print("middle")


            class Bottom(Middle):
                def m_bottom(self):
                    print("bottom")


            object = Bottom()
            object.m_bottom()
            object.m_middle()
            object.m_top()

        output:

            bottom
            middle
            top

        code:

            class Top:
                def m_top(self):
                    print("top")


            class Middle(Top):
                def m_middle(self):
                    print("middle")


            class Bottom(Middle, Top):
                def m_bottom(self):
                    print("bottom")


            object = Bottom()
            object.m_bottom()
            object.m_middle()
            object.m_top()

        output:

            bottom
            middle
            top

        code:

            class Top:
                def m_top(self):
                    print("top")


            class Middle(Top):
                def m_middle(self):
                    print("middle")


            class Bottom(Top, Middle):
                def m_bottom(self):
                    print("bottom")


            object = Bottom()
            object.m_bottom()
            object.m_middle()
            object.m_top()

        output:

            TypeError: Cannot create a consistent method resolution order (MRO) for bases Top, Middle

        To anticipate your question, weâll say that this amendment has spoiled the code, and it won't run anymore. What a pity.
            The order we tried to force (Top, Middle) is incompatible with the inheritance path which is derived from the code's structure.
            Python won't like it.

        We think that the message speaks for itself. Python's MRO cannot be bent or violated, not just because that's the way Python works,
            but also because it's a rule you have to obey.

86) The diamond problem
        code:

            class Top:
                def m_top(self):
                    print("top")


            class Middle_Left(Top):
                def m_middle(self):
                    print("middle_left")


            class Middle_Right(Top):
                def m_middle(self):
                    print("middle_right")


            class Bottom(Middle_Left, Middle_Right):          #class Bottom(Middle_Right, Middle_Left):          gives the same output
                def m_bottom(self):
                    print("bottom")


            object = Bottom()
            object.m_bottom()
            object.m_middle()
            object.m_top()

        output:

            bottom
            middle_left
            top

        The invocation will activate the m_middle() method, which comes from the Middle_Left class
        The explanation is simple: the class is listed before Middle_Right on the Bottom class's inheritance list

87) else (try except)

        code:

            def reciprocal(n):
                try:
                    n = 1 / n
                except ZeroDivisionError:
                    print("Division failed")
                    return None
                else:
                    print("Everything went fine")
                    return n

            print(reciprocal(2))
            print(reciprocal(0))

        output:

            Everything went fine
            It's time to say good bye
            0.5
            Division failed

88) finally (try except)

        code:

            def reciprocal(n):
                try:
                    n = 1 / n
                except ZeroDivisionError:
                    print("Division failed")
                    n = None
                else:
                    print("Everything went fine")
                finally:
                    print("It's time to say goodbye")
                    return n


            print(reciprocal(2))
            print(reciprocal(0))

        output:

            Everything went fine
            It's time to say good bye
            0.5
            Division failed
            It's time to say good bye
            None

89) Exceptions are classes

        code:

            try:
                i = int("Hello!")
            except Exception as e:
                print(e)
                print(e.__str__())
                print(type(e))
                print(type(e.__str__()))


        output:

            invalid literal for int() with base 10: 'Hello!'
            invalid literal for int() with base 10: 'Hello!'
            <class 'ValueError'>
            <class 'str'>

        Note: the identifier's scope covers its except branch, and doesn't go any further

90) The exception tree

        code:

            def print_exception_tree(thisclass, nest = 0):
                if nest > 1:
                    print("   |" * (nest - 1), end="")
                if nest > 0:
                    print("   +---", end="")

                print(thisclass.__name__)

                for subclass in thisclass.__subclasses__():
                    print_exception_tree(subclass, nest + 1)


            print_exception_tree(BaseException)

        output:

            BaseException
                +---Exception
                |   +---TypeError
                |   +---StopAsyncIteration
                |   +---StopIteration
                |   +---ImportError
                |   |   +---ModuleNotFoundError
                |   |   +---ZipImportError
                |   +---OSError
                |   |   +---ConnectionError
                |   |   |   +---BrokenPipeError
                |   |   |   +---ConnectionAbortedError
                |   |   |   +---ConnectionRefusedError
                |   |   |   +---ConnectionResetError
                |   |   +---BlockingIOError
                |   |   +---ChildProcessError
                |   |   +---FileExistsError
                |   |   +---FileNotFoundError
                |   |   +---IsADirectoryError
                |   |   +---NotADirectoryError
                |   |   +---InterruptedError
                |   |   +---PermissionError
                |   |   +---ProcessLookupError
                |   |   +---TimeoutError
                |   |   +---UnsupportedOperation
                |   |   +---herror
                |   |   +---gaierror
                |   |   +---timeout
                |   |   +---Error
                |   |   |   +---SameFileError
                |   |   +---SpecialFileError
                |   |   +---ExecError
                |   |   +---ReadError
                |   +---EOFError
                |   +---RuntimeError
                |   |   +---RecursionError
                |   |   +---NotImplementedError
                |   |   +---_DeadlockError
                |   |   +---BrokenBarrierError
                |   +---NameError
                |   |   +---UnboundLocalError
                |   +---AttributeError
                |   +---SyntaxError
                |   |   +---IndentationError
                |   |   |   +---TabError
                |   +---LookupError
                |   |   +---IndexError
                |   |   +---KeyError
                |   |   +---CodecRegistryError
                |   +---ValueError
                |   |   +---UnicodeError
                |   |   |   +---UnicodeEncodeError
                |   |   |   +---UnicodeDecodeError
                |   |   |   +---UnicodeTranslateError
                |   |   +---UnsupportedOperation
                |   +---AssertionError
                |   +---ArithmeticError
                |   |   +---FloatingPointError
                |   |   +---OverflowError
                |   |   +---ZeroDivisionError
                |   +---SystemError
                |   |   +---CodecRegistryError
                |   +---ReferenceError
                |   +---BufferError
                |   +---MemoryError
                |   +---Warning
                |   |   +---UserWarning
                |   |   +---DeprecationWarning
                |   |   +---PendingDeprecationWarning
                |   |   +---SyntaxWarning
                |   |   +---RuntimeWarning
                |   |   +---FutureWarning
                |   |   +---ImportWarning
                |   |   +---UnicodeWarning
                |   |   +---BytesWarning
                |   |   +---ResourceWarning
                |   +---error
                |   +---Verbose
                |   +---Error
                |   +---TokenError
                |   +---StopTokenizing
                |   +---Empty
                |   +---Full
                |   +---_OptionError
                |   +---TclError
                |   +---SubprocessError
                |   |   +---CalledProcessError
                |   |   +---TimeoutExpired
                |   +---Error
                |   |   +---NoSectionError
                |   |   +---DuplicateSectionError
                |   |   +---DuplicateOptionError
                |   |   +---NoOptionError
                |   |   +---InterpolationError
                |   |   |   +---InterpolationMissingOptionError
                |   |   |   +---InterpolationSyntaxError
                |   |   |   +---InterpolationDepthError
                |   |   +---ParsingError
                |   |   |   +---MissingSectionHeaderError
                |   +---InvalidConfigType
                |   +---InvalidConfigSet
                |   +---InvalidFgBg
                |   +---InvalidTheme
                |   +---EndOfBlock
                |   +---BdbQuit
                |   +---error
                |   +---_Stop
                |   +---PickleError
                |   |   +---PicklingError
                |   |   +---UnpicklingError
                |   +---_GiveupOnSendfile
                |   +---error
                |   +---LZMAError
                |   +---RegistryError
                |   +---ErrorDuringImport
                +---GeneratorExit
                +---SystemExit
                +---KeyboardInterrupt

                
        - a tree is a perfect example of a recursive data structure
        - the root of Python's exception classes is the BaseException class (it's a superclass of all other exceptions)
        - print its name, taken from the __name__ property;
        - iterate through the list of subclasses delivered by the __subclasses__() method,
            and recursively invoke the print_exception_tree() function, incrementing the nesting level respectively

91) Detailed anatomy of exceptions
        The BaseException class introduces a property named args
        a tuple designed to gather all arguments passed to the class constructor
        we don't count the self argument here

        code:

            def print_args(args):
                lng = len(args)
                if lng == 0:
                    print("")
                elif lng == 1:
                    print(args[0])
                else:
                    print(str(args))


            try:
                raise Exception
            except Exception as e:
                print(e, e.__str__(), sep=' : ' ,end=' : ')
                print_args(e.args)

            try:
                raise Exception("my exception")
            except Exception as e:
                print(e, e.__str__(), sep=' : ', end=' : ')
                print_args(e.args)

            try:
                raise Exception("my", "exception")
            except Exception as e:
                print(e, e.__str__(), sep=' : ', end=' : ')
                print_args(e.args)

        output:

                :  :
            my exception : my exception : my exception
            ('my', 'exception') : ('my', 'exception') : ('my', 'exception')

92) How to create your own exception

        code:

            class MyZeroDivisionError(ZeroDivisionError):	
                pass

            def do_the_division(mine):
                if mine:
                    raise MyZeroDivisionError("1")
                else:		
                    raise ZeroDivisionError("2")

            for mode in [False, True]:
                try:
                    do_the_division(mode)
                except ZeroDivisionError:
                    print('3')

            for mode in [False, True]:
                try:
                    do_the_division(mode)
                except MyZeroDivisionError:
                    print('4')
                except ZeroDivisionError:
                    print('5')

        output:

            3
            3
            5
            4

        We've defined our own exception, named MyZeroDivisionError, derived from the built-in ZeroDivisionError. 
            As you can see, we've decided not to add any new components to the class.

        In effect, an exception of this class can be - depending on the desired point of view
        - treated like a plain ZeroDivisionError, or considered separately.

        The do_the_division() function raises either a MyZeroDivisionError or ZeroDivisionError exception,
            depending on the argument's value.

        The function is invoked four times in total, while the first two invocations are handled using only one
            except branch (the more general one) and the last two ones with two different branches,
            able to distinguish the exceptions (don't forget: the order of the branches makes a fundamental difference!)

        code:

            class PizzaError(Exception):
                def __init__(self, pizza, message):
                    Exception.__init__(self, message)
                    self.pizza = pizza


            class TooMuchCheeseError(PizzaError):
                def __init__(self, pizza, cheese, message):
                    PizzaError.__init__(self, pizza, message)
                    self.cheese = cheese


            def make_pizza(pizza, cheese):
                if pizza not in ['margherita', 'capricciosa', 'calzone']:
                    raise PizzaError(pizza, "no such pizza on the menu")
                if cheese > 100:
                    raise TooMuchCheeseError(pizza, cheese, "too much cheese")
                print("Pizza ready!")

            for (pz, ch) in [('calzone', 0), ('margherita', 110), ('mafia', 20)]:
                try:
                    make_pizza(pz, ch)
                except TooMuchCheeseError as tmce:
                    print(tmce, ':', tmce.cheese)
                except PizzaError as pe:
                    print(pe, ':', pe.pizza)

        output:

            Pizza ready!
            too much cheese : 110
            no such pizza on the menu : mafia

        code:

            class PizzaError(Exception):
                def __init__(self, pizza='Invalid Pizza', message='Error'):
                    Exception.__init__(self, message)
                    self.pizza = pizza


            class TooMuchCheeseError(PizzaError):
                def __init__(self, pizza='uknown', cheese='>100', message='Too much cheese'):
                    PizzaError.__init__(self, pizza, message)
                    self.cheese = cheese


            def make_pizza(pizza, cheese):
                if pizza not in ['margherita', 'capricciosa', 'calzone']:
                    raise PizzaError
                if cheese > 100:
                    raise TooMuchCheeseError
                print("Pizza ready!")


            for (pz, ch) in [('calzone', 0), ('margherita', 110), ('mafia', 20)]:
                try:
                    make_pizza(pz, ch)
                except TooMuchCheeseError as tmce:
                    print(tmce, ':', tmce.cheese)
                except PizzaError as pe:
                    print(pe, ':', pe.pizza)



        output:

            Pizza ready!
            Too much cheese : >100
            Error : Invalid Pizza


                        
--------------------------------------------------------------------------------------------------------------------------
                                                        Module 4
--------------------------------------------------------------------------------------------------------------------------



93) Generators
        A Python generator is a piece of specialized code able to produce a series of values, and to control the iteration process
        A function returns one, well-defined value
        A generator returns a series of values

94) Iterator protocol
        The iterator protocol is a way in which an object should behave to conform to the rules imposed
            by the context of the for and in statements
        An object conforming to the iterator protocol is called an iterator
        
        An iterator must provide two methods:

            __iter__() which should return the object itself and which is invoked once (it's needed for Python to
                successfully start the iteration)
            
            __next__() which is intended to return the next value (first, second, and so on) of the desired series - 
                it will be invoked by the for/in statements in order to pass through the next iteration;
            if there are no more values to provide, the method should raise the StopIteration exception.

        code:

            class Fib:
                def __init__(self, nn):
                    print("__init__")
                    self.__n = nn
                    self.__i = 0
                    self.__p1 = self.__p2 = 1

                def __iter__(self):
                    print("__iter__")
                    return self

                def __next__(self):
                    print("__next__")				
                    self.__i += 1
                    if self.__i > self.__n:
                        raise StopIteration
                    if self.__i in [1, 2]:
                        return 1
                    ret = self.__p1 + self.__p2
                    self.__p1, self.__p2 = self.__p2, ret
                    return ret

            for i in Fib(10):
                print(i)

        output:

            __init__
            __iter__
            __next__
            1
            __next__
            1
            __next__
            2
            __next__
            3
            __next__
            5
            __next__
            8
            __next__
            13
            __next__
            21
            __next__
            34
            __next__
            55
            __next__

        the iterator object is instantiated first;
        next, Python invokes the __iter__ method to get access to the actual iterator;
        the __next__ method is invoked eleven times - the first ten times produce useful values,
            while the eleventh terminates the iteration.

        code:

            class Fib:
                def __init__(self, nn):
                    self.__n = nn
                    self.__i = 0
                    self.__p1 = self.__p2 = 1

                def __iter__(self):
                    print("Fib iter")
                    return self

                def __next__(self):
                    self.__i += 1
                    if self.__i > self.__n:
                        raise StopIteration
                    if self.__i in [1, 2]:
                        return 1
                    ret = self.__p1 + self.__p2
                    self.__p1, self.__p2 = self.__p2, ret
                    return ret

            class Class:
                def __init__(self, n):
                    self.__iter = Fib(n)

                def __iter__(self):
                    print("Class iter")
                    return self.__iter;


            object = Class(8)

            for i in object:
                print(i)

        output:

            Class iter
            1
            1
            2
            3
            5
            8
            13
            21

95) yield
        turns the function into a generator:
            code:

                def fun(n):
                    for i in range(n):
                        return i

            to

                def fun(n):
                    for i in range(n):
                        yield i

96) How to build a generator
        code:

            def fun(n):
                for i in range(n):
                    yield i


            for v in fun(5):
                print(v)

        output:

            0
            1
            2
            3
            4

        A generator to produce the first n powers of 2
        code:

            def powers_of_2(n):
                power = 1
                for i in range(n):
                    yield power
                    power *= 2


            for v in powers_of_2(8):
                print(v)

        output:

            1
            2
            4
            8
            16
            32
            64
            128

97) list() function in generators
        The list() function can transform a series of subsequent generator invocations into a real list:
        code:

            def powers_of_2(n):
                power = 1
                for i in range(n):
                    yield power
                    power *= 2


            t = list(powers_of_2(3))
            print(t)

        output:

            [1, 2, 4]

98) The in operator
        the context created by the in operator allows the use of a generator
        code:

            def powers_of_2(n):
                power = 1
                for i in range(n):
                    yield power
                    power *= 2


            for i in range(20):
                if i in powers_of_2(4):
                    print(i)

        output:

            1
            2
            4
            8

99) Fibonacci number generator
        code:

            def fibonacci(n):
                p = pp = 1
                for i in range(n):
                    if i in [0, 1]:
                        yield 1
                    else:
                        n = p + pp
                        pp, p = p, n
                        yield n

            fibs = list(fibonacci(10))
            print(fibs)

        output:

            [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]


100) List comprehensions
        A list comprehension becomes a generator when used inside parentheses
        code:

            def powers_of_2(n):
                power = 1
                for i in range(n):
                    yield power
                    power *= 2


            t = [x for x in powers_of_2(5)]
            print(t)

        output:

            [1, 2, 4, 8, 16]
            
        code:

            list_1 = []

            for ex in range(6):
                list_1.append(10 ** ex)

            list_2 = [10 ** ex for ex in range(6)]

            print(list_1)
            print(list_2)

        output:

            [1, 10, 100, 1000, 10000, 100000]
            [1, 10, 100, 1000, 10000, 100000]

        code:

            the_list = []

            for x in range(10):
                the_list.append(1 if x % 2 == 0 else 0)

            print(the_list)

        output:

            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]

        code:

            the_list = [1 if x % 2 == 0 else 0 for x in range(10)]
            print(the_list)

        output:

            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]

        code:

            the_list = [1 if x % 2 == 0 else 0 for x in range(10)]
            the_generator = (1 if x % 2 == 0 else 0 for x in range(10))
            print(the_generator, the_list)

            for v in the_list:
                print(v, end=" ")
            print()

            for v in the_generator:
                print(v, end=" ")
            print()

        output:

            <generator object <genexpr> at 0x00000218D5EF97D0> [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
            1 0 1 0 1 0 1 0 1 0 
            1 0 1 0 1 0 1 0 1 0

        It's the parentheses. The brackets make a comprehension, the parentheses make a generator.

        How can you know that the second assignment creates a generator, not a list?
        There is some proof we can show you. Apply the len() function to both these entities.

        len(the_list) will evaluate to 10. Clear and predictable. len(the_generator) will raise an exception, 
            and you will see the following message:
            TypeError: object of type 'generator' has no len()

        code:

            for v in [1 if x % 2 == 0 else 0 for x in range(10)]:
                print(v, end=" ")
            print()

            for v in (1 if x % 2 == 0 else 0 for x in range(10)):
                print(v, end=" ")
            print()

        output:

            1 0 1 0 1 0 1 0 1 0 
            1 0 1 0 1 0 1 0 1 0
            
        Note: the same appearance of the output doesn't mean that both loops work in the same way.
        In the first loop, the list is created (and iterated through) as a whole - it actually exists when the loop is being executed.
        In the second loop, there is no list at all - there are only subsequent values produced by the generator, one by one.

101) lambda
        A lambda function is a function without a name (you can also call it an anonymous function)
            lambda parameters: expression
        such a clause returns the value of the expression when taking into account the current value of the current lambda argument
        returns the value of the expression when taking into account the current value of the current lambda argument

        code:

            two = lambda: 2
            sqr = lambda x: x * x
            pwr = lambda x, y: x ** y

            for a in range(-2, 3):
                print(sqr(a), end=" ")
                print(pwr(a, two()))

        output:

            4 4
            1 1
            0 0
            1 1
            4 4

        code:

            def print_function(args, fun):
                for x in args:
                    print('f(', x,')=', fun(x), sep='')

            def poly(x):
                return 2 * x**2 - 4 * x + 2

            print_function([x for x in range(-2, 3)], poly)

        output:

            f(-2)=18
            f(-1)=8
            f(0)=2
            f(1)=0
            f(2)=2

        code:

            def print_function(args, fun):
                for x in args:
                    print('f(', x,')=', fun(x), sep='')

            print_function([x for x in range(-2, 3)], lambda x: 2 * x**2 - 4 * x + 2)

        output:

            f(-2)=18
            f(-1)=8
            f(0)=2
            f(1)=0
            f(2)=2

102) map()
        map(function, list)
        applies the function passed by its first argument to all its second argument's elements,
            and returns an iterator delivering all subsequent function results.
            use the resulting iterator in a loop, or convert it into a list using the list() function
        can accept more than 2 arguments

        code:

            def a(c):
                return c * 10
            b = [x for x in range(10)]

            print(list(map(a, b)))

        output:

            [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]

        code:

            print(list(map(lambda a: a * 10, [x for x in range(10)])))

        output:

            [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]

        code:

            list_1 = [x for x in range(5)]
            list_2 = list(map(lambda x: 2 ** x, list_1))
            print(list_2)

            for x in map(lambda x: x * x, list_2):
                print(x, end=' ')
            print()

        output:

            [1, 2, 4, 8, 16]
            1 4 16 64 256

103) filter()
        filters its second argument while being guided by directions flowing from the function specified as the first argument
        the elements which return True from the function pass the filter - the others are rejected
        returns an iterator
        
        code:

            from random import seed, randint

            seed()
            data = [randint(-10,10) for x in range(5)]
            filtered = list(filter(lambda x: x > 0 and x % 2 == 0, data))

            print(data)
            print(filtered)

        output:

            [6, 3, 3, 2, -7]
            [6, 2]

104) closures
        closure is a technique which allows the storing of values in spite of the fact that the context in which
            they have been created does not exist anymore
            a function that captures the local variables from its enclosing scope. This means that even after the outer 
            function has finished executing, the inner function retains access to the variables and parameters of the outer function
        code:

            def outer(par):
                loc = par

                def inner():
                    return loc
                return inner


            var = 1
            fun = outer(var)
            print(fun())

        output:

            1

        A closure has to be invoked in exactly the same way in which it has been declared

        code:

            def make_closure(par):
                loc = par

                def power(p):
                    return p ** loc
                return power


            fsqr = make_closure(2)
            fcub = make_closure(3)

            for i in range(5):
                print(i, fsqr(i), fcub(i))

        output:

            0 0 0
            1 1 1
            2 4 8
            3 9 27
            4 16 64

        You can create as many closures as you want using one and the same piece of code
        This is done with a function named make_closure()

105) Streams
        an abstraction used to read from or write to files.
        streams represent the flow of data to or from a storage medium, such as a file on disk
        The opening of the stream is not only associated with the file, 
            but should also declare the manner in which the stream will be processed. This declaration is called an open mode
        If the opening is successful, 
            the program will be allowed to perform only the operations which are consistent with the declared open mode

        There are two basic operations performed on the stream:

            read from the stream: the portions of the data are retrieved from the file and placed in a memory area 
                managed by the program (e.g., a variable);
            write to the stream: the portions of the data from the memory (e.g., a variable) are transferred to the file.

        3 basic modes:

            read
                read operations only
                trying to write to the stream will cause UnsupportedOperation, which inherits OSError and ValueError, from the io module
            write
                write operations only
                attempting to read the stream will cause the exception mentioned above
            update
                both

106) File handles
        Python assumes that every file is hidden behind an object of an adequate class
        An object of an adequate class is created when you open the file and annihilate it at the time of closing
        The operations you're allowed to use are imposed by the way in which you've opened the file

                    IOBase
                    /    |      \
                /     |       \
                /      |        \
                /       |         \
        RawIOBase BufferedIOBase TextIOBase

        you never use constructors to bring these objects to life. The only way you obtain them is to invoke the function named open()
        the function analyses the arguments you've provided, and automatically creates the required object
        
        if you want to get rid of the object, you invoke the method named close()
        the invocation will sever the connection to the object, and the file and will remove the object

        the end of line is marked by a pair of characters, CR and LF (ASCII codes 13 and 10) which can be encoded as \r\n

        portability
            If you create a program responsible for processing a text file, and it is written for Windows, you can recognize the 
                ends of the lines by finding the \r\n characters, but the same program running in a Unix/Linux environment will be 
                completely useless, and vice versa: the program written for Unix/Linux systems might be useless in Windows.

            Such undesirable features of the program, which prevent or hinder the use of the program in different environments, 
                are called non-portability.

            Similarly, the trait of the program allowing execution in different environments is called portability.
                A program endowed with such a trait is called a portable program.

        when the stream is open & advised that the data in the associated file will be processed as text, it is switched into text mode

        during reading/writing of lines from/to the associated file, a translation of newline characters occurs:
            during read operations, every pair of \r\n characters is replaced with a single \n character
            during write operations, every \n character is replaced with a pair of \r\n characters
    
107) Opening the streams & selecting text and binary modes
        stream = open(file, mode = 'r', encoding = None)
        FileNotFoundError if the file you're going to read doesn't exist
        The default opening mode is reading in text mode, while the default encoding depends on the platform used
        
        Opening the streams: modes
            r   read mode
                file associated with the stream must exist and has to be readable, othwewise open() raises an exception
            w   write mode
                file associated with the stream doesn't need to exist, will be created if it doesnt exist,
                will be tranculated to length 0 if exists (will be erased), otherwise open() raises an exception if creation impossible
            a   append mode
                file associated with the stream doesn't need to exist, will be created if it doesnt exist,
                if exists, virtual recording head will be set at the end of the file (previous content of the file remains untouched)
            r+  read and update mode
                file associated with the stream must exist and has to be writeable, othwewise open() raises an exception
                both read and write operations are allowed for the stream
            w+  write and update mode
                file associated with the stream doesn't need to exist, will be created if it doesnt exist, 
                previous content of the file remains untouched
                both read and write operations are allowed for the stream
                
        Selecting text and binary modes
            if b at the end of a stream mode, the stream is to be opened in the binary mode
            if the mode string ends with a letter t the stream is opened in the text mode
            Text mode is the default behaviour assumed when no binary/text mode specifier is used
                the successful opening of the file will set the current file position (the virtual reading/writing head) before the
                first byte of the file if the mode is not a and after the last byte of file if the mode is set to a

            Text        mode    	Binary mode	Description
            rt	        rb	            read
            wt	        wb          	write
            at	        ab	            append
            r+t	        r+b	            read and update
            w+t	        w+b         	write and update

            extra
                You can also open a file for its exclusive creation. You can do this using the x open mode.
                    If the file already exists, the open() function will raise an exception

108) Opening the stream for the first time
        code:

            try:
                stream = open("C:\\Users\\Micro\\Desktop\\desk\Code\\PCAP\\file.txt", "rt")
                # Processing goes here.
                stream.close()
            except Exception as exc:
                print("Cannot open the file:", exc)

109) Pre-opened streams
        import sys

        sys.stdin
            stdin (as standard input)
            the stdin stream is normally associated with the keyboard, 
                pre-open for reading and regarded as the primary data source for the running programs;
            the well-known input() function reads data from stdin by default.

        sys.stdout
            stdout (as standard output)
            the stdout stream is normally associated with the screen,
                pre-open for writing, regarded as the primary target for outputting data by the running program;
            the well-known print() function outputs the data to the stdout stream
        
        sys.stderr
            stderr (as standard error output)
            the stderr stream is normally associated with the screen, pre-open for writing,
                regarded as the primary place where the running program should send information on the errors encountered during its work
            the separation of stdout (useful results produced by the program) from the stderr (error messages, undeniably useful but does
                not provide results) gives the possibility of redirecting these two types of information to the different targets

110) Closing streams
        stream.close()
        the function returns nothing but raises IOError exception in case of error

111) Diagnosing stream problems
        The IOError object is equipped with a property named errno (the name comes from the phrase error number)
            and you can access it as follows:
            
            code:

                try:
                    # Some stream operations.
                except IOError as exc:
                    print(exc.errno)

        errno.EACCES â Permission denied
            The error occurs when you try, for example, to open a file with the read only attribute for writing.
        errno.EBADF â Bad file number
            The error occurs when you try, for example, to operate with an unopened stream.
        errno.EEXIST â File exists
            The error occurs when you try, for example, to rename a file with its previous name.
        errno.EFBIG â File too large
            The error occurs when you try to create a file that is larger than the maximum allowed by the operating system.
        errno.EISDIR â Is a directory
            The error occurs when you try to treat a directory name as the name of an ordinary file.
        errno.EMFILE â Too many open files
            The error occurs when you try to simultaneously open more streams than acceptable for your operating system.
        errno.ENOENT â No such file or directory
            The error occurs when you try to access a non-existent file/directory.
        errno.ENOSPC â No space left on device
            The error occurs when there is no free space on the media    

        code:
            
                import errno

                try:
                    s = open("C:\\Users\\Micro\\Desktop\\desk\Code\\PCAP\\file.txt", "rt")
                    # Actual processing goes here.
                    s.close()
                except Exception as exc:
                    if exc.errno == errno.ENOENT:
                        print("The file doesn't exist.")
                    elif exc.errno == errno.EMFILE:
                        print("You've opened too many files.")
                    else:
                        print("The error number is:", exc.errno)

112) strerror()
        comes from the os module and expects just one argument - an error number
        give an error number and get a string describing the meaning of the error
        if you pass a non-existent error code, the function will raise ValueError exception

        code:

            from os import strerror

            try:
                s = open("C:\\Users\\Micro\\Desktop\\desk\Code\\PCAP\\file.txt", "rt")
                # Actual processing goes here.
                s.close()
            except Exception as exc:
                print("The file could not be opened:", strerror(exc.errno))

113) Processing text files
        encoding = ""
            If your text files contain some national characters not covered by the standard ASCII charset,
                you may need an additional step. Your open() function invocation may require an argument denoting specific text encoding.
            For example, if you're using a Unix/Linux OS configured to use UTF-8 as a system-wide setting,
                the open() function may look as follows:

                code:

                    stream = open('file.txt', 'rt', encoding='utf-8')

            code:

            # Opening tzop.txt in read mode, returning it as a file object:
            stream = open("tzop.txt", "rt", encoding = "utf-8")
            print(stream.read()) # printing the content of the file
        
114) read()
        read a desired number of characters (including just one) from the file, and return them as a string
        read all the file contents, and return them as a string
        if there is nothing more to read (the virtual reading head reaches the end of the file), the function returns an empty string

        code:

            from os import strerror

            try:
                cnt = 0
                s = open('C:\\Users\\Micro\\Desktop\\desk\Code\\PCAP\\file.txt', "rt")
                ch = s.read(1)
                while ch != '':
                    print(ch, end='')
                    cnt += 1
                    ch = s.read(1)
                s.close()
                print("\n\nCharacters in file:", cnt)
            except IOError as e:
                print("I/O error occurred: ", strerror(e.errno))

        output:

            Beautiful is better than ugly.
            Explicit is better than implicit.
            Simple is better than complex.
            Complex is better than complicated.

            Characters in file: 131

        code:

            from os import strerror

            try:
                cnt = 0
                s = open('text.txt', "rt")
                content = s.read()
                for ch in content:
                    print(ch, end='')
                    cnt += 1
                s.close()
                print("\n\nCharacters in file:", cnt)
            except IOError as e:
                print("I/O error occurred: ", strerr(e.errno))

        output:

            Beautiful is better than ugly.
            Explicit is better than implicit.
            Simple is better than complex.
            Complex is better than complicated.

            Characters in file: 131

115) readline()
        treats the file's contents as a set of lines instead of a set of characters
        the method tries to read a complete line of text from the file, and returns it as a string in the case of success.
            otherwise, it returns an empty string

        code:

            from os import strerror

            try:
                ccnt = lcnt = 0
                s = open('C:\\Users\\Micro\\Desktop\\desk\Code\\PCAP\\file.txt', 'rt')
                line = s.readline()
                while line != '':
                    lcnt += 1
                    for ch in line:
                        print(ch, end='')
                        ccnt += 1
                    line = s.readline()
                s.close()
                print("\n\nCharacters in file:", ccnt)
                print("Lines in file:     ", lcnt)
            except IOError as e:
                print("I/O error occurred:", strerror(e.errno))

        output:

            Beautiful is better than ugly.
            Explicit is better than implicit.
            Simple is better than complex.
            Complex is better than complicated.

            Characters in file: 131
            Lines in file:      4
                        
116) readlines()
        treats the file's contents as a set of lines instead of a set of characters
        when invoked without arguments, tries to read all the file contents, and returns a list of strings, one element per file line

        code:

            from os import strerror
            name = "C:\\Users\\Micro\\Desktop\\desk\Code\\PCAP\\file.txt"

            try:
                ccnt = lcnt = 0
                s = open(name, 'rt')
                lines = s.readlines(20)
                while len(lines) != 0:
                    for line in lines:
                        lcnt += 1
                        for ch in line:
                            print(ch, end='')
                            ccnt += 1
                    lines = s.readlines(10)
                s.close()
                print("\n\nCharacters in file:", ccnt)
                print("Lines in file:     ", lcnt)
            except IOError as e:
                print("I/O error occurred:", strerror(e.errno))

        output:

            Beautiful is better than ugly.
            Explicit is better than implicit.
            Simple is better than complex.
            Complex is better than complicated.

            Characters in file: 131
            Lines in file:      4

        code:

            name = "C:\\Users\\Micro\\Desktop\\desk\Code\\PCAP\\file.txt"
            from os import strerror

            try:
                ccnt = lcnt = 0
                for line in open(name, 'rt'):
                    lcnt += 1
                    for ch in line:
                        print(ch, end='')
                        ccnt += 1
                print("\n\nCharacters in file:", ccnt)
                print("Lines in file:     ", lcnt)
            except IOError as e:
                print("I/O error occurred: ", strerror(e.errno))

        output:

            Beautiful is better than ugly.
            Explicit is better than implicit.  
            Simple is better than complex.     
            Complex is better than complicated.

            Characters in file: 131
            Lines in file:      4

        a trait of the object returned by the open() function in text mode
        the object is an instance of the iterable class
        The iteration protocol defined for the file object is very simple - its __next__ method just returns
            the next line read in from the file

117) write()
        expects just one argument, a string that will be transferred to an open file
        writing a file opened in read mode won't succeed
        no newline character is added, add manually for file to be filled with multiple lines
        the open mode w ensures that the file will be created from scratch, even if it exists and contains data) 
        
        code:

            from os import strerror

            try:
                fo = open('newtext.txt', 'wt') # A new file (newtext.txt) is created.
                for i in range(10):
                    s = "line #" + str(i+1) + "\n"
                    for ch in s:
                        fo.write(ch)
                fo.close()
            except IOError as e:
                print("I/O error occurred: ", strerror(e.errno))

        file (newtext.txt):

            line #1
            line #2
            line #3
            line #4
            line #5
            line #6
            line #7
            line #8
            line #9
            line #10

        code:

            from os import strerror

            try:
                fo = open('newtext.txt', 'wt')
                for i in range(10):
                    fo.write("line #" + str(i+1) + "\n")
                fo.close()
            except IOError as e:
                print("I/O error occurred: ", strerror(e.errno))

        file (newtext.txt):

            line #1
            line #2
            line #3
            line #4
            line #5
            line #6
            line #7
            line #8
            line #9
            line #10

        Note: you can use the same method to write to the stderr stream, but don't try to open it, as it's always open implicitly.
        For example, if you want to send a message string to stderr to distinguish it from normal program output, it may look like this:

        code:

            import sys
            sys.stderr.write("Error message")

118) Bytearrays
        a mutable sequence of bytes
        an array containing (amorphous) bytes
        setting a byte array element with a value which is not an integer will raise the TypeError exception
        setting a byte array element with a value which is outside 0-225 will raise the ValueError exception

        code:

            data = bytearray(10)
            print(data)

        output:

            bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00')

        Such an invocation creates a bytearray object able to store ten bytes
        Note: such a constructor fills the whole array with zeros

        code:

            data = bytearray(10)

            for i in range(len(data)):
                data[i] = 10 - i
            print(data)
            for b in data:
                print(hex(b))

        output:

            bytearray(b'\n\t\x08\x07\x06\x05\x04\x03\x02\x01')
            0xa
            0x9
            0x8
            0x7
            0x6
            0x5
            0x4
            0x3
            0x2
            0x1

        we've used two methods to iterate the byte arrays, and the hex() function to see the elements printed as hexadecimal values
            
119) Writing a byte array to a file
        code:

            from os import strerror

            data = bytearray(10)
            for i in range(len(data)):
                data[i] = 10 + i
            try:
                bf = open('file.bin', 'wb')
                bf.write(data)
                bf.close()
            except IOError as e:
                print("I/O error occurred:", strerror(e.errno))

120) readinto()
        Reading bytes from a stream (to a binary file)
        code:

            from os import strerror

            data = bytearray(10)

            try:
                bf = open('file.bin', 'rb')
                bf.readinto(data)
                bf.close()

                for b in data:
                    print(hex(b), end=' ')
            except IOError as e:
                print("I/O error occurred:", strerror(e.errno))

        output:
            
            0xa 0xb 0xc 0xd 0xe 0xf 0x10 0x11 0x12 0x13

        read()
            tries to read all the contents of the file into the memory, making them a part of a newly created object of the bytes class
            this class has some similarities to bytearray, with the exception of one significant difference - it's immutable
        
        code:

            from os import strerror

            try:
                bf = open('file.bin', 'rb')
                data = bytearray(bf.read())
                bf.close()

                for b in data:
                    print(hex(b), end=' ')

            except IOError as e:
                print("I/O error occurred:", strerror(e.errno))

        output:

            0xa 0xb 0xc 0xd 0xe 0xf 0x10 0x11 0x12 0x13

        don't use this kind of read if you're not sure that the file's contents will fit the available memory

        if the read() method is invoked with an argument, it specifies the maximum number of bytes to be read

        code:

            try:
                bf = open('file.bin', 'rb')
                data = bytearray(bf.read(5))
                bf.close()

                for b in data:
                    print(hex(b), end=' ')

            except IOError as e:
                print("I/O error occurred:", strerror(e.errno))

        output:

            0xa 0xb 0xc 0xd 0xe 

        the first five bytes of the file have been read by the code - the next five are still waiting to be processed

121) Copying files

        code:

            from os import strerror

            srcname = input("Enter the source file name: ")
            try:
                src = open(srcname, 'rb')
            except IOError as e:
                print("Cannot open the source file: ", strerror(e.errno))
                exit(e.errno)	

            dstname = input("Enter the destination file name: ")
            try:
                dst = open(dstname, 'wb')
            except Exception as e:
                print("Cannot create the destination file: ", strerror(e.errno))
                src.close()
                exit(e.errno)	

            buffer = bytearray(65536)
            total  = 0
            try:
                readin = src.readinto(buffer)
                while readin > 0:
                    written = dst.write(buffer[:readin])
                    total += written
                    readin = src.readinto(buffer)
            except IOError as e:
                print("Cannot create the destination file: ", strerror(e.errno))
                exit(e.errno)	
                
            print(total,'byte(s) succesfully written')
            src.close()
            dst.close()

        lines 3 through 8: ask the user for the name of the file to copy, and try to open it to read; terminate the program execution if 
            the open fails; note: use the exit() function to stop program execution and to pass the completion code to the OS; any completion 
            code other than 0 says that the program has encountered some problems; use the errno value to specify the nature of the issue;
        lines 10 through 16: repeat nearly the same action, but this time for the output file;
        line 18: prepare a piece of memory for transferring data from the source file to the target one; such a transfer area is often 
            called a buffer, hence the name of the variable; the size of the buffer is arbitrary - in this case, we decided to use 64 
            kilobytes; technically, a larger buffer is faster at copying items, as a larger buffer means fewer I/O operations; actually, there 
            is always a limit, the crossing of which renders no further improvements; test it yourself if you want.
        line 19: count the bytes copied - this is the counter and its initial value;
        line 21: try to fill the buffer for the very first time;
        line 22: as long as you get a non-zero number of bytes, repeat the same actions;
        line 23: write the buffer's contents to the output file (note: we've used a slice to limit the number of bytes being written,
            as write() always prefer to write the whole buffer)
        line 24: update the counter;
        line 25: read the next file chunk;
        lines 30 through 32: some final cleaning - the job is done.

        if the buffer automatically takes in 65536 bytes already, why do i have to limit the write to readin in the next line?
            The reason you need to limit the write to the number of bytes actually read (readin) is because the last read operation
                might not fill the entire buffer. When you reach the end of the source file, the number of bytes read could be less than
                the buffer size (65536 bytes). 
            Therefore, you need to ensure that only the valid portion of the buffer is written to the destination file.

122) Project: Character frequency histogram

        my code:

            dictionary = {}
            src = "C:\\Users\\Micro\\Desktop\\desk\\Code\\PCAP\\file.txt"  # input("Enter source file name:   ")
            readfrom = open(src, "rt")
            text = readfrom.read()

            for char in text:
                char = char.lower()
                if (char in dictionary) and (char.isalpha() == True) and (len(char) == 1):
                    dictionary[char] += 1
                elif (char.isalpha() == True) and (len(char) == 1):
                    dictionary[char] = 1
                    
            sorted_dictionary =  sorted(dictionary)

            for key in sorted_dictionary:
                if dictionary[key] != 0:
                    print(f"{key} -> {dictionary[key]}")

            readfrom.close()
        
        their code:

            from os import strerror

            # Initialize 26 counters for each Latin letter.
            # Note: we've used comprehension to do that.
            counters = {chr(ch): 0 for ch in range(ord('a'), ord('z') + 1)}
            file_name = input("Enter the name of the file to analyze: ")
            try:
                f = open(file_name, "rt")
                for line in f:
                    for char in line:
                        # If it is a letter...
                        if char.isalpha():
                            # ... we'll treat it as lower-case and update the appropriate counter.
                            counters[char.lower()] += 1
                f.close()
                # Let's output the counters.
                for char in counters.keys():
                    cnt = counters[char]
                    if cnt > 0:
                        print(char, '->',cnt)
            except IOError as e:
                print("I/O error occurred: ", strerror(e.errno))

123) Project: Sorted character frequency histogram

        my code:

            dictionary, sorted_dictionary = {}, {}
            src = "C:\\Users\\Micro\\Desktop\\desk\\Code\\PCAP\\file.txt"  # input("Enter source file name:   ")
            dst = "C:\\Users\\Micro\\Desktop\\desk\\Code\\PCAP\\file.hist"
            readfrom = open(src, "rt")
            writeto = open(dst, "wt")
            readfile = readfrom.read()

            for char in readfile:
                char = char.lower()
                if (char in dictionary) and (char.isalpha() == True) and (len(char) == 1):
                    dictionary[char] += 1
                elif (char.isalpha() == True) and (len(char) == 1):
                    dictionary[char] = 1

            sorted_items = sorted(dictionary.items(), key = lambda item: item[1], reverse = True)
            sorted_dictionary = {key: value for key, value in sorted_items}

            for key, value in sorted_dictionary.items():
                writeto.write(f"{key} -> {value}\n")

            readfrom.close()
            writeto.close()

        their code:
        
            from os import strerror

            counters = {chr(ch): 0 for ch in range(ord('a'), ord('z') + 1)}
            file_name = input("Enter the name of the file to analyze: ")
            try:
                f = open(file_name, "rt")
                for line in f:
                    for char in line:
                        if char.isalpha():
                            counters[char.lower()] += 1
                f.close()
                f = open(file_name + '.hist', 'wt')
                # Note: we've used lambda to access the directory's elements and set reverse to get a valid order.
                for char in sorted(counters.keys(), key=lambda x: counters[x], reverse=True):
                    cnt = counters[char]
                    if cnt > 0:
                        f.write(char + ' -> ' + str(cnt) + '\n')
                f.close()
            except IOError as e:
                print("I/O error occurred: ", strerror(e.errno))
        
124) Project: Evaluating students' results

        my code:

            from os import strerror
            import errno

            class StudentsDataException(Exception):
                pass

            class BadLine(StudentsDataException):
                def __init__(self, error_line, error_string):
                    super().__init__(self)
                    self.error_line = error_line
                    self.error_string = error_string
                    

            class FileEmpty(StudentsDataException):
                def __init__(self):
                    super().__init__(self)

            src = "C:\\Users\\Micro\\Desktop\\desk\\Code\\PCAP\\samplefile.txt"  # input("Enter Prof. Jekyll's file name:   ")
            results = {}

            try:
                source = open(src, "rt")
                info = source.readlines()
                if not info:
                    raise FileEmpty()

                for errorcase, line in enumerate(info, start=1):
                    if "\t" not in line:
                        raise BadLine(errorcase, line)

                    name, score = line[:line.rfind("\t")].replace("\t", " "), float(line[line.rfind("\t") + 1:])
                    if name not in results:
                        results[name] = score
                    else:
                        results[name] += score
                
                for key in sorted(results.keys()):
                    print(key + "\t" + str(results[key]))

            except IOError as exception:
                print("File I/O error occurred:", strerror(exception.errno))
            except BadLine as exception:
                print("Bad line #" + str(exception.error_line) + " in source file:" + exception.error_string)
            except FileEmpty:
                print("Source file empty")

        their code:

            # A base exception class for our code:
            class StudentsDataException(Exception):
                pass


            # An exception for erroneous lines:
            class BadLine(StudentsDataException):
                def __init__(self, line_number, line_string):
                    super().__init__(self)
                    self.line_number = line_number
                    self.line_string = line_string


            # An exception for an empty file.
            class FileEmpty(StudentsDataException):
                def __init__(self):
                    super().__init__(self)


            from os import strerror

            # A dictionary for students' data:
            data = { }

            file_name = input("Enter student's data filename: ")
            line_number = 1
            try:
                f = open(file_name, "rt")
                # Read the whole file into list.
                lines = f.readlines()
                f.close()
                # Is the file empty?
                if len(lines) == 0:
                    raise FileEmpty()
                # Scan the file line by line.
                for i in range(len(lines)):
                    # Get the i'th line.
                    line = lines[i]
                    # Divide it into columns.
                    columns = line.split()
                    # There shoule be 3 columns - are they there?
                    if len(columns) != 3:
                        raise BadLine(i + 1, line)
                    # Build a key from student's given name and surname.
                    student = columns[0] + ' ' + columns[1]
                    # Get points.
                    try:
                        points = float(columns[2])
                    except ValueError:
                        raise BadLine(i + 1, line)
                    # Update dictionary.
                    try:
                        data[student] += points
                    except KeyError:
                        data[student] = points
                # Print results.
                for student in sorted(data.keys()):
                    print(student,'\t', data[student])

            except IOError as e:
                print("I/O error occurred: ", strerror(e.errno))
            except BadLine as e:
                print("Bad line #" + str(e.line_number) + " in source file:" + e.line_string)
            except FileEmpty:
                print("Source file empty")

125) Getting information about the os
        os module provides a function called uname, which returns an object containing the following attributes:
            systemname â stores the name of the os;
            nodename â stores the machine name on the network;
            release â stores the os release;
            version â stores the os version;
            machine â stores the hardware identifier, e.g., x86_64.
        
        unix:
        
            code:
                
                import os
                print(os.uname())

        windows:

            code:

                import platform
                print(platform.uname())
            
            output:

                uname_result(system='Windows', node='DESKTOP-ED2OOO9', release='10', version='10.0.19045', machine='AMD64')
            
        The os module allows you to quickly distinguish the operating system using the name attribute, which supports one of the following names:
            posix â you'll get this name if you use Unix
            nt â you'll get this name if you use Windows
            java â you'll get this name if your code is written in Jython
                
                code:

                    import os
                    print(os.name)

                output:

                    nt

126) Creating directories in Python
        mkdir â creates a directory in the specified path. Note that running the program twice will raise a FileExistsError
        listdir â returns a list containing the names of the files and directories that are in the path passed as an argument
                    if no argument is passed to it, the current working directory will be used
                    the listdir function omits the entries '.' and '..', which are displayed, for example, when using the ls -a command on Unix systems. 
                    If the path isn't passed, the result will be returned for the current working directory

        my_first_directory
            relative path which will create the my_first_directory directory in the current working directory;
        ./my_first_directory
            relative path that explicitly points to the current working directory. It has the same effect as the path above;
        ../my_first_directory
            relative path that will create the my_first_directory directory in the parent directory of the current working directory;
        /python/my_first_directory
            absolute path that will create the my_first_directory directory, exists in the python directory in the root directory.

        chmod function â to change directory permissions

        code:

            import os

            os.mkdir("my_first_directory")
            print(os.listdir())

127) Recursive directory creation
        makedirs â create a directory recursively
        chdir â to move between directories, changes the current working directory to the specified path

        code:

            import os

            os.makedirs("my_first_directory/my_second_directory")
            os.chdir("my_first_directory")
            print(os.listdir())

        output:            

            ['my_second_directory']

        equivalent to:

            mkdir my_first_directory/my_second_directory

128) Get current working directory
        getcwd  â get current working directory

        code:

            import os

            os.makedirs("my_first_directory/my_second_directory")
            os.chdir("my_first_directory")
            print(os.getcwd())
            os.chdir("my_second_directory")
            print(os.getcwd())

        output:

            .../my_first_directory
            .../my_first_directory/my_second_directory

129) Deleting directories
        rmdir â delete an empty directory
                â if one of the directories doesn't exist or isn't empty, an exception will be raised
        removedirs â removes all directories specified in the given path

        code:

            import os

            os.mkdir("my_first_directory")
            print(os.listdir())
            os.rmdir("my_first_directory")
            print(os.listdir())

        code:

            import os

            os.makedirs("my_first_directory/my_second_directory")
            os.removedirs("my_first_directory/my_second_directory")
            print(os.listdir())

130) system()
        to execute a command in the underlying operating system's shell, python passes the command string to the os, which executes it as if
            it were run from the command line or terminal
        returns the exit status code of the command executed, a return value of 0 indicates that the command executed successfully,
            while a non-zero value indicates an error
        
        code:

            import os

            returned_value = os.system("mkdir my_first_directory")
            print(returned_value)

        output:

            0

131) Project: The os module

        their code:

            import os

            class DirectorySearcher:
                def find(self, path, dir):
                    try:
                        os.chdir(path)
                    except OSError:
                        return
                    current_dir = os.getcwd()
                    for entry in os.listdir("."):
                        if entry == dir:
                            print(os.getcwd() + "/" + dir)
                        self.find(current_dir + "/" + entry, dir)
            directory_searcher = DirectorySearcher()
            directory_searcher.find("./tree", "python")

132) Getting the current local date and creating date objects
        datetime module provides classes for working with date and time, one of its classes is called date

        code:

            from datetime import date

            today = date.today()

            print("Today:", today)
            print("Year:", today.year)
            print("Month:", today.month)
            print("Day:", today.day)


        output:

            Today: 2024-07-20
            Year: 2024
            Month: 7
            Day: 20

        The today method returns a date object representing the current local date, the date object has three attributes: year, month, and day

        code:

            from datetime import date

            my_date = date(2019, 11, 4)
            print(my_date)


        output:

            2019-11-04

        When creating a date object, keep the following restrictions in mind:
            Parameters & Restrictions
                year	
                    The year parameter must be greater than or equal to 1 (MINYEAR constant) and less than or equal to 9999 (MAXYEAR constant).

                month	
                    The month parameter must be greater than or equal to 1 and less than or equal to 12.

                day	
                    The day parameter must be greater than or equal to 1 and less than or equal to the last day of the given month and year.

133) Creating a date object from a timestamp
        time() returns num of seconds from January 1, 1970 to the current moment in the form of a float number
        timestamp is the dif bw a particular date (including time) and January 1, 1970
        code:

            from datetime import date
            import time

            timestamp = time.time()
            print("Timestamp:", timestamp)

            d = date.fromtimestamp(timestamp)
            print("Date:", d)


        output:

            Timestamp: 1721491077.66011
            Date: 2024-07-20

134) Creating a date object using the ISO format
        fromisoformat method â takes a date in the YYYY-MM-DD format compliant with the ISO 8601 standard
        code:

            from datetime import date
            d = date.fromisoformat('2019-11-04')
            print(d)


        output:

            2019-11-04

135) The replace() method
        returns a changed date object, and needs to be assigned to a variable
        code:

            from datetime import date

            d = date(1991, 2, 5)
            print(d)

            d = d.replace(year=1992, month=1, day=16)
            print(d)

        output:

            1991-02-05
            1992-01-16

136) weekday() & isodayweek()
        weekday returns the day of the week as an integer, where 0 is Monday and 6 is Sunday
        isoweekday() returns the day of the week as an integer, but 1 is Monday, and 7 is Sunday
            for the same date we get a different integer, but expressing the same day of the week, the integer returned by the isodayweek
                method follows the ISO 85601 specification
        code:

            from datetime import date

            d = date(2019, 11, 4)
            print(d.weekday())
            print(d.isoweekday())

        output:

                0
                1

137) Creating time objects
        time(hour, minute, second, microsecond, tzinfo, fold)
        The time class constructor accepts the following optional parameters:

        Parameters	& Restrictions
            hour	
                The hour parameter must be greater than or equal to 0 and less than 23.
            minute	
                The minute parameter must be greater than or equal to 0 and less than 59.
            second	
                The second parameter must be greater than or equal to 0 and less than 59.
            microsecond	
                The microsecond parameter must be greater than or equal to 0 and less than 1000000.
            tzinfo
                The tzinfo parameter must be a tzinfo subclass object or None (default).
            fold	
                The fold parameter must be 0 or 1 (default 0).

        The tzinfo parameter is associated with time zones, while fold with wall times

        code:

            from datetime import time

            t = time(14, 53, 20, 1)

            print("Time:", t)
            print("Hour:", t.hour)
            print("Minute:", t.minute)
            print("Second:", t.second)
            print("Microsecond:", t.microsecond)

        output:

            Time: 14:53:20.000001
            Hour: 14
            Minute: 53
            Second: 20
            Microsecond: 1

        In the example, we passed four parameters to the class constructor: hour, minute, second, and microsecond.
            Each of them can be accessed using the class attributes.

138) sleep()
        suspends program execution for the given number of seconds
        the sleep function accepts only an integer or a floating point number
        code:

            import time

            class Student:
                def take_nap(self, seconds):
                    print("I'm very tired. I have to take a nap. See you later.")
                    time.sleep(seconds)
                    print("I slept well! I feel great!")

            student = Student()
            student.take_nap(5)

        output:

            I'm very tired. I have to take a nap. See you later.
            I slept well! I feel great!                                 (Output after a 5 second delay)

139) ctime()
            converts the time in seconds since January 1, 1970 (Unix epoch) to a string
            code:

            import time
            from datetime import date

            timestamp = time.time()
            seconds = time.ctime(timestamp)

            print(f"{timestamp}\n{seconds}")
            print(f"\n{time.ctime()}")

        output:

            1721506087.4283576
            Sat Jul 20 23:08:07 2024

            Sat Jul 20 23:08:07 2024

140) gmtime() & localtime()
        Some of the functions available in the time module require knowledge of the struct_time class, the class looks like this:

            time.struct_time:
                tm_year   # specifies the year
                tm_mon    # specifies the month (value from 1 to 12)
                tm_mday   # specifies the day of the month (value from 1 to 31)
                tm_hour   # specifies the hour (value from 0 to 23)
                tm_min    # specifies the minute (value from 0 to 59)
                tm_sec    # specifies the second (value from 0 to 61 )
                tm_wday   # specifies the weekday (value from 0 to 6)
                tm_yday   # specifies the year day (value from 1 to 366)
                tm_isdst  # specifies whether daylight saving time applies (1 - yes, 0 - no, -1 - it isn't known)
                tm_zone   # specifies the timezone name (value in an abbreviated form)
                tm_gmtoff # specifies the offset east of UTC (value in seconds)

        The struct_time class also allows access to values using indexes. Index 0 returns the value in tm_year,
            while 8 returns the value in tm_isdst
        The exceptions are tm_zone and tm_gmoff, which cannot be accessed using indexes

        code:

            import time

            timestamp = time.time()
            print(time.gmtime(timestamp))
            print(time.localtime(timestamp))

        output:

            time.struct_time(tm_year=2024, tm_mon=7, tm_mday=20, tm_hour=20, tm_min=32, tm_sec=11, tm_wday=5, tm_yday=202, tm_isdst=0)
            time.struct_time(tm_year=2024, tm_mon=7, tm_mday=20, tm_hour=23, tm_min=32, tm_sec=11, tm_wday=5, tm_yday=202, tm_isdst=0)

        For the gmtime function, the tm_isdst attribute is always 0

141) asctime() & mktime()
        asctime() â converts a struct_time object or a tuple to a string
            if no arguments are passed, time returned by localtime is used
        mktime() â converts a struct_time obkect or a tuple that expressed the local time to the number of seconds since the Unix epoch

        code:

            import time

            timestamp = 1572879180
            st = time.gmtime(timestamp)

            print(time.asctime(st))
            print(time.mktime((2019, 11, 4, 14, 53, 0, 0, 308, 0)))

        output:

            Mon Nov  4 14:53:00 2019
            1572879180.0

142) Creating datetime objects
        In the datetime module, date & time are represented as separate objects or as one. The class that combines date & time is called datetime
        datetime(year, month, day, hour, minute, second, microsecond, tzinfo, fold)

        code:

            from datetime import datetime

            dt = datetime(2019, 11, 4, 14, 53)

            print("Datetime:", dt)
            print("Date:", dt.date())
            print("Time:", dt.time())

        output:

            Datetime: 2019-11-04 14:53:00
            Date: 2019-11-04
            Time: 14:53:00

        All parameters passed to the constructor go to read-only class attributes.
            They're year, month, day, hour, minute, second, microsecond, tzinfo, and fold.

        The example shows two methods that return two different objects. The method called date returns the date object with the given
            year, month, and day, while the method called time returns the time object with the given hour and minute

143) Methods that return the current date and time
        today()  â  returns the current local date and time with the tzinfo attribute set to None;
        now()  â    returns the current local date and time the same as the today method, unless we pass the optional argument tz to it.
                        The argument of this method must be an object of the tzinfo subclass;
        utcnow() â  returns the current UTC date and time with the tzinfo attribute set to None.

        code:

            from datetime import datetime

            print("today:", datetime.today())
            print("now:", datetime.now())
            print("utcnow:", datetime.utcnow())

        output:

            today: 2024-07-20 20:47:27.591619
            now: 2024-07-20 20:47:27.592013
            utcnow: 2024-07-20 20:47:27.592256

        the result of all the three methods is the same. The small differences are caused by the time elapsed between subsequent calls

144) Getting a timestamp - timestamp()
        The timestamp method returns a float value expressing the number of seconds elapsed between the date and time indicated by the datetime object
            and January 1, 1970, 00:00:00 (UTC)
        
        code:

            from datetime import datetime

            dt = datetime(2024, 7, 20, 23, 52)
            print("Timestamp:", dt.timestamp())

        output:

            Timestamp: 1721508720.0

145) Date & time formatting - strftime()
        allows us to return the date and time in the format we specify
        takes only one argument in the form of a string specifying the format that can consist of directives
        A directive is a string consisting of the character % (percent) and a lowercase or uppercase letter,
            e.g., the directive %Y means the year with the century as a decimal number.
        
        code:
            
            from datetime import date

            d = date(2024, 7, 20)
            print(d.strftime('%Y/%m/%d'))

        output:

            2024/07/20

        all available directives: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes

        code:

            from datetime import time
            from datetime import datetime

            t = time(14, 53)
            print(t.strftime("%H:%M:%S"))

            dt = datetime(2020, 11, 4, 14, 53)
            print(dt.strftime("%y/%B/%d %H:%M:%S"))

        output:

            14:53:00
            20/November/04 14:53:00

146) strftime() in the time module
        code:

            import time

            timestamp = 1572879180
            st = time.gmtime(timestamp)

            print(st)
            print(time.strftime("%Y/%m/%d %H:%M:%S", st))
            print(time.strftime("%Y/%m/%d %H:%M:%S"))
        
        output:

            time.struct_time(tm_year=2019, tm_mon=11, tm_mday=4, tm_hour=14, tm_min=53, tm_sec=0, tm_wday=0, tm_yday=308, tm_isdst=0)
            2019/11/04 14:53:00
            2024/07/21 00:16:19

        all available directives in the time module: https://docs.python.org/3/library/time.html#time.strftime

147) strptime()


        code:

            from datetime import datetime
            print(datetime.strptime("2019/11/04 14:53:00", "%Y/%m/%d %H:%M:%S"))

        output:

            2019-11-04 14:53:00

        code:

            import time
            print(time.strptime("2019/11/04 14:53:00", "%Y/%m/%d %H:%M:%S"))

        output:

            time.struct_time(tm_year=2019, tm_mon=11, tm_mday=4, tm_hour=14, tm_min=53, tm_sec=0, tm_wday=0, tm_yday=308, tm_isdst=-1)

        datetime.strptime: Converts a string representing a date and time into a datetime object
        time.strptime: Converts a string representing a time into a struct_time object

148) Date & time operations - timedelta()
        The timedelta class in the datetime module allows for date and time calculation,
            such as subtracting two date or datetime objects to get the difference in days, hours, minutes, and seconds
        
        code:

            from datetime import date
            from datetime import datetime

            d1 = date(2020, 11, 4)
            d2 = date(2019, 11, 4)

            print(d1 - d2)

            dt1 = datetime(2020, 11, 4, 0, 0, 0)
            dt2 = datetime(2019, 11, 4, 14, 53, 0)

            print(dt1 - dt2)

        output:

            366 days, 0:00:00
            365 days, 9:07:00

        The difference in outputs arises because date subtraction yields days only,
            while datetime subtraction includes differences in days, hours, minutes, and seconds

149) Creating timedelta objects
        arguments accepted by the class constructor:
        days, seconds, microseconds, milliseconds, minutes, hours, and weeks

        code:

            from datetime import timedelta

            delta = timedelta(weeks=2, days=2, hours=3)
            print(delta)

        output:

            16 days, 3:00:00

        code:

            from datetime import timedelta

            delta = timedelta(weeks=2, days=2, hours=3)
            print("Days:", delta.days)
            print("Seconds:", delta.seconds)
            print("Microseconds:", delta.microseconds)

        output:

            Days: 16
            Seconds: 10800
            Microseconds: 0

        code:

            from datetime import timedelta
            from datetime import date
            from datetime import datetime

            delta = timedelta(weeks=2, days=2, hours=2)
            print(delta)

            delta2 = delta * 2
            print(delta2)

            d = date(2019, 10, 4) + delta2
            print(d)

            dt = datetime(2019, 10, 4, 14, 53) + delta2
            print(dt)

        output:

            16 days, 02:00:00
            32 days, 04:00:00
            2019-11-05
            2019-11-05 18:53:00

150) Project: The datetime and time modules

        my code:

            from datetime import datetime

            object = datetime(2020, 11, 4, 14, 53)

            print(object.strftime("%Y/%m/%d %H:%M:%S"))
            print(object.strftime("%y/%B/%d %H:%M:%S %p"))
            print(object.strftime("%a, %Y %B %d"))
            print(object.strftime("%A, %Y %B %d"))
            print(object.strftime("Weekday: %w"))
            print(object.strftime("Day of the year: %j"))
            print(object.strftime("Week number of the year: %U"))

        their code:

            from datetime import datetime

            my_date = datetime(2020, 11, 4, 14, 53)

            print(my_date.strftime("%Y/%m/%d %H:%M:%S"))
            print(my_date.strftime("%y/%B/%d %H:%M:%S %p"))
            print(my_date.strftime("%a, %Y %b %d"))
            print(my_date.strftime("%A, %Y %B %d"))
            print(my_date.strftime("Weekday: %w"))
            print(my_date.strftime("Day of the year: %j"))
            print(my_date.strftime("Week number of the year: %W"))

151) the calendar module
        Day of the week	       Integer value	    Constant
        Monday	                    0	        calendar.MONDAY
        Tuesday         	        1	        calendar.TUESDAY
        Wednesday       	        2	        calendar.WEDNESDAY
        Thursday	                3	        calendar.THURSDAY
        Friday	                    4	        calendar.FRIDAY
        Saturday        	        5	        calendar.SATURDAY
        Sunday          	        6	        calendar.SUNDAY

        The first day of the week (Monday) is represented by  0 & the calendar.MONDAY constant, while the last day of the week (Sunday) is 
        represented by 6 & the calendar.SUNDAY constant.

        For months, integer values are indexed from 1, i.e., January is represented by 1, and December by 12

        w - date column width (default 2)
        l - number of lines per week (default 1)
        c - number of spaces between month columns (default 6)
        m - number of columns (default 3)

        prcal() â has the same parameters as calendar(), but doesn't require printing to display the calendar:

            import calendar
            calendar.prcal(2020)

        code:

            import calendar
            print(calendar.calendar(2020))

        output:

                                            2020

                January                   February                   March
            Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                1  2  3  4  5                      1  2                         1
            6  7  8  9 10 11 12       3  4  5  6  7  8  9       2  3  4  5  6  7  8
            13 14 15 16 17 18 19      10 11 12 13 14 15 16       9 10 11 12 13 14 15
            20 21 22 23 24 25 26      17 18 19 20 21 22 23      16 17 18 19 20 21 22
            27 28 29 30 31            24 25 26 27 28 29         23 24 25 26 27 28 29
                                                                30 31

                April                      May                       June
            Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                1  2  3  4  5                   1  2  3       1  2  3  4  5  6  7
            6  7  8  9 10 11 12       4  5  6  7  8  9 10       8  9 10 11 12 13 14
            13 14 15 16 17 18 19      11 12 13 14 15 16 17      15 16 17 18 19 20 21
            20 21 22 23 24 25 26      18 19 20 21 22 23 24      22 23 24 25 26 27 28
            27 28 29 30               25 26 27 28 29 30 31      29 30

                    July                     August                  September
            Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                1  2  3  4  5                      1  2          1  2  3  4  5  6
            6  7  8  9 10 11 12       3  4  5  6  7  8  9       7  8  9 10 11 12 13
            13 14 15 16 17 18 19      10 11 12 13 14 15 16      14 15 16 17 18 19 20
            20 21 22 23 24 25 26      17 18 19 20 21 22 23      21 22 23 24 25 26 27
            27 28 29 30 31            24 25 26 27 28 29 30      28 29 30
                                    31

                October                   November                  December
            Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                    1  2  3  4                         1          1  2  3  4  5  6
            5  6  7  8  9 10 11       2  3  4  5  6  7  8       7  8  9 10 11 12 13
            12 13 14 15 16 17 18       9 10 11 12 13 14 15      14 15 16 17 18 19 20
            19 20 21 22 23 24 25      16 17 18 19 20 21 22      21 22 23 24 25 26 27
            26 27 28 29 30 31         23 24 25 26 27 28 29      28 29 30 31
                                    30

152) Calendar for a specific month
        w - date column width (default 2)
        l - number of lines per week (default 1)
        prmonth() â has the same parameters as month(), but doesn't require printing to display the calendar:

            import calendar
            calendar.prmonth(2024, 7)

        code:

            import calendar
            print(calendar.month(2024, 7))

        output:

                    July 2024      
            Mo Tu We Th Fr Sa Su
            1  2  3  4  5  6  7
            8  9 10 11 12 13 14
            15 16 17 18 19 20 21
            22 23 24 25 26 27 28
            29 30 31

153) setfirstweekday()
        change the first day of the week from monday to any other day

        code:

            import calendar
            calendar.prmonth(2024, 7)
            calendar.setfirstweekday(calendar.SUNDAY)
            print()
            calendar.prmonth(2024, 7)

        output:

                    July 2024      
            Mo Tu We Th Fr Sa Su
            1  2  3  4  5  6  7
            8  9 10 11 12 13 14
            15 16 17 18 19 20 21
            22 23 24 25 26 27 28
            29 30 31

                July 2024      
            Su Mo Tu We Th Fr Sa
                1  2  3  4  5  6
            7  8  9 10 11 12 13
            14 15 16 17 18 19 20
            21 22 23 24 25 26 27
            28 29 30 31

154) weekday()
        returns the day of the week as an integer value for the given year, month, and day

        code:

            import calendar
            print(calendar.weekday(2020, 12, 24))

        outuput:

            3

        the weekday function returns 3, which means that December 24, 2020 is a Thursday

155) weekheader()
        takes in 1 argument; width of the week header and returns the shortened week name

        code:

            import calendar
            print(calendar.weekheader(2))

        output:

            Mo Tu We Th Fr Sa Su

156) isleap()
        returns boolean, True, if the only argument passed; year, is a leap year

        code:

            import calendar

print(calendar.isleap(2020))
print(calendar.leapdays(2010, 2021))  # Up to but not including 2021.

        output:

            True
157) leapyears
        returns integer, number of leap years inside the range of the 2 passed arguments; start & end year, end year is excluded from the range

        code:

            import calendar

            print(calendar.leapdays(2010, 2021))  # Up to but not including 2021.

        output:
        
            3
        
158) Classes for creating calendars
        calendar.Calendar -             provides methods to prepare calendar data for formatting;
        calendar.TextCalendar -         is used to create regular text calendars;
        calendar.HTMLCalendar -         is used to create HTML calendars;
        calendar.LocalTextCalendar -    is a subclass of the calendar.TextCalendar class. The constructor of this class takes the locale parameter,
            which is used to return the appropriate months and weekday names.
        calendar.LocalHTMLCalendar - is a subclass of the calendar.HTMLCalendar class. The constructor of this class takes the locale parameter,
            which is used to return the appropriate months and weekday names

159) Creating a Calendar object
        The Calendar class constructor takes one optional parameter named firstweekday, by default equal to 0 (Monday), must be bw 0-6
        iterweekdays()  â  class method that returns an iterator for week day numbers

        code:

            import calendar  

            c = calendar.Calendar(calendar.SUNDAY)

            for weekday in c.iterweekdays():
                print(weekday, end=" ")
                
        output:

            6 0 1 2 3 4 5

        The first value returned is always equal to the value of the firstweekday property

160) itermonthdates()
        the method takes in 2 arguments, year and month
        all days in the specified month and year are returned,
            as well as all days before the beginning of the month or the end of the month that are necessary to get a complete week
        each day is represented by a datetime.date object

        code:

            import calendar  

            c = calendar.Calendar()

            for date in c.itermonthdates(2019, 11):
                print(date, end=" ")
            
            print()
            print()

            cal = calendar.TextCalendar()
            print(cal.formatmonth(2019, 11))

        output:

            2019-10-28 2019-10-29 2019-10-30 2019-10-31 2019-11-01 2019-11-02 2019-11-03 2019-11-04 2019-11-05 2019-11-06 2019-11-07 2019-11-08
                2019-11-09 2019-11-10 2019-11-11 2019-11-12 2019-11-13 2019-11-14 2019-11-15 2019-11-16 2019-11-17 2019-11-18 2019-11-19 2019-11-20
                2019-11-21 2019-11-22 2019-11-23 2019-11-24 2019-11-25 2019-11-26 2019-11-27 2019-11-28 2019-11-29 2019-11-30 2019-12-01 
                
                November 2019    
            Mo Tu We Th Fr Sa Su
                        1  2  3
            4  5  6  7  8  9 10
            11 12 13 14 15 16 17
            18 19 20 21 22 23 24
            25 26 27 28 29 30  

161) Other methods that return iterators
        itermonthdates()  â  takes year & month as parameters, returns the iterator to the days of the week represented by numbers
        itermonthdays() works too

        code:

            import calendar  

            c = calendar.Calendar()

            for iter in c.itermonthdates(2019, 11):
                print(iter, end=" ")

            print()
            print()

            cal = calendar.TextCalendar()
            print(cal.formatmonth(2019, 11))

        output:

            0 0 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 0 

            November 2019    
            Mo Tu We Th Fr Sa Su
                        1  2  3
            4  5  6  7  8  9 10
            11 12 13 14 15 16 17
            18 19 20 21 22 23 24
            25 26 27 28 29 30  

        three other similar methods in the Calendar class that differ in data returned:

        itermonthdates2  â  returns days in the form of tuples consisting of a day of the month number and a week day number
        itermonthdates3  â  returns days in the form of tuples consisting of a year, a month, and a day of the month numbers
        itermonthdates4  â  returns days in the form of tuples consisting of a year, a month, a day of the month, and a day of the week numbers

        code:

            import calendar  

            c = calendar.Calendar()

            for iter in c.itermonthdays2(2019, 11):
                print(iter, end=" ")

            print()
            print()

            for iter in c.itermonthdays3(2019, 11):
                print(iter, end=" ")

            print()
            print()

            for iter in c.itermonthdays4(2019, 11):
                print(iter, end=" ")

        output:

            (0, 0) (0, 1) (0, 2) (0, 3) (1, 4) (2, 5) (3, 6) (4, 0) (5, 1) (6, 2) (7, 3) (8, 4) (9, 5) (10, 6) (11, 0) (12, 1) (13, 2) (14, 3)
                (15, 4) (16, 5) (17, 6) (18, 0) (19, 1) (20, 2) (21, 3) (22, 4) (23, 5) (24, 6) (25, 0) (26, 1) (27, 2) (28, 3) (29, 4) (30, 5)
                (0, 6)

            (2019, 10, 28) (2019, 10, 29) (2019, 10, 30) (2019, 10, 31) (2019, 11, 1) (2019, 11, 2) (2019, 11, 3) (2019, 11, 4) (2019, 11, 5)
                (2019, 11, 6) (2019, 11, 7) (2019, 11, 8) (2019, 11, 9) (2019, 11, 10) (2019, 11, 11) (2019, 11, 12) (2019, 11, 13) (2019, 11, 14)
                (2019, 11, 15) (2019, 11, 16) (2019, 11, 17) (2019, 11, 18) (2019, 11, 19) (2019, 11, 20) (2019, 11, 21) (2019, 11, 22)
                (2019, 11, 23) (2019, 11, 24) (2019, 11, 25) (2019, 11, 26) (2019, 11, 27) (2019, 11, 28) (2019, 11, 29) (2019, 11, 30)
                (2019, 12, 1)

            (2019, 10, 28, 0) (2019, 10, 29, 1) (2019, 10, 30, 2) (2019, 10, 31, 3) (2019, 11, 1, 4) (2019, 11, 2, 5) (2019, 11, 3, 6)
                (2019, 11, 4, 0) (2019, 11, 5, 1) (2019, 11, 6, 2) (2019, 11, 7, 3) (2019, 11, 8, 4) (2019, 11, 9, 5) (2019, 11, 10, 6)
                (2019, 11, 11, 0) (2019, 11, 12, 1) (2019, 11, 13, 2) (2019, 11, 14, 3) (2019, 11, 15, 4) (2019, 11, 16, 5) (2019, 11, 17, 6)
                (2019, 11, 18, 0) (2019, 11, 19, 1) (2019, 11, 20, 2) (2019, 11, 21, 3) (2019, 11, 22, 4) (2019, 11, 23, 5) (2019, 11, 24, 6)
                (2019, 11, 25, 0) (2019, 11, 26, 1) (2019, 11, 27, 2) (2019, 11, 28, 3) (2019, 11, 29, 4) (2019, 11, 30, 5) (2019, 12, 1, 6)

162) monthdays2calendar()
        calendar docs: https://docs.python.org/3/library/calendar.html
        takes year & month, returns a list of weeks in a specific month, each week is a tuple consisting of day numbers and weekday numbers
        
        code:

            import calendar  

            c = calendar.Calendar()

            for data in c.monthdays2calendar(2020, 12):
                print(data)

            print()

            cal = calendar.TextCalendar()
            print(cal.formatmonth(2019, 11))

    output:

            [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]
            [(7, 0), (8, 1), (9, 2), (10, 3), (11, 4), (12, 5), (13, 6)]
            [(14, 0), (15, 1), (16, 2), (17, 3), (18, 4), (19, 5), (20, 6)]
            [(21, 0), (22, 1), (23, 2), (24, 3), (25, 4), (26, 5), (27, 6)]
            [(28, 0), (29, 1), (30, 2), (31, 3), (0, 4), (0, 5), (0, 6)]

            November 2019
            Mo Tu We Th Fr Sa Su
                        1  2  3
            4  5  6  7  8  9 10
            11 12 13 14 15 16 17
            18 19 20 21 22 23 24
            25 26 27 28 29 30

163) Project: LAB: the calendar module

        my code:

            import calendar

            class MyCalendar(calendar.Calendar):
                def count_weekday_in_year(self, year, weekday):
                    data, self.sum  = calendar.Calendar(), 0

                    for month in range(1, 13):
                        for line in data.monthdays2calendar(year, month):
                            if list(line[weekday])[0] != 0: self.sum += 1

                def __str__(self):
                    return str(self.sum)

            object = MyCalendar()
            object.count_weekday_in_year(2000, 6)
            print(object)

        output:

            import calendar

            class MyCalendar(calendar.Calendar):
                def count_weekday_in_year(self, year, weekday):
                    current_month = 1
                    number_of_days = 0
                    while (current_month <= 12):
                        for data in self.monthdays2calendar(year, current_month):
                            if data[weekday][0] != 0:
                                number_of_days = number_of_days + 1

                        current_month = current_month + 1
                    return number_of_days

            my_calendar = MyCalendar()
            number_of_days = my_calendar.count_weekday_in_year(2019, calendar.MONDAY)

            print(number_of_days)



----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------






1.4.1.18
Where does the name "The Cheese Shop" come from?
    It's a reference to an old Monty Python's sketch of the same name.
Why should I ensure which one of pip and pip3 works for me?
    When Python 2 and Python 3 coexist in your OS, it's likely that pip identifies the instance of pip working with Python 2 packages only.
How can I determine if my pip works with either Python 2 or Python 3?
    pip --version will tell you that.
Unfortunately, I don't have administrative right. What should I do to install a package system-wide?
    You have to ask your sysadmin - don't try to hack your OS!

4.3.1.18
What do we expect from the readlines() method when the stream is associated with an empty file?
    An empty list (a zero-length list).</code></pre>
                            <div class="button-container">
                                <button class="see-more-btn" onclick="showModal(this)">
                                    <i class="language-icon more"></i>
                                    See More
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://github.com/arubbinali/docs/blob/main/Python%20Institute/PCAP/PCAP.py', '_blank')">
                                    <i class="language-icon github"></i>
                                    GitHub
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://arubbinali.github.io/Certifications.html#pcap-cert', '_blank')">
                                    <i class="language-icon certification"></i>
                                    View Certification
                                </button>
                            </div>
                        </div>
                    </div>

                    <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;6,257 lines (4,581 loc)</h5>

                </section>
                </div>

                <!-- PCEP -->
                <div id="pcep-docs">
                <section class="info-section">
                    <h2 class="project-heading">PCEPâ¢ â Certified Entry-Level Python Programmer</h2>
                    <div class="code-snippet">
                        <div class="code-snippet-header">
                            <h5 class="code-snippet-title">
                                <div class="code-language">
                                    <i class="language-icon python"></i>
                                </div>
                                PCEP.py
                            </h5>
                            <button class="code-snippet-toggle">+</button>
                        </div>
    
                        <div class="code-snippet-content">
                            
                            <pre class="code-snippet-code"><code class="language-python">Ø¨Ø³Ù Ø§ÙÙÙ Ø§ÙØ±Ø­ÙØ§Ù Ø§ÙØ±Ø­ÙÙ

------------------------------

1) end="" > To prevent output in next line
    1) Type anything between "" to join 2 lines with that text

2) \n > Next line

3) sep="" > print gives gaps by default
    1) Seperate elements

4) Underscore > Ease in representing numbers
    1) 105_007 Views > Underscores used instead of commas in numbers

5) 0O/0o/zero-o > Octal values start with these prefixes, digits taken from the [0..7] range only

6) 0X/0x/zero-x > Hexadecimal numbers start with these prefixes

7) E/e > Exponent
    1) 3e8 = 3E8 = 3 * 10^8
    2) 3E8 = 300000000.0
    3) 4e2 = 400.0

8) \ > Escape character
    1) print("Me \"Arub\"") = Me "Arub"
    2) print('Me "Arub"') = Me "Arub"
    3) print("Me 'Arub'") = Me 'Arub'

9) +, -, *, /, //, %, ** > Basic Operators
    1) +   > Addition 
    2) -   > Subtraction
    3) *   > Multiplication
    4) /   > Division
        1) 6 / 3 = 2.0
        2) 6 / 3. = 2.0
        3) 6. / 3 = 2.0
        4) 6. / 3. = 2.0

    5) //  > DIV > Integer result
        1) 6 // 3 = 2
        2) 6 // 3. = 2.0
        3) 6. // 3 = 2.0
        4) 6. // 3. = 2.0
        5) 6 // 4 = 1
        6) 6. // 4 = 1.0
        7) Negative Values effect results by rounding as shown below
        8) -6 // 4 = -2 
        9) 6. // -4 = -2.0

    6) %   > Modulo > Remainder
        1) Left sided binding
        2) 9 % 6 % 2 = 1

    7) **  > Exponentiation
        1) 2 ** 3 = 8
        2) 2 ** 3. = 8.0
        3) 2. ** 3 = 8.0
        4) 2. ** 3. = 8.0
        5) Right sided binding

10) A unary operator is an operator with only one operand
    1) -1
    2) +3

11) A binary operator is an operator with two operands
    1) 4 + 5
    2) 12 % 5

12) Variable Names
    1) Upper-case or lower-case letters, digits, and the character _ (underscore)
    2) Begin with a letter
    3) Underscore character is a letter
    4) Upper- and lower-case letters are treated as different
    5) Must not be any of Python's reserved words

13) Invalid Variable Names
    ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class',
        'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for',
        'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal',
        'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

14) Powers & Incrementation
    1) variable = variable op expression
    2) variable op= expression
        1) x = x * 2               â    x *= 2
        2) x = x + 1               â    x += 1
        3) i = i + 2 * j           â    i += 2 * j
        4) var = var / 2           â    var /= 2
        5) rem = rem % 10          â    rem %= 10
        6) j = j - (i + var + rem) â    j -= (i + var + rem)
        7) x = x ** 2              â    x **= 2

15) Round (Decimal Points)
    1) round(23.834,1) = 23.8
    2) round(23.289405,3) = 23.289

16) CTRL + / > Hash all lines to comment

17) type() > Tells the type of data

18) = > assignment operator

19) == > comparison operator

20) != > not equals to

21) Priority	Operator	
        1	+, -	            unary
        2	**	                unary
        3	*, /, //, %	        unary
        4	+, -	            binary
        5	<, <=, >, >=	    binary
        6	==, !=	            binary
22)  Indentation > 1 Tab click = 4 Space clicks

23) If & Else

24) Elif 

25) max() > Find largest number

26) min() > Find smallest number

27) While loop
    1) while True > Is an infinite or endless loop
    2) Break by CTRL + C or CTRL + BREAK
    3) while number > For e.g number is input, while will stop loop if number = 0

28) For loop

29) Syntactic candy/syntactic sugar > Additions that simply the work

30) break > exits the loop immediately
    1) break - example

        print("The break instruction:")
        for i in range(1, 6):
            if i == 3:
                break
            print("Inside the loop.", i)
        print("Outside the loop.")

31) continue > behaves as if the program has suddenly reached the end of the body
    1) continue - example

        print("\nThe continue instruction:")
        for i in range(1, 6):
            if i == 3:
                continue
            print("Inside the loop.", i)
        print("Outside the loop.")

32) While & Else

33) For & Else

34) Conjuction > and

35) Disjunction > or

36) Logical operators > and, or, not

37) Bitwise operators
        1) & (ampersand) - bitwise conjunction;    AND
                1) & Does a bitwise and, e.g., x & y = 0, which is 0000 0000 in binary
                2) i = 15
                3) j = 22
                4) i:                      00000000000000000000000000001111
                5) j:                      00000000000000000000000000010110
                6) bit = i & j         =   00000000000000000000000000000110    =   6
                7) log = i and j       =   log : True 

        2) | (bar) - bitwise disjunction;          OR
                1) | Does a bitwise or, e.g., x | y = 31, which is 0001 1111 in binary

        3) ~ (tilde) - bitwise negation;           NOT
                1) Does a bitwise not, e.g., ~ x = 240*, which is 1111 0000 in binary
                2) logneg = not i
                3) bitneg = ~i
                4) i	                    00000000000000000000000000001111
                5) bitneg = ~i	            11111111111111111111111111110000
                6) Therefore: i = -16

        4) ^ (caret) - bitwise exclusive or (xor) XOR
                1) ^ Does a bitwise xor, e.g., x ^ y = 31, which is 0001 1111 in binary
        
    SUMMARY (IMPORTANT)
            In the table below: Let x = 10 (0000 1010 in binary) and y = 4 (0000 0100 in binary)

            Operator	    Meaning	Example
                &	        Bitwise AND	            x & y = 0 (0000 0000)
                |	        Bitwise OR	            x | y = 14 (0000 1110)
                ~	        Bitwise NOT	            ~x = -11 (1111 0101)
                ^	        Bitwise XOR	            x ^ y = 14 (0000 1110)
                >>	        Bitwise right shift	    x >> 2 = 2 (0000 0010)
                <<	        Bitwise left shift	    x << 2 = 40 (0010 1000)

38) Abbreviated form
        x = x & y	x &= y
        x = x | y	x |= y
        x = x ^ y	x ^= y

39) Binary left shift >     <<
        << Does a bitwise left shift, e.g., y << 3 = , which is 1000 0000 in binary
        Shifting a value one bit to the left thus corresponds to multiplying it by two
        17 << 2 = 68

40) Binary right shift >    >>
        >> Does a bitwise right shift, e.g., y >> 1 = 8, which is 0000 1000 in binary
        Shifting one bit to the right is like dividing by two
        17 >> 1 = 8 (Integer Division)

41) Updated priority table
    Priority	Operator	
        1)	~, +, -	unary
        2)	**	
        3)	*, /, //, %	
        4)	+, -	binary
        5)	<<, >>	
        6)	<, <=, >, >=	
        7)	==, !=	
        8)	&	
        9)	|	
        10	=, +=, -=, *=, /=, %=, &=, ^=, |=, >>=, <<=

42) Lists
        1) Consists of elements
        2) Can be scalar

43) Indexing > The operation of selecting an element from the list

44) len() > Length of a list or string

45) del > Deletes elements in a list
        1) If used to delete the entire list, it deletes the list itself, not its content
        2) del my_list[:] >     OUTPUT = []

46) Negative indices
        1) -1 > Last element

47) Functions vs Methods
    1) Function doesn't belong to any data, it gets data, may create new data, then outputs it
        A method does all these things, but is also able to change the internal state of a selected entity

    2)  function is owned by the whole code
        A method is owned by the data it works for

    3) A typical function invocation may look like this
            result = function(arg)
            The function takes an argument, does something, and returns a result
        A typical method invocation usually looks like this:
            result = data.method(arg)
                1) Name of the data which owns the method
                2) Dot
                3) Method name
                4) A pair of parenthesis enclosing the arguments

48) append() > To glue a new element in the end of a list
        1) list.append(value)

49) insert() > To add a new element at any place in the list
        1) list.insert(location, value)

50) Swapping values of 2 variables
        1) Right value is assigned to left, however, both have the same value in the end
        2)  a = 1
            b = 2

            auxiliary = a
            a = b
            b = auxiliary
        3)  An easier method
                a = 1
                b = 2

                a, b = b, a

51) The bubble sort
        1)  On site:
            my_list = [8, 10, 6, 2, 4]  # list to sort
            swapped = True  # It's a little fake, we need it to enter the while loop.

            while swapped:
                swapped = False  # no swaps so far
                for i in range(len(my_list) - 1):
                    if my_list[i] > my_list[i + 1]:
                        swapped = True  # a swap occurred!
                        my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]

            print(my_list)

        2) Mine:
            list = [2, 4, 1, 5, 9, 11, 3, 93, 24, 82]
            swap = True
            while swap:
                swap = False
                for x in range((len(list) - 1)):
                    if list[x] > list[x + 1]:
                        list[x], list[x + 1] = list[x + 1], list[x]
                        swap = True
            print(list)

52) sort() > To sort elements in a list

53) reverse() > To reverse the elements in a list

54) A variable is the name of it's content
    A lists name is the name of the memory location where the list is stored
        1)  list_1 = [1]
            list_2 = list_1
            list_1[0] = 2
            print(list_2)

            OUTPUT = [2]
        2)  var_1 = 1
            var_2 = var_1
            var_1 = 2
            print(var_2)

            OUTPUT = 1

55) Slices > Copying an entire list or parts of a list

        1)  list[start:end]
            start is the index of the first element included in the slice
            end is the index of the first element not included in the slice

        2)  list[start:end] = list[:end] = list[0:end]
            list[:end] = list[:len(list)]

56) in & not in > Checks if a certain element is in a list and returns boolean

        1)  my_list = [0, 3, 12, 8, 2]

            print(5 in my_list)
            print(5 not in my_list)
            print(12 in my_list)

            OUTPUT = False, True, True

57) List comprehension

        1)  Allows you to create new lists from existing ones in a concise and elegant way
            Created on-the-fly during program execution, and is not described statically

        2) Syntax
            1)  [expression for element in list if conditional]
            2)  for element in list:
                if conditional:
                    expression

        3) Examples
            1) row = [WHITE_PAWN for i in range(8)]
            2) squares = [x ** 2 for x in range(10)]
            3) twos = [2 ** i for i in range(8)]
            4) odds = [x for x in squares if x % 2 != 0]

58) 2D Arrays

        1) A four-column/four-row table - a two dimensional array (4x4)

            table = [[":(", ":)", ":(", ":)"],
                    [":)", ":(", ":)", ":)"],
                    [":(", ":)", ":)", ":("],
                    [":)", ":)", ":)", ":("]]

            print(table)
            print(table[0][0])  # outputs: ':('
            print(table[0][3])  # outputs: ':)'

        2) Example of Chess board
            1)  board = [[EMPTY for i in range(8)] for j in range(8)]
                EQUALS:
                for j in range(8):
                    for i in range(8):
                        EMPTY

            2)  Printing an empty board

                EMPTY = "-"
                ROOK = "ROOK"
                board = []

                for i in range(8):
                    row = [EMPTY for i in range(8)]
                    board.append(row)
                print(board)

            3)  Printing the 4 ROOKS

                EMPTY = "-"
                ROOK = "ROOK"
                board = []

                for i in range(8):
                    row = [EMPTY for i in range(8)]
                    board.append(row)
                
                board[0][0] = ROOK
                board[0][7] = ROOK
                board[7][0] = ROOK
                board[7][7] = ROOK

                print(board)

            4)  To find any element of a two-dimensional list, you have to use two coordinates:

                    1)  A vertical one (row number)
                    2)  A horizontal one (column number)

59) 3D Arrays

        1) Cube - a three-dimensional array (3x3x3)

            cube = [[[':(', 'x', 'x'],
                    [':)', 'x', 'x'],
                    [':(', 'x', 'x']],

                    [[':)', 'x', 'x'],
                    [':(', 'x', 'x'],
                    [':)', 'x', 'x']],

                    [[':(', 'x', 'x'],
                    [':)', 'x', 'x'],
                    [':)', 'x', 'x']]]

            print(cube)
            print(cube[0][0][0])  # outputs: ':('
            print(cube[2][2][0])  # outputs: ':)'

        2) Example of 3 buildings with 15 floors each with 20 rooms on each floor

            1) Assigning all rooms as False (Meaning vacant)
                rooms = [[[False for r in range(20)] for f in range(15)] for t in range(3)]

            2) Now you can book a room for two newlyweds: in the 2nd building, on the 10th floor, room 14:
                rooms[1][9][13] = True

            3) Release the second room on the fifth floor located in the first building:
                rooms[0][4][1] = False

            4) Check if there are any vacancies on the 15th floor of the third building:
                vacency = 0

                for room_number in range(20):
                    if not rooms[2][14][room_number]:
                        vacency += 1

60) Functions
        1) Syntax
            
            def function_name():
                function_body
                    
        2) To run it

            function_name()

        3) Types of functions:
            
            1) Built-in functions
                Example: print()
            
            2) Pre-installed modules

            3) user-defined functions

            4) Lambda functions
            
61) Parameterized functions

        1) Syntax

            def function(parameter):
                ###
            
        2)  Parameters live inside functions (this is their natural environment)
            Arguments exist outside functions, and are carriers of values passed to corresponding parameters

        3)  Example:
                def message(number):
                    print("Enter a number:", number)
                message(534)

                OUTPUTS Enter a number: 534

        4)  Positional parameter passing
                A technique which assigns the ith (first, second, and so on) argument to
                the ith (first, second, and so on) function parameter  

            Example:
                def my_function(a, b, c):
                    print(a, b, c)

                my_function(1, 2, 3)

        5)  Default (predefined) values
                1) Default values are taken into consideration when their corresponding arguments have been omitted

                2) Example:
                    def introduction(first_name, last_name="Smith"):
                        print("Hello, my name is", first_name, last_name)
                    introduction("Arub")
                    introduction("Arub", "Ali")

62) Keyword argument passing (Functions)
        1) The meaning of the argument is dictated by its name, not by its position

        2)  Example:
                def introduction(first_name, last_name):
                    print("Hello, my name is", first_name, last_name)

                introduction(first_name = "James", last_name = "Bond")
                introduction(last_name = "Skywalker", first_name = "Luke")

        3) A non-default argument (c) can not follow a default argument (b=2)!

        4)  Example:
                def add_numbers(a, b=2, c):
                    print(a + b + c)
                add_numbers(a=1, c=3)

                def add_numbers(a, b=2, c=1):
                    print(a + b + c)
                add_numbers(a=1, c=3)


63) return
        1) A python keyword to get functions to return a value

        2) Return without an expression
            1)  When used inside a function, it causes the immediate termination of the function's execution,
                and an instant return (hence the name) to the point of invocation.

            2)  Example:
                    def happy_new_year(wishes = True):
                        print("Three...")
                        print("Two...")
                        print("One...")
                        if not wishes:
                            return
                        
                        print("Happy New Year!")
                    
                ************************************************************************************************
                        When invoked without any arguments:

                            happy_new_year()

                        OUTPUT:

                            Three...
                            Two...
                            One...
                            Happy New Year!

                ************************************************************************************************
                        Providing False as an argument:

                            happy_new_year(False)

                        OUTPUT:

                            Three...
                            Two...
                            One...
                            
        3) Return with an expression
            1)  causes the immediate termination of the function's execution (nothing new compared to the first variant)
                Will evaluate the expression's value and will return (the name once again) it as the function's result
            
            
            2)  Example:
                    def function():
                        return expression

            3)  Example:
                    def boring_function():
                        return 123
                    x = boring_function()

                    print("The boring_function has returned its result. It's:", x)

                    OUTPUT: The boring_function has returned its result. It's: 123

            4)  Example:
                    def boring_function():
                        print("a")
                        return 123

                    print("b")
                    boring_function()
                    print("c")

                    OUTPUT: 
                        b
                        a
                        c

64) None

        1)  There are only two kinds of circumstances when None can be safely used:
                1) when you assign it to a variable (or return it as a function's result)
                2) when you compare it with a variable to diagnose its internal state.

        2)  Example:
                value = None
                if value is None:
                    print("Sorry, you don't carry any value")

        3)  If a function doesn't return a certain value using a return expression clause, it is assumed that it implicitly returns None            

        4)  Example:
                def strange_function(n):
                    if(n % 2 == 0):
                        return True

                strange_function(5)         #OUTPUT: (NOTHING)

                print(strange_function(4))  #OUTPUT: True
                print(strange_function(5))  #OUTPTU: None

65) Lists in Functions

    1) A list can be sent to a function as an argument:

            def num_sum(listx):
            sumx = 0

            for element in listx:
                sumx += element
            return sumx

            print(num_sum([1, 1, 1, 1, 1, 1, 1, 1]))



                

    2) A list can be a function result:

            def strange_list_fun(n):
                strange_list = []
                
                for i in range(0, n):
                    strange_list.insert(0, i)
                
                return strange_list

            print(strange_list_fun(5))

            OUTPUT: [4, 3, 2, 1, 0]

66) Days in a year:
        def is_year_leap(year):
            if year % 400 == 0:
                return True
            elif year % 100 == 0:
                return False
            elif year % 4 == 0:
                return True
            else:
                return False

        def days_in_month(year, month):
            if month in (1, 3, 5, 7, 8, 10, 12):
                return 31
            elif month in (4, 6, 9, 11):
                return 30
            elif month == 2:
                if is_year_leap(year):
                    return 29
                else:
                    return 28

        def day_of_year(year, month, day):
            days = day
            for m in range(1, month):
                days += days_in_month(year, m)
            return days
        print(day_of_year(2000, 12, 31))

67) Prime numbers
        def is_prime(num):
            prime = 0
            if num <= 1:
                return False
            for x in range(1, num + 1):
                check = num % x
                if check == 0:
                    prime += 1
                if prime > 2:
                    return False
            return True

        for i in range(1, 20):
            if is_prime(i + 1):
                    print(i + 1, end=" ")
        print()

68) Liters per 100km to miles per gallons & vice versa
        def liters_100km_to_miles_gallon(liters):   #EU
            y =  62.137119224 / (liters / 3.785411784)
            return y

        def miles_gallon_to_liters_100km(miles):    #US
            y = (3.785411784 / miles) * 62.137119224
            return y


        print(liters_100km_to_miles_gallon(3.9))
        print(liters_100km_to_miles_gallon(7.5))
        print(liters_100km_to_miles_gallon(10.))
        print(miles_gallon_to_liters_100km(60.3))
        print(miles_gallon_to_liters_100km(31.4))
        print(miles_gallon_to_liters_100km(23.5))

69) Functions and Scopes
        1)  Scope > The scope of a name (e.g., a variable name) is the part of a code where the name is properly recognizable 
                A variable existing outside a function has a scope inside the functions' bodies
                Excluding those of them which define a variable of the same name
                It also means that the scope of a variable existing outside a function is supported only when getting its value(reading)
                Assigning a value forces the creation of the function's own variable

        2)  Example:
                def scope_test():
                    x = 123
                scope_test()
                print(x)

            OUTPUT: x aint defined
            
        3)  Example:
                def my_function():
                    print("Do I know that variable?", var)
                var = 1
                my_function()
                print(var)
            
            OUTPUT: DO I know that variable? 1

        4)  Example:
                def my_function():
                    var = 2
                    print("Do I know that variable?", var)
                var = 1
                my_function()
                print(var)
                
            OUTPUT: Do I know that variable? 2
                    1
        
70) global > Extends a variable's scope in a way which includes the functions' bodies
        
        1)  Example:
                def my_function():
                    global var
                    var = 2
                    print("Do I know that variable?", var)
                var = 1
                my_function()
                print(var)
        
            OUTPUT: Do I know that variable? 2
                    2
71) A function receives the argument's value, not the argument itself
        1)  Example:
                def my_function(my_list_1):
                    print("Print #1:", my_list_1)
                    print("Print #2:", my_list_2)
                    my_list_1 = [0, 1]
                    print("Print #3:", my_list_1)
                    print("Print #4:", my_list_2)
                my_list_2 = [2, 3]
                my_function(my_list_2)
                print("Print #5:", my_list_2)
        
            OUTPUT: Print #1: [2, 3]
                    Print #2: [2, 3]
                    Print #3: [0, 1]
                    Print #4: [2, 3]
                    Print #5: [2, 3]
        
        2)  Example:
                def my_function(my_list_1):
                    print("Print #1:", my_list_1)
                    print("Print #2:", my_list_2)
                    del my_list_1[0]  # Pay attention to this line.
                    print("Print #3:", my_list_1)
                    print("Print #4:", my_list_2)
                my_list_2 = [2, 3]
                my_function(my_list_2)
                print("Print #5:", my_list_2)
        
            OUTPUT: Print #1: [2, 3]
                    Print #2: [2, 3]
                    Print #3: [3]
                    Print #4: [3]
                    Print #5: [3]
        
72) Evaluating BMI

        def ft_and_inch_to_m(ft, inch = 0.0):
            return ft * 0.3048 + inch * 0.0254


        def lb_to_kg(lb):
            return lb * 0.45359237


        def bmi(weight, height):
            if height < 1.0 or height > 2.5 or weight < 20 or weight > 200:
                return None
            
            return weight / height ** 2


        print(bmi(weight = lb_to_kg(176), height = ft_and_inch_to_m(5, 7)))
            
73) Backslash(\) > To continue the line of code in the next line of code

74) Can three sides of given lengths build a triangle?
    (The sum of the lengths of any two sides of a triangle must always be greater than the length of the remaining side)

        Program 1:

            def is_a_triangle(a, b, c):
                if a + b <= c:
                    return False
                if b + c <= a:
                    return False
                if c + a <= b:
                    return False
                return True

        Program 2:

            def is_a_triangle(a, b, c):
                if a + b <= c or b + c <= a or c + a <= b:
                    return False
                return True
                
        Program 3:

            def is_a_triangle(a, b, c):
                return a + b > c and b + c > a and c + a > b
        
75) Pythagorean theorem:

        def is_a_triangle(a, b, c):
            return a + b > c and b + c > a and c + a > b


        def is_a_right_triangle(a, b, c):
            if not is_a_triangle(a, b, c):
                return False
            if c > a and c > b:
                return c ** 2 == a ** 2 + b ** 2
            if a > b and a > c:
                return a ** 2 == b ** 2 + c ** 2


        print(is_a_right_triangle(5, 3, 4))
        print(is_a_right_triangle(1, 3, 4))
        
76) A triangle's area (Heron's formula)

        def is_a_triangle(a, b, c):
            return a + b > c and b + c > a and c + a > b


        def heron(a, b, c):
            p = (a + b + c) / 2
            return (p * (p - a) * (p - b) * (p - c)) ** 0.5


        def area_of_triangle(a, b, c):
            if not is_a_triangle(a, b, c):
                return None
            return heron(a, b, c)


        print(area_of_triangle(1., 1., 2. ** .5))
        
77) Factorials
        
        def factorial_function(n):
            if n < 0:
                return None
            if n < 2:
                return 1
            
            product = 1
            for i in range(2, n + 1):
                product *= i
            return product


        for n in range(1, 6):  # testing
            print(n, factorial_function(n))

78) Fibonacci numbers
        (Fibi = Fibi-1 + Fibi-2)
        fib_1 = 1
        fib_2 = 1
        fib_3 = 1 + 1 = 2
        fib_4 = 1 + 2 = 3
        fib_5 = 2 + 3 = 5
        fib_6 = 3 + 5 = 8
        fib_7 = 5 + 8 = 13

        def fib(n):
            if n < 1:
                return None
            if n < 3:
                return 1

            elem_1 = elem_2 = 1
            the_sum = 0
            for i in range(3, n + 1):
                the_sum = elem_1 + elem_2
                elem_1, elem_2 = elem_2, the_sum
            return the_sum


        for n in range(1, 10):  # testing
            print(n, "->", fib(n))

79) Recursion
        A technique where a function invokes itself

        1)  Factorials
                def factorial_function(n):
                    if n < 0:
                        return None
                    if n < 2:
                        return 1
                    return n * factorial_function(n - 1)

            *** Negative factorials (By me, not tested!)

                    def factorial_function(n):
                        if n == 0:
                            return 1
                        return n * factorial_function(n + 1)

                    print(factorial_function(-5))

        2)  Fibonacci numbers
                def fib(n):
                    if n < 1:
                        return None
                    if n < 3:
                        return 1
                    return fib(n - 1) + fib(n - 2)

80) Sequence
        Data which can be scanned by the for loop

81) Mutability
        1) Mutable
            Mutable data can be freely updated at any time
                E.g list.append(1)

        2) Immutable
            Immutable data cannot be modified in this way
            These are tuples

82) Tuples
        1) An immutable sequence type
        2) Prefer to use parenthesis
        3) Also possible to create a tuple just from a set of values separated by commas


            tuple_1 = (1, 2, 4, 8)
            tuple_2 = 1., .5, .25, .125

            print(tuple_1)
            print(tuple_2)

                This is what you should see in the console:

                (1, 2, 4, 8)
                (1.0, 0.5, 0.25, 0.125)

        4) Each tuple element may be of a different type (floating-point, integer, or any other not-as-yet-introduced kind of data)
        5) Empty tuple
            1) A pair of empty parenthesis
                empty_tuple = ()

        6) One-element tuple
            1) The value must end with a comma due to syntax reasons
            2) Otherwise it'll be a variable instead of a tuple

                one_element_tuple_1 = (1, )
                one_element_tuple_2 = 1.,

        7) How to use a tuple

                my_tuple = (1, 10, 100, 1000)

                print(my_tuple[0])
                print(my_tuple[-1])
                print(my_tuple[1:])
                print(my_tuple[:-2])

                for elem in my_tuple:
                    print(elem)
        
        8) All these are not valid and will give an error

                my_tuple = (1, 10, 100, 1000)

                my_tuple.append(10000)
                del my_tuple[0]
                my_tuple[1] = -10

        9) All these are allowed:
            1) +
            2) *
            3) len
            4) in
            5) not in


                my_tuple = (1, 10, 100)

                t1 = my_tuple + (1000, 10000)
                t2 = my_tuple * 3

                print(len(t2))
                print(t1)
                print(t2)
                print(10 in my_tuple)
                print(-10 not in my_tuple)

        10) A tuples elements can be variables
            1) Values stored "circulate". t1 becomes t2, t2 becomes t3 and t3 becomes t1

                var = 123

                t1 = (1, )
                t2 = (2, )
                t3 = (3, var)

                t1, t2, t3 = t2, t3, t1

                print(t1, t2, t3)

        11) tuple() > Create a tuple / Convert a data type to a tuple

        12) Unpacking of a tuple:

                tup = 1, 2, 3
                a, b, c = tup
                print(a * b * c)

            OUTPUT:

                6

83) Dictonaries
        1) A data strcutre, not a sequence
        2) Mutable
        3) The word you look for is named a key
        4) The word you get from the dictionary is called a value
        5) Bilingual
        6) Key must be unique
        7) Key may be any immutable type of object
        8) len() in dictionaries returns the numbers of key-value elements in the dictionary
        9) A one-way tool (value from keys, not keys from values)

                dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                phone_numbers = {'boss': 5551234567, 'Suzy': 22657854310}
                empty_dictionary = {}

                print(dictionary)
                print(phone_numbers)
                print(empty_dictionary)
            
        10) Hanging indent:

                dictionary = {
                            "cat": "chat",
                            "dog": "chien",
                            "horse": "cheval"
                            }

                phone_numbers = {'boss': 5551234567,
                                'Suzy': 22657854310
                                }

        11) list() > Create a list / Convert a data type to a list

        12) keys() > Returns an iterable object consisting of all the keys gathered within the dictionary
                
                        dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                        for key in dictionary.keys():
                            print(key, "->", dictionary[key])

                    OUTPUT:

                        horse -> cheval
                        dog -> chien
                        cat -> chat

        13) sorted() > To sort the output 

                        for key in sorted(dictionary.keys()):
                        
                        (I think its already sorted hmm)

        14) items() > Returns tuples where each tuple is a key-value pair

                        dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                        for english, french in dictionary.items():
                            print(english, "->", french)

                    OUTPUT:

                        cat -> chat
                        dog -> chien
                        horse -> cheval
                
        15) values() > Returns values

                        dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                        for french in dictionary.values():
                            print(french)

                    OUTPUT:

                        cheval
                        chien
                        chat
            
        16) Modifying and adding values to dictionaries
                1) Fully mutable
                2) 
                        dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                        dictionary['cat'] = 'minou'
                        print(dictionary)

                    OUTPUT:

                        {'cat': 'minou', 'dog': 'chien', 'horse': 'cheval'}

                3) Adding a new key
                        Assign a value to a new, previously non-existent key

                            dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                            dictionary['swan'] = 'cygne'
                            print(dictionary)

                        OUTPUT:

                            {'cat': 'chat', 'dog': 'chien', 'horse': 'cheval', 'swan': 'cygne'}

                4) update() > You can also insert an item to a dictionary

                            dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                            dictionary.update({"duck": "canard"})
                            print(dictionary)

                        OUTPUT: 

                            {'cat': 'chat', 'dog': 'chien', 'horse': 'cheval', 'duck': 'canard'}

                5) del > Removing a key
                            
                            dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                            del dictionary['dog']
                            print(dictionary)

                        OUTPUT:

                            {'cat': 'chat', 'horse': 'cheval'}

                6) clear() > Remove all the dictionary's items, NOT THE DICTIONARY!

                7) popitem() > To remove the last item in a dictionary

                            dictionary = {"cat": "chat", "dog": "chien", "horse": "cheval"}
                            dictionary.popitem()
                            print(dictionary)
                            
                        OUTPUT:
                            
                            {'cat': 'chat', 'dog': 'chien'}

                8) Average score of each student

                            school_class = {}

                            while True:
                                name = input("Enter the student's name: ")
                                if name == '':
                                    break
                                
                                score = int(input("Enter the student's score (0-10): "))
                                if score not in range(0, 11):
                                    break
                                
                                if name in school_class:
                                    school_class[name] += (score,)
                                else:
                                    school_class[name] = (score,)
                                    
                            for name in sorted(school_class.keys()):
                                adding = 0
                                counter = 0
                                for score in school_class[name]:
                                    adding += score
                                    counter += 1
                                print(name, ":", adding / counter)

                9) get() > Get the value of a kwy from a dictionary

                            dict = {
                                "a" : "1",
                                "b" : "2"
                            }

                            item = dict.get("a")
                            print(item)

                        OUTPUT:

                            1

                10) copy() > Copy a dictionary

84) Exceptions
        1) is > Check if a value is of a specific data type
                type(value) is int > True/False
        2) Try-Except
                1) An exception is raised
                2) The try keyword marks the place where you try to do something without permission
                3) The except keyword starts a location where you can show off your apology talents

                    try:
                        value = int(input('Enter a natural number: '))
                        print('The reciprocal of', value, 'is', 1/value)        
                    except:
                        print('I do not know what to do.')    
                
                4) Two exceptions after one try
                    Only one of all branches can intercept the control - if one of the branches is executed,
                    all the other branches remain idle

                        try:
                            value = int(input('Enter a natural number: '))
                            print('The reciprocal of', value, 'is', 1/value)        
                        except ValueError:
                            print('I do not know what to do.')    
                        except ZeroDivisionError:
                            print('Division by zero is not allowed in our Universe.')

                5) The default exception
                    1) Last one
                    2) Should only be "except:"
                    3) Aka the default or generic exception

                        try:
                            value = int(input('Enter a natural number: '))
                            print('The reciprocal of', value, 'is', 1/value)        
                        except ValueError:
                            print('I do not know what to do.')    
                        except ZeroDivisionError:
                            print('Division by zero is not allowed in our Universe.')    
                        except:
                            print('Something strange has happened here... Sorry!')

                6)  Specify and handle multiple built-in exceptions within a single except clause

                        while True:
                            try:
                                number = int(input("Enter an int number: "))
                                print(5/number)
                                break
                            except (ValueError, ZeroDivisionError):
                                print("Wrong value or No division by zero rule broken.")
                            except:
                                print("Sorry, something went wrong...")

        3) Some useful exceptions
            1) ZeroDivisionError > Division in which the divider is zero
            2) ValueError > When a function like int() or str() recieves an unnaceptable value
            3) TypeError > When type of dadta is used which can't be accepted in the context

                    short_list = [1]
                    one_value = short_list[0.5]

            4) AttributeError > When a method which doesn't exist in an item is used

                    short_list = [1]
                    short_list.append(2)
                    short_list.depend(3)

                (Nothing known as depend)

            5) SyntaxError > Wrong syntax or errors in syntax/grammer of the python code
            6) KeyboardInterrupt > When the user hits the interrupt key (CTRL-C or Delete)

85) Bugs
    1) A debugger is used against a bug
    2) Debugging > The process during which bugs are removed from the code
    3) Using a debugger:
        1) The code can be executed line by line
        2) Variables' states can be inspected and values can be changed without modifying the source code
        3) Stop program execution when certain conditions are or aren't met
    4) Interactive debugging > Needs the developers interaction to be performed
        1)  print debugging 
                Insert several additional print() invocations inside your code to
                output data which illustrates the path your code is currently negotiating

86) Project: Tic Tac toe
"""



#Initial board
board = [
            ["1", "2", "3"],
            ["4", "X", "6"], 
            ["7", "8", "9"]
        ]

#User friendly row & column index
row = 0
column = 1

row -= 1
column -= 1

#Importing random library for computer's move
from random import randrange
#print(board[0][1])






def display_board(board):
    for x in range(3):
        print(board[x])




def enter_move(board):
    #User move
    user_move = str(input("Where would you spot an 'O'?   "))
    for row in range(3):
        for column in range(3):
            if user_move == board[row][column]:
                board[row][column] = "O"
    
    #Display board
    for x in range(3):
        print(board[x])



""""""

def make_list_of_free_fields(board):
    free_fields = []
    for row in range(3):
        for column in range(3):
            if board[row][column] != "O" and board[row][column] != "X":
                free_fields.append((row, column))
    print(free_fields)

    #Computer move
    computer_move_done = True
    while computer_move_done:
        computer_move_column = randrange(0, 3)
        computer_move_row = randrange(0, 3)
        computer_move_coordinates = (computer_move_column, computer_move_row)
        if computer_move_coordinates in free_fields and board[computer_move_row][computer_move_column] != "O":
            board[computer_move_row][computer_move_column] = "X"
            computer_move_done = False
    


    #Display board
    for x in range(3):
        print(board[x])






def victory_for(board, sign):
    # The function analyzes the board's status in order to check if 
    # the player using 'O's or 'X's has won the game
    sign = False
    for x in range(3):
        if board[x] == sign:
            sign = True
            print("True")
            return sign
            
            



display_board(board)
enter_move(board)
make_list_of_free_fields(board)
print()
display_board(board)
enter_move(board)
make_list_of_free_fields(board)
print(victory_for(board, "X"))
print()
display_board(board)
enter_move(board)
make_list_of_free_fields(board)
print(victory_for(board, "X"))
print()
display_board(board)
enter_move(board)
make_list_of_free_fields(board)
print(victory_for(board, "X"))
print()
display_board(board)
enter_move(board)
make_list_of_free_fields(board)
print(victory_for(board, "X"))
print()
display_board(board)
enter_move(board)
make_list_of_free_fields(board)
print(victory_for(board, "X"))
print()
"""
def draw_move(board):
    # The function draws the computer's move and updates the board.
"""
from random import randrange


def display_board(board):
    print("+-------" * 3,"+", sep="")
    for row in range(3):
        print("|       " * 3,"|", sep="")
        for col in range(3):
            print("|   " + str(board[row][col]) + "   ", end="")
        print("|")
        print("|       " * 3,"|",sep="")
        print("+-------" * 3,"+",sep="")


def enter_move(board):
    ok = False	# fake assumption - we need it to enter the loop
    while not ok:
        move = input("Enter your move: ") 
        ok = len(move) == 1 and move >= '1' and move <= '9' # is user's input valid?
        if not ok:
            print("Bad move - repeat your input!") # no, it isn't - do the input again
            continue
        move = int(move) - 1 	# cell's number from 0 to 8
        row = move // 3 	# cell's row
        col = move % 3		# cell's column
        sign = board[row][col]	# check the selected square
        ok = sign not in ['O','X'] 
        if not ok:	# it's occupied - to the input again
            print("Field already occupied - repeat your input!")
            continue
    board[row][col] = 'O' 	# set '0' at the selected square


def make_list_of_free_fields(board):
    free = []	# the list is empty initially
    for row in range(3): # iterate through rows
        for col in range(3): # iterate through columns
            if board[row][col] not in ['O','X']: # is the cell free?
                free.append((row,col)) # yes, it is - append new tuple to the list
    return free


def victory_for(board,sgn):
    if sgn == "X":	# are we looking for X?
        who = 'me'	# yes - it's computer's side
    elif sgn == "O": # ... or for O?
        who = 'you'	# yes - it's our side
    else:
        who = None	# we should not fall here!
    cross1 = cross2 = True  # for diagonals
    for rc in range(3):
        if board[rc][0] == sgn and board[rc][1] == sgn and board[rc][2] == sgn:	# check row rc
            return who
        if board[0][rc] == sgn and board[1][rc] == sgn and board[2][rc] == sgn: # check column rc
            return who
        if board[rc][rc] != sgn: # check 1st diagonal
            cross1 = False
        if board[2 - rc][2 - rc] != sgn: # check 2nd diagonal
            cross2 = False
    if cross1 or cross2:
        return who
    return None


def draw_move(board):
    free = make_list_of_free_fields(board) # make a list of free fields
    cnt = len(free)
    if cnt > 0:	# if the list is not empty, choose a place for 'X' and set it
        this = randrange(cnt)
        row, col = free[this]
        board[row][col] = 'X'


board = [ [3 * j + i + 1 for i in range(3)] for j in range(3) ] # make an empty board
board[1][1] = 'X' # set first 'X' in the middle
free = make_list_of_free_fields(board)
human_turn = True # which turn is it now?
while len(free):
    display_board(board)
    if human_turn:
        enter_move(board)
        victor = victory_for(board,'O')
    else:	
        draw_move(board)
        victor = victory_for(board,'X')
    if victor != None:
        break
    human_turn = not human_turn		
    free = make_list_of_free_fields(board)

display_board(board)
if victor == 'you':
    print("You won!")
elif victor == 'me':
    print("I won")
else:
    print("Tie!")</code></pre>
                            <div class="button-container">
                                <button class="see-more-btn" onclick="showModal(this)">
                                    <i class="language-icon more"></i>
                                    See More
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://github.com/arubbinali/docs/blob/main/Python%20Institute/PCEP/PCEP.py', '_blank')">
                                    <i class="language-icon github"></i>
                                    GitHub
                                </button>
                                <button class="see-more-btn" onclick="window.open('https://arubbinali.github.io/Certifications.html#pcep-cert', '_blank')">
                                    <i class="language-icon certification"></i>
                                    View Certification
                                </button>

                            </div>
                        </div>
                    </div>

                    <h5 class="code-snippet-title">Source code size:&nbsp;&nbsp;&nbsp;1,541 lines (1,139 loc)</h5>

                </section>
                </div>
                


            </div>
        </div>


























        <!-- Modal -->
        <div id="codeModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Source Code <span class="header-language"><i class="language-icon"></i>Python</span></h2>
                    <span class="close-modal">&times;</span>
                </div>
                <div class="modal-code-container">
                    <pre class="modal-code-wrapper"><code class="modal-code language-python"></code></pre>
                </div>
            </div>
        </div>










        <script>
            // Function to truncate code for preview
            function truncateCode(code, lines = 12) {
                const codeLines = code.split('\n');
                if (codeLines.length > lines) {
                    return codeLines.slice(0, lines).join('\n');
                }
                return code;
            }

            // Function to toggle code snippet visibility
            document.querySelectorAll('.code-snippet-header').forEach(header => {
                const content = header.nextElementSibling;
                const codeElement = content.querySelector('code');
                const fullCode = codeElement.textContent;
                
                // Store full code and set truncated preview
                codeElement.dataset.fullCode = fullCode;
                codeElement.textContent = truncateCode(fullCode);
                
                header.addEventListener('click', () => {
                    const toggle = header.querySelector('.code-snippet-toggle');
                    content.classList.toggle('expanded');
                    toggle.textContent = content.classList.contains('expanded') ? '-' : '+';
                });
            });

            // Function to format code with line numbers for modal
            function formatCodeWithLineNumbers(code) {
                const lines = code.split('\n');
                const totalLines = lines.length;
                const lineNumberWidth = totalLines.toString().length;
                
                return lines.map((line, index) => {
                    const lineNum = (index + 1).toString().padStart(lineNumberWidth, ' ');
                    return `<span class="code-line"><span class="line-number" style="width: ${lineNumberWidth}ch">${lineNum}&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="line-content">${line}</span></span>`;
                }).join('\n');
            }

            // Function to show modal with full code
            function showModal(button) {
                const modal = document.getElementById('codeModal');
                const codeBlock = button.closest('.code-snippet-content').querySelector('code');
                const code = codeBlock.dataset.fullCode;
                const modalCode = modal.querySelector('.modal-code');
                
                // Format code with line numbers
                modalCode.innerHTML = formatCodeWithLineNumbers(code);
                
                // Apply syntax highlighting
                Prism.highlightElement(modalCode);
                
                modal.style.display = 'block';
            }

            // Function to close modal
            document.querySelector('.close-modal').addEventListener('click', () => {
                const modal = document.getElementById('codeModal');
                modal.style.display = 'none';
            });

            // Close modal when clicking outside

            window.addEventListener('click', (event) => {
                const modal = document.getElementById('codeModal');
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        </script>

        <!-- Shade effect overlays -->
        <div class="shade-effect-top"></div>
        <div class="shade-effect-bottom"></div>
        <div class="shade-effect-left"></div>
        <div class="shade-effect-right"></div>

        <footer id="footer">Arub Â© 2024 - 2025</footer>
        </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
        <script src="script.js"></script>
    </body>
</html>
